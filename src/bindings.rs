/* automatically generated by rust-bindgen 0.72.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const ZENOH_PICO: &[u8; 6] = b"1.5.0\0";
pub const ZENOH_PICO_MAJOR: u32 = 1;
pub const ZENOH_PICO_MINOR: u32 = 5;
pub const ZENOH_PICO_PATCH: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __MAC_15_2: u32 = 150200;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __IPHONE_18_2: u32 = 180200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __WATCHOS_11_2: u32 = 110200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __TVOS_18_2: u32 = 180200;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __BRIDGEOS_9_2: u32 = 90200;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __DRIVERKIT_24_2: u32 = 240200;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const __VISIONOS_2_2: u32 = 20200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const MAC_OS_VERSION_15_2: u32 = 150200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150200;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const _Z_ERR_MESSAGE_MASK: u32 = 136;
pub const _Z_ERR_ENTITY_MASK: u32 = 144;
pub const _Z_ERR_TRANSPORT_MASK: u32 = 152;
pub const _Z_ERR_CONFIG_MASK: u32 = 160;
pub const _Z_ERR_SCOUT_MASK: u32 = 168;
pub const _Z_ERR_SYSTEM_MASK: u32 = 176;
pub const _Z_ERR_GENERIC_MASK: u32 = 184;
pub const Z_FRAG_MAX_SIZE: u32 = 300000;
pub const Z_BATCH_UNICAST_SIZE: u32 = 65535;
pub const Z_BATCH_MULTICAST_SIZE: u32 = 8192;
pub const Z_CONFIG_SOCKET_TIMEOUT: u32 = 100;
pub const Z_TRANSPORT_LEASE: u32 = 10000;
pub const ZP_PERIODIC_SCHEDULER_MAX_TASKS: u32 = 64;
pub const Z_FEATURE_MULTI_THREAD: u32 = 1;
pub const Z_FEATURE_PUBLICATION: u32 = 1;
pub const Z_FEATURE_ADVANCED_PUBLICATION: u32 = 0;
pub const Z_FEATURE_SUBSCRIPTION: u32 = 1;
pub const Z_FEATURE_ADVANCED_SUBSCRIPTION: u32 = 0;
pub const Z_FEATURE_QUERY: u32 = 1;
pub const Z_FEATURE_QUERYABLE: u32 = 1;
pub const Z_FEATURE_LIVELINESS: u32 = 1;
pub const Z_FEATURE_RAWETH_TRANSPORT: u32 = 0;
pub const Z_FEATURE_INTEREST: u32 = 1;
pub const Z_FEATURE_LINK_TCP: u32 = 1;
pub const Z_FEATURE_LINK_BLUETOOTH: u32 = 0;
pub const Z_FEATURE_LINK_WS: u32 = 0;
pub const Z_FEATURE_LINK_SERIAL: u32 = 0;
pub const Z_FEATURE_LINK_SERIAL_USB: u32 = 0;
pub const Z_FEATURE_SCOUTING: u32 = 1;
pub const Z_FEATURE_LINK_UDP_MULTICAST: u32 = 1;
pub const Z_FEATURE_LINK_UDP_UNICAST: u32 = 1;
pub const Z_FEATURE_MULTICAST_TRANSPORT: u32 = 1;
pub const Z_FEATURE_UNICAST_TRANSPORT: u32 = 1;
pub const Z_FEATURE_FRAGMENTATION: u32 = 1;
pub const Z_FEATURE_ENCODING_VALUES: u32 = 1;
pub const Z_FEATURE_TCP_NODELAY: u32 = 1;
pub const Z_FEATURE_LOCAL_SUBSCRIBER: u32 = 0;
pub const Z_FEATURE_SESSION_CHECK: u32 = 1;
pub const Z_FEATURE_BATCHING: u32 = 1;
pub const Z_FEATURE_BATCH_TX_MUTEX: u32 = 0;
pub const Z_FEATURE_BATCH_PEER_MUTEX: u32 = 0;
pub const Z_FEATURE_MATCHING: u32 = 1;
pub const Z_FEATURE_RX_CACHE: u32 = 0;
pub const Z_FEATURE_UNICAST_PEER: u32 = 1;
pub const Z_FEATURE_AUTO_RECONNECT: u32 = 1;
pub const Z_FEATURE_MULTICAST_DECLARATIONS: u32 = 0;
pub const Z_FEATURE_PERIODIC_TASKS: u32 = 0;
pub const Z_CONFIG_MODE_KEY: u32 = 64;
pub const Z_CONFIG_MODE_CLIENT: &[u8; 7] = b"client\0";
pub const Z_CONFIG_MODE_PEER: &[u8; 5] = b"peer\0";
pub const Z_CONFIG_MODE_DEFAULT: &[u8; 7] = b"client\0";
pub const Z_CONFIG_CONNECT_KEY: u32 = 65;
pub const Z_CONFIG_LISTEN_KEY: u32 = 66;
pub const Z_CONFIG_USER_KEY: u32 = 67;
pub const Z_CONFIG_PASSWORD_KEY: u32 = 68;
pub const Z_CONFIG_MULTICAST_SCOUTING_KEY: u32 = 69;
pub const Z_CONFIG_MULTICAST_SCOUTING_DEFAULT: &[u8; 5] = b"true\0";
pub const Z_CONFIG_MULTICAST_LOCATOR_KEY: u32 = 70;
pub const Z_CONFIG_MULTICAST_LOCATOR_DEFAULT: &[u8; 21] = b"udp/224.0.0.224:7446\0";
pub const Z_CONFIG_SCOUTING_TIMEOUT_KEY: u32 = 71;
pub const Z_CONFIG_SCOUTING_TIMEOUT_DEFAULT: &[u8; 5] = b"1000\0";
pub const Z_CONFIG_SCOUTING_WHAT_KEY: u32 = 72;
pub const Z_CONFIG_SCOUTING_WHAT_DEFAULT: &[u8; 2] = b"3\0";
pub const Z_CONFIG_SESSION_ZID_KEY: u32 = 73;
pub const Z_CONFIG_ADD_TIMESTAMP_KEY: u32 = 74;
pub const Z_CONFIG_ADD_TIMESTAMP_DEFAULT: &[u8; 6] = b"false\0";
pub const Z_ZID_LENGTH: u32 = 16;
pub const Z_PROTO_VERSION: u32 = 9;
pub const Z_TRANSPORT_LEASE_EXPIRE_FACTOR: u32 = 3;
pub const Z_JOIN_INTERVAL: u32 = 2500;
pub const Z_SN_RESOLUTION: u32 = 2;
pub const Z_REQ_RESOLUTION: u32 = 2;
pub const Z_RX_CACHE_SIZE: u32 = 10;
pub const Z_GET_TIMEOUT_DEFAULT: u32 = 10000;
pub const Z_LISTEN_MAX_CONNECTION_NB: u32 = 10;
pub const USE_CLANG_STDARG: u32 = 0;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const L_ctermid: u32 = 1024;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const FD_SETSIZE: u32 = 1024;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const TIME_UTC: u32 = 1;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const _Z_DEFAULT_HASHMAP_CAPACITY: u32 = 16;
pub const _Z_DEFAULT_INT_MAP_CAPACITY: u32 = 16;
pub const INT_STR_MAP_KEYVALUE_SEPARATOR: u8 = 61u8;
pub const INT_STR_MAP_LIST_SEPARATOR: u8 = 59u8;
pub const Z_SELECTOR_TIME: &[u8; 7] = b"_time=\0";
pub const Z_SELECTOR_QUERY_MATCH: &[u8; 7] = b"_anyke\0";
pub const _Z_KEYEXPR_ADV_PREFIX: &[u8; 5] = b"@adv\0";
pub const _Z_KEYEXPR_PUB: &[u8; 4] = b"pub\0";
pub const _Z_KEYEXPR_SUB: &[u8; 4] = b"sub\0";
pub const _Z_KEYEXPR_UHLC: &[u8; 5] = b"uhlc\0";
pub const _Z_KEYEXPR_EMPTY: &[u8; 2] = b"_\0";
pub const _Z_KEYEXPR_STAR: &[u8; 2] = b"*\0";
pub const _Z_KEYEXPR_STARSTAR: &[u8; 3] = b"**\0";
pub const _Z_ENCODING_ID_DEFAULT: u32 = 0;
pub const Z_RESOURCE_ID_NONE: u32 = 0;
pub const Z_PRIORITIES_NUM: u32 = 8;
pub const ZENOH_ID_SIZE: u32 = 16;
pub const _Z_INTEREST_FLAG_KEYEXPRS: u32 = 1;
pub const _Z_INTEREST_FLAG_SUBSCRIBERS: u32 = 2;
pub const _Z_INTEREST_FLAG_QUERYABLES: u32 = 4;
pub const _Z_INTEREST_FLAG_TOKENS: u32 = 8;
pub const _Z_INTEREST_FLAG_RESTRICTED: u32 = 16;
pub const _Z_INTEREST_FLAG_CURRENT: u32 = 32;
pub const _Z_INTEREST_FLAG_FUTURE: u32 = 64;
pub const _Z_INTEREST_FLAG_AGGREGATE: u32 = 128;
pub const _Z_INTEREST_NOT_FINAL_MASK: u32 = 96;
pub const _Z_DEFAULT_UNICAST_BATCH_SIZE: u32 = 65535;
pub const _Z_DEFAULT_MULTICAST_BATCH_SIZE: u32 = 8192;
pub const _Z_DEFAULT_RESOLUTION_SIZE: u32 = 2;
pub const _Z_MSG_LEN_ENC_SIZE: u32 = 2;
pub const _Z_MID_MASK: u32 = 31;
pub const _Z_FLAGS_MASK: u32 = 224;
pub const _Z_MID_Z_OAM: u32 = 0;
pub const _Z_MID_Z_PUT: u32 = 1;
pub const _Z_MID_Z_DEL: u32 = 2;
pub const _Z_MID_Z_QUERY: u32 = 3;
pub const _Z_MID_Z_REPLY: u32 = 4;
pub const _Z_MID_Z_ERR: u32 = 5;
pub const _Z_FLAG_Z_Z: u32 = 128;
pub const _Z_FLAG_Z_D: u32 = 32;
pub const _Z_FLAG_Z_K: u32 = 128;
pub const _Z_FLAG_Z_R: u32 = 32;
pub const _Z_FLAG_Z_X: u32 = 0;
pub const _Z_FRAG_BUFF_BASE_SIZE: u32 = 128;
pub const _Z_FLAG_Z_E_E: u32 = 64;
pub const _Z_M_DEL_ID: u32 = 2;
pub const _Z_FLAG_Z_D_T: u32 = 32;
pub const _Z_M_PUT_ID: u32 = 1;
pub const _Z_FLAG_Z_P_E: u32 = 64;
pub const _Z_FLAG_Z_P_T: u32 = 32;
pub const _Z_FLAG_Z_Q_C: u32 = 32;
pub const _Z_FLAG_Z_Q_P: u32 = 64;
pub const _Z_FLAG_Z_R_C: u32 = 32;
pub const _Z_EXT_FULL_ID_MASK: u32 = 127;
pub const _Z_EXT_ID_MASK: u32 = 15;
pub const _Z_EXT_ENC_MASK: u32 = 96;
pub const _Z_MSG_EXT_ENC_UNIT: u32 = 0;
pub const _Z_MSG_EXT_ENC_ZINT: u32 = 32;
pub const _Z_MSG_EXT_ENC_ZBUF: u32 = 64;
pub const _Z_MSG_EXT_FLAG_M: u32 = 16;
pub const _Z_MSG_EXT_FLAG_Z: u32 = 128;
pub const _Z_MID_N_OAM: u32 = 31;
pub const _Z_MID_N_DECLARE: u32 = 30;
pub const _Z_MID_N_PUSH: u32 = 29;
pub const _Z_MID_N_REQUEST: u32 = 28;
pub const _Z_MID_N_RESPONSE: u32 = 27;
pub const _Z_MID_N_RESPONSE_FINAL: u32 = 26;
pub const _Z_MID_N_INTEREST: u32 = 25;
pub const _Z_FLAG_N_Z: u32 = 128;
pub const _Z_FLAG_N_DECLARE_I: u32 = 32;
pub const _Z_FLAG_N_INTEREST_CURRENT: u32 = 32;
pub const _Z_FLAG_N_INTEREST_FUTURE: u32 = 64;
pub const _Z_FLAG_N_PUSH_N: u32 = 32;
pub const _Z_FLAG_N_PUSH_M: u32 = 64;
pub const _Z_FLAG_N_REQUEST_N: u32 = 32;
pub const _Z_FLAG_N_REQUEST_M: u32 = 64;
pub const _Z_FLAG_N_RESPONSE_N: u32 = 32;
pub const _Z_FLAG_N_RESPONSE_M: u32 = 64;
pub const _Z_N_QOS_IS_EXPRESS_FLAG: u32 = 16;
pub const TCP_SCHEMA: &[u8; 4] = b"tcp\0";
pub const UDP_SCHEMA: &[u8; 4] = b"udp\0";
pub const LOCATOR_PROTOCOL_SEPARATOR: u8 = 47u8;
pub const LOCATOR_METADATA_SEPARATOR: u8 = 63u8;
pub const ENDPOINT_CONFIG_SEPARATOR: u8 = 35u8;
pub const _Z_MID_SCOUT: u32 = 1;
pub const _Z_MID_HELLO: u32 = 2;
pub const _Z_MID_T_OAM: u32 = 0;
pub const _Z_MID_T_INIT: u32 = 1;
pub const _Z_MID_T_OPEN: u32 = 2;
pub const _Z_MID_T_CLOSE: u32 = 3;
pub const _Z_MID_T_KEEP_ALIVE: u32 = 4;
pub const _Z_MID_T_FRAME: u32 = 5;
pub const _Z_MID_T_FRAGMENT: u32 = 6;
pub const _Z_MID_T_JOIN: u32 = 7;
pub const _Z_FLAG_T_Z: u32 = 128;
pub const _Z_FLAG_T_SCOUT_I: u32 = 8;
pub const _Z_FLAG_T_HELLO_L: u32 = 32;
pub const _Z_FLAG_T_JOIN_T: u32 = 32;
pub const _Z_FLAG_T_JOIN_S: u32 = 64;
pub const _Z_FLAG_T_INIT_A: u32 = 32;
pub const _Z_FLAG_T_INIT_S: u32 = 64;
pub const _Z_FLAG_T_OPEN_A: u32 = 32;
pub const _Z_FLAG_T_OPEN_T: u32 = 64;
pub const _Z_FLAG_T_FRAME_R: u32 = 32;
pub const _Z_FLAG_T_FRAGMENT_R: u32 = 32;
pub const _Z_FLAG_T_FRAGMENT_M: u32 = 64;
pub const _Z_FLAG_T_CLOSE_S: u32 = 32;
pub const _Z_NO_PATCH: u32 = 0;
pub const _Z_CURRENT_PATCH: u32 = 1;
pub const _Z_CLOSE_GENERIC: u32 = 0;
pub const _Z_CLOSE_UNSUPPORTED: u32 = 1;
pub const _Z_CLOSE_INVALID: u32 = 2;
pub const _Z_CLOSE_MAX_TRANSPORTS: u32 = 3;
pub const _Z_CLOSE_MAX_LINKS: u32 = 4;
pub const _Z_CLOSE_EXPIRED: u32 = 5;
pub const _Z_RES_POOL_INIT_SIZE: u32 = 8;
pub const _Z_MATCHING_LISTENER_CTX_NULL_ID: u32 = 4294967295;
pub const _Z_QUERYABLE_COMPLETE_DEFAULT: u32 = 0;
pub const _Z_QUERYABLE_DISTANCE_DEFAULT: u32 = 0;
pub const Z_INFO_PID_KEY: u32 = 0;
pub const Z_INFO_PEER_PID_KEY: u32 = 1;
pub const Z_INFO_ROUTER_PID_KEY: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __darwin_intptr_t = ::core::ffi::c_long;
pub type __darwin_natural_t = ::core::ffi::c_uint;
pub type __darwin_ct_rune_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::core::ffi::c_char; 128usize],
    pub _mbstateL: ::core::ffi::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::core::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::core::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::core::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::core::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::core::ffi::c_long;
pub type __darwin_size_t = ::core::ffi::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::core::ffi::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::core::ffi::c_int;
pub type __darwin_clock_t = ::core::ffi::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::core::ffi::c_long;
pub type __darwin_time_t = ::core::ffi::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::core::ffi::c_uint;
pub type __darwin_fsfilcnt_t = ::core::ffi::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::core::ffi::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::core::ffi::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    pub __arg: *mut ::core::ffi::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::core::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::core::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::core::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::core::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::core::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::core::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::core::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::core::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::core::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::core::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::core::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"]
        [::core::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::core::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::core::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::core::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::core::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::core::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::core::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::core::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::core::ffi::c_long,
    pub __opaque: [::core::ffi::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::core::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::core::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::core::ffi::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::core::ffi::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::core::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::core::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::core::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::core::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::core::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::core::ffi::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::core::ffi::c_long;
pub type uintmax_t = ::core::ffi::c_ulong;
pub type rsize_t = ::core::ffi::c_ulong;
pub type wchar_t = ::core::ffi::c_int;
pub type max_align_t = f64;
unsafe extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> !;
}
pub type __darwin_nl_item = ::core::ffi::c_int;
pub type __darwin_wctrans_t = ::core::ffi::c_int;
pub type __darwin_wctype_t = __uint32_t;
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn memcpy(
        __dst: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dst: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __len: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __b: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __len: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn strcat(
        __s1: *mut ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcpy(
        __dst: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __charset: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strncat(
        __s1: *mut ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncpy(
        __dst: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __charset: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __charset: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strstr(
        __big: *const ::core::ffi::c_char,
        __little: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __str: *mut ::core::ffi::c_char,
        __sep: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strxfrm(
        __s1: *mut ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strtok_r(
        __str: *mut ::core::ffi::c_char,
        __sep: *const ::core::ffi::c_char,
        __lasts: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __strerrbuf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strdup(__s1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn memccpy(
        __dst: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dst: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dst: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __s1: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnlen(__s1: *const ::core::ffi::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
pub type errno_t = ::core::ffi::c_int;
unsafe extern "C" {
    pub fn memset_s(
        __s: *mut ::core::ffi::c_void,
        __smax: rsize_t,
        __c: ::core::ffi::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
pub type u_int8_t = ::core::ffi::c_uchar;
pub type u_int16_t = ::core::ffi::c_ushort;
pub type u_int32_t = ::core::ffi::c_uint;
pub type u_int64_t = ::core::ffi::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
unsafe extern "C" {
    pub fn memmem(
        __big: *const ::core::ffi::c_void,
        __big_len: usize,
        __little: *const ::core::ffi::c_void,
        __little_len: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::core::ffi::c_void,
        __pattern4: *const ::core::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::core::ffi::c_void,
        __pattern8: *const ::core::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::core::ffi::c_void,
        __pattern16: *const ::core::ffi::c_void,
        __len: usize,
    );
}
unsafe extern "C" {
    pub fn strcasestr(
        __big: *const ::core::ffi::c_char,
        __little: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strnstr(
        __big: *const ::core::ffi::c_char,
        __little: *const ::core::ffi::c_char,
        __len: usize,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn strlcat(
        __dst: *mut ::core::ffi::c_char,
        __source: *const ::core::ffi::c_char,
        __size: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dst: *mut ::core::ffi::c_char,
        __source: *const ::core::ffi::c_char,
        __size: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strmode(__mode: ::core::ffi::c_int, __bp: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn swab(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: isize);
}
unsafe extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::core::ffi::c_void,
        __b2: *const ::core::ffi::c_void,
        __len: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strsignal_r(
        __sig: ::core::ffi::c_int,
        __strsignalbuf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bcmp(
        arg1: *const ::core::ffi::c_void,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bcopy(arg1: *const ::core::ffi::c_void, arg2: *mut ::core::ffi::c_void, arg3: usize);
}
unsafe extern "C" {
    pub fn bzero(arg1: *mut ::core::ffi::c_void, arg2: ::core::ffi::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        arg1: *const ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ffs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ffsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fls(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn flsl(arg1: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn flsll(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
pub type z_result_t = i8;
pub const _z_res_t__Z_RES_OK: _z_res_t = 0;
pub const _z_res_t_Z_OK: _z_res_t = 0;
pub const _z_res_t__Z_RES_CHANNEL_CLOSED: _z_res_t = 1;
pub const _z_res_t_Z_CHANNEL_DISCONNECTED: _z_res_t = 1;
pub const _z_res_t__Z_RES_CHANNEL_NODATA: _z_res_t = 2;
pub const _z_res_t_Z_CHANNEL_NODATA: _z_res_t = 2;
pub const _z_res_t__Z_NO_DATA_PROCESSED: _z_res_t = 3;
pub const _z_res_t_Z_NO_DATA_PROCESSED: _z_res_t = 3;
pub const _z_res_t__Z_ERR_MESSAGE_DESERIALIZATION_FAILED: _z_res_t = -119;
pub const _z_res_t__Z_ERR_MESSAGE_SERIALIZATION_FAILED: _z_res_t = -118;
pub const _z_res_t__Z_ERR_MESSAGE_UNEXPECTED: _z_res_t = -117;
pub const _z_res_t__Z_ERR_MESSAGE_FLAG_UNEXPECTED: _z_res_t = -116;
pub const _z_res_t__Z_ERR_MESSAGE_ZENOH_DECLARATION_UNKNOWN: _z_res_t = -115;
pub const _z_res_t__Z_ERR_MESSAGE_ZENOH_UNKNOWN: _z_res_t = -114;
pub const _z_res_t__Z_ERR_MESSAGE_TRANSPORT_UNKNOWN: _z_res_t = -113;
pub const _z_res_t__Z_ERR_MESSAGE_EXTENSION_MANDATORY_AND_UNKNOWN: _z_res_t = -112;
pub const _z_res_t__Z_ERR_ENTITY_DECLARATION_FAILED: _z_res_t = -111;
pub const _z_res_t__Z_ERR_ENTITY_UNKNOWN: _z_res_t = -110;
pub const _z_res_t__Z_ERR_KEYEXPR_UNKNOWN: _z_res_t = -109;
pub const _z_res_t__Z_ERR_KEYEXPR_NOT_MATCH: _z_res_t = -108;
pub const _z_res_t__Z_ERR_QUERY_NOT_MATCH: _z_res_t = -107;
pub const _z_res_t__Z_ERR_TRANSPORT_NOT_AVAILABLE: _z_res_t = -103;
pub const _z_res_t__Z_ERR_TRANSPORT_OPEN_FAILED: _z_res_t = -102;
pub const _z_res_t__Z_ERR_TRANSPORT_OPEN_SN_RESOLUTION: _z_res_t = -101;
pub const _z_res_t__Z_ERR_TRANSPORT_TX_FAILED: _z_res_t = -100;
pub const _z_res_t__Z_ERR_TRANSPORT_RX_FAILED: _z_res_t = -99;
pub const _z_res_t__Z_ERR_TRANSPORT_NO_SPACE: _z_res_t = -98;
pub const _z_res_t__Z_ERR_TRANSPORT_NOT_ENOUGH_BYTES: _z_res_t = -97;
pub const _z_res_t__Z_ERR_CONFIG_FAILED_INSERT: _z_res_t = -95;
pub const _z_res_t__Z_ERR_CONFIG_UNSUPPORTED_CLIENT_MULTICAST: _z_res_t = -94;
pub const _z_res_t__Z_ERR_CONFIG_UNSUPPORTED_PEER_UNICAST: _z_res_t = -93;
pub const _z_res_t__Z_ERR_CONFIG_LOCATOR_SCHEMA_UNKNOWN: _z_res_t = -92;
pub const _z_res_t__Z_ERR_CONFIG_LOCATOR_INVALID: _z_res_t = -91;
pub const _z_res_t__Z_ERR_CONFIG_INVALID_MODE: _z_res_t = -90;
pub const _z_res_t__Z_ERR_SCOUT_NO_RESULTS: _z_res_t = -87;
pub const _z_res_t__Z_ERR_SYSTEM_GENERIC: _z_res_t = -80;
pub const _z_res_t__Z_ERR_SYSTEM_TASK_FAILED: _z_res_t = -79;
pub const _z_res_t__Z_ERR_SYSTEM_OUT_OF_MEMORY: _z_res_t = -78;
pub const _z_res_t__Z_ERR_CONNECTION_CLOSED: _z_res_t = -77;
pub const _z_res_t__Z_ERR_DID_NOT_READ: _z_res_t = -76;
pub const _z_res_t__Z_ERR_INVALID: _z_res_t = -75;
pub const _z_res_t_Z_EINVAL: _z_res_t = -75;
pub const _z_res_t__Z_ERR_OVERFLOW: _z_res_t = -74;
pub const _z_res_t__Z_ERR_SESSION_CLOSED: _z_res_t = -73;
pub const _z_res_t_Z_EDESERIALIZE: _z_res_t = -72;
pub const _z_res_t_Z_ETIMEDOUT: _z_res_t = -71;
pub const _z_res_t__Z_ERR_GENERIC: _z_res_t = -128;
pub type _z_res_t = ::core::ffi::c_int;
unsafe extern "C" {
    pub fn _z_rc_init(cnt: *mut *mut ::core::ffi::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_increase_strong(cnt: *mut ::core::ffi::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_increase_weak(cnt: *mut ::core::ffi::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_decrease_strong(cnt: *mut *mut ::core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_rc_decrease_weak(cnt: *mut *mut ::core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_rc_weak_upgrade(cnt: *mut ::core::ffi::c_void) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_rc_weak_count(cnt: *mut ::core::ffi::c_void) -> usize;
}
unsafe extern "C" {
    pub fn _z_rc_strong_count(cnt: *mut ::core::ffi::c_void) -> usize;
}
unsafe extern "C" {
    pub fn _z_simple_rc_value(rc: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_simple_rc_init(
        rc: *mut *mut ::core::ffi::c_void,
        val: *const ::core::ffi::c_void,
        val_size: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_simple_rc_increase(rc: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _z_simple_rc_decrease(rc: *mut ::core::ffi::c_void) -> bool;
}
unsafe extern "C" {
    pub fn _z_simple_rc_strong_count(rc: *mut ::core::ffi::c_void) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_delete_context_t {
    pub deleter: ::core::option::Option<
        unsafe extern "C" fn(data: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
    >,
    pub context: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_delete_context_t"][::core::mem::size_of::<_z_delete_context_t>() - 16usize];
    ["Alignment of _z_delete_context_t"][::core::mem::align_of::<_z_delete_context_t>() - 8usize];
    ["Offset of field: _z_delete_context_t::deleter"]
        [::core::mem::offset_of!(_z_delete_context_t, deleter) - 0usize];
    ["Offset of field: _z_delete_context_t::context"]
        [::core::mem::offset_of!(_z_delete_context_t, context) - 8usize];
};
unsafe extern "C" {
    pub fn _z_delete_context_default() -> _z_delete_context_t;
}
unsafe extern "C" {
    pub fn _z_delete_context_static() -> _z_delete_context_t;
}
#[doc = " An array of bytes.\n\n Members:\n   size_t len: The length of the bytes array.\n   uint8_t *start: A pointer to the bytes array.\n   _z_delete_context_t delete_context - context used to delete the data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_t {
    pub len: usize,
    pub start: *const u8,
    pub _delete_context: _z_delete_context_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_t"][::core::mem::size_of::<_z_slice_t>() - 32usize];
    ["Alignment of _z_slice_t"][::core::mem::align_of::<_z_slice_t>() - 8usize];
    ["Offset of field: _z_slice_t::len"][::core::mem::offset_of!(_z_slice_t, len) - 0usize];
    ["Offset of field: _z_slice_t::start"][::core::mem::offset_of!(_z_slice_t, start) - 8usize];
    ["Offset of field: _z_slice_t::_delete_context"]
        [::core::mem::offset_of!(_z_slice_t, _delete_context) - 16usize];
};
unsafe extern "C" {
    pub fn _z_slice_init(bs: *mut _z_slice_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_make(capacity: usize) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_copy_from_buf(bs: *const u8, len: usize) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_steal(b: *mut _z_slice_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_copy(dst: *mut _z_slice_t, src: *const _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_n_copy(
        dst: *mut _z_slice_t,
        src: *const _z_slice_t,
        offset: usize,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_duplicate(src: *const _z_slice_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_slice_move(dst: *mut _z_slice_t, src: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_slice_eq(left: *const _z_slice_t, right: *const _z_slice_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_slice_free(bs: *mut *mut _z_slice_t);
}
unsafe extern "C" {
    pub fn _z_slice_is_alloced(s: *const _z_slice_t) -> bool;
}
pub type va_list = __darwin_va_list;
unsafe extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn renamex_np(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn renameatx_np(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
        arg5: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sbuf"][::core::mem::size_of::<__sbuf>() - 16usize];
    ["Alignment of __sbuf"][::core::mem::align_of::<__sbuf>() - 8usize];
    ["Offset of field: __sbuf::_base"][::core::mem::offset_of!(__sbuf, _base) - 0usize];
    ["Offset of field: __sbuf::_size"][::core::mem::offset_of!(__sbuf, _size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
    >,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *mut ::core::ffi::c_char,
            arg3: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: fpos_t,
            arg3: ::core::ffi::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: *const ::core::ffi::c_char,
            arg3: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: fpos_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sFILE"][::core::mem::size_of::<__sFILE>() - 152usize];
    ["Alignment of __sFILE"][::core::mem::align_of::<__sFILE>() - 8usize];
    ["Offset of field: __sFILE::_p"][::core::mem::offset_of!(__sFILE, _p) - 0usize];
    ["Offset of field: __sFILE::_r"][::core::mem::offset_of!(__sFILE, _r) - 8usize];
    ["Offset of field: __sFILE::_w"][::core::mem::offset_of!(__sFILE, _w) - 12usize];
    ["Offset of field: __sFILE::_flags"][::core::mem::offset_of!(__sFILE, _flags) - 16usize];
    ["Offset of field: __sFILE::_file"][::core::mem::offset_of!(__sFILE, _file) - 18usize];
    ["Offset of field: __sFILE::_bf"][::core::mem::offset_of!(__sFILE, _bf) - 24usize];
    ["Offset of field: __sFILE::_lbfsize"][::core::mem::offset_of!(__sFILE, _lbfsize) - 40usize];
    ["Offset of field: __sFILE::_cookie"][::core::mem::offset_of!(__sFILE, _cookie) - 48usize];
    ["Offset of field: __sFILE::_close"][::core::mem::offset_of!(__sFILE, _close) - 56usize];
    ["Offset of field: __sFILE::_read"][::core::mem::offset_of!(__sFILE, _read) - 64usize];
    ["Offset of field: __sFILE::_seek"][::core::mem::offset_of!(__sFILE, _seek) - 72usize];
    ["Offset of field: __sFILE::_write"][::core::mem::offset_of!(__sFILE, _write) - 80usize];
    ["Offset of field: __sFILE::_ub"][::core::mem::offset_of!(__sFILE, _ub) - 88usize];
    ["Offset of field: __sFILE::_extra"][::core::mem::offset_of!(__sFILE, _extra) - 104usize];
    ["Offset of field: __sFILE::_ur"][::core::mem::offset_of!(__sFILE, _ur) - 112usize];
    ["Offset of field: __sFILE::_ubuf"][::core::mem::offset_of!(__sFILE, _ubuf) - 116usize];
    ["Offset of field: __sFILE::_nbuf"][::core::mem::offset_of!(__sFILE, _nbuf) - 119usize];
    ["Offset of field: __sFILE::_lb"][::core::mem::offset_of!(__sFILE, _lb) - 120usize];
    ["Offset of field: __sFILE::_blksize"][::core::mem::offset_of!(__sFILE, _blksize) - 136usize];
    ["Offset of field: __sFILE::_offset"][::core::mem::offset_of!(__sFILE, _offset) - 144usize];
};
pub type FILE = __sFILE;
unsafe extern "C" {
    pub static mut __stdinp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
unsafe extern "C" {
    pub static mut __stderrp: *mut FILE;
}
unsafe extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::core::ffi::c_char,
        __mode: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __nitems: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __nitems: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::core::ffi::c_char,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: __builtin_va_list)
    -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __swbuf(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
unsafe extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::core::ffi::c_char,
        __prefix: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
pub type off_t = __darwin_off_t;
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
unsafe extern "C" {
    pub fn snprintf(
        __str: *mut ::core::ffi::c_char,
        __size: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        arg1: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::core::ffi::c_char,
        arg1: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __str: *mut ::core::ffi::c_char,
        __size: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        arg1: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __str: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        arg1: __builtin_va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::core::ffi::c_char,
        __linecapp: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn getline(
        __linep: *mut *mut ::core::ffi::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
unsafe extern "C" {
    pub fn fmemopen(
        __buf: *mut ::core::ffi::c_void,
        __size: usize,
        __mode: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(__bufp: *mut *mut ::core::ffi::c_char, __sizep: *mut usize) -> *mut FILE;
}
unsafe extern "C" {
    pub static sys_nerr: ::core::ffi::c_int;
}
unsafe extern "C" {
    pub static sys_errlist: [*const ::core::ffi::c_char; 0usize];
}
unsafe extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ctermid_r(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fmtcheck(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
unsafe extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn funopen(
        arg1: *const ::core::ffi::c_void,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *mut ::core::ffi::c_char,
                arg3: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_char,
                arg3: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: fpos_t,
                arg3: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: ::core::ffi::c_int,
        arg4: usize,
        arg5: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: va_list,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: ::core::ffi::c_int,
        arg4: usize,
        arg5: *const ::core::ffi::c_char,
        arg6: va_list,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::core::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::core::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::fds_bits"][::core::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
unsafe extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_void,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::core::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::core::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::core::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::core::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::core::mem::offset_of!(timeval, tv_usec) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval64"][::core::mem::size_of::<timeval64>() - 16usize];
    ["Alignment of timeval64"][::core::mem::align_of::<timeval64>() - 8usize];
    ["Offset of field: timeval64::tv_sec"][::core::mem::offset_of!(timeval64, tv_sec) - 0usize];
    ["Offset of field: timeval64::tv_usec"][::core::mem::offset_of!(timeval64, tv_usec) - 8usize];
};
pub type time_t = __darwin_time_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerval"][::core::mem::size_of::<itimerval>() - 32usize];
    ["Alignment of itimerval"][::core::mem::align_of::<itimerval>() - 8usize];
    ["Offset of field: itimerval::it_interval"]
        [::core::mem::offset_of!(itimerval, it_interval) - 0usize];
    ["Offset of field: itimerval::it_value"]
        [::core::mem::offset_of!(itimerval, it_value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::core::ffi::c_int,
    pub tz_dsttime: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timezone"][::core::mem::size_of::<timezone>() - 8usize];
    ["Alignment of timezone"][::core::mem::align_of::<timezone>() - 4usize];
    ["Offset of field: timezone::tz_minuteswest"]
        [::core::mem::offset_of!(timezone, tz_minuteswest) - 0usize];
    ["Offset of field: timezone::tz_dsttime"]
        [::core::mem::offset_of!(timezone, tz_dsttime) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::core::ffi::c_int,
    pub tick: ::core::ffi::c_int,
    pub tickadj: ::core::ffi::c_int,
    pub stathz: ::core::ffi::c_int,
    pub profhz: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clockinfo"][::core::mem::size_of::<clockinfo>() - 20usize];
    ["Alignment of clockinfo"][::core::mem::align_of::<clockinfo>() - 4usize];
    ["Offset of field: clockinfo::hz"][::core::mem::offset_of!(clockinfo, hz) - 0usize];
    ["Offset of field: clockinfo::tick"][::core::mem::offset_of!(clockinfo, tick) - 4usize];
    ["Offset of field: clockinfo::tickadj"][::core::mem::offset_of!(clockinfo, tickadj) - 8usize];
    ["Offset of field: clockinfo::stathz"][::core::mem::offset_of!(clockinfo, stathz) - 12usize];
    ["Offset of field: clockinfo::profhz"][::core::mem::offset_of!(clockinfo, profhz) - 16usize];
};
pub type clock_t = __darwin_clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *mut ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::core::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::core::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::core::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::core::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::core::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::core::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::core::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::core::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::core::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::core::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::core::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::core::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::core::mem::offset_of!(tm, tm_zone) - 48usize];
};
unsafe extern "C" {
    pub static mut tzname: [*mut ::core::ffi::c_char; 0usize];
}
unsafe extern "C" {
    pub static mut getdate_err: ::core::ffi::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::core::ffi::c_long;
}
unsafe extern "C" {
    pub static mut daylight: ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
unsafe extern "C" {
    pub fn getdate(arg1: *const ::core::ffi::c_char) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strptime(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut tm,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::core::ffi::c_char)
    -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
unsafe extern "C" {
    pub fn tzsetwall();
}
unsafe extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::core::ffi::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::core::ffi::c_uint;
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn futimes(arg1: ::core::ffi::c_int, arg2: *const timeval) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn lutimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getitimer(arg1: ::core::ffi::c_int, arg2: *mut itimerval) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn gettimeofday(arg1: *mut timeval, arg2: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn select(
        arg1: ::core::ffi::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setitimer(
        arg1: ::core::ffi::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn utimes(arg1: *const ::core::ffi::c_char, arg2: *const timeval) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::core::ffi::c_int,
    pub __opaque: [::core::ffi::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::core::mem::size_of::<sched_param>() - 8usize];
    ["Alignment of sched_param"][::core::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::core::mem::offset_of!(sched_param, sched_priority) - 0usize];
    ["Offset of field: sched_param::__opaque"]
        [::core::mem::offset_of!(sched_param, __opaque) - 4usize];
};
unsafe extern "C" {
    pub fn sched_yield() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub type qos_class_t = ::core::ffi::c_uint;
unsafe extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
unsafe extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
unsafe extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
unsafe extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::core::ffi::c_int,
    ) -> pthread_override_t;
}
unsafe extern "C" {
    pub fn pthread_override_qos_class_end_np(__override: pthread_override_t) -> ::core::ffi::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
pub type sigset_t = __darwin_sigset_t;
unsafe extern "C" {
    pub fn pthread_atfork(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
        arg3: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::core::ffi::c_void,
        arg3: *mut usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(arg1: *mut pthread_attr_t, arg2: usize) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(arg1: *mut pthread_attr_t, arg2: usize) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
        >,
        arg4: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(arg1: *mut ::core::ffi::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_getconcurrency() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::core::ffi::c_int,
        arg3: *mut sched_param,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn pthread_join(arg1: pthread_t, arg2: *mut *mut ::core::ffi::c_void)
    -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void)>,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setconcurrency(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::core::ffi::c_int,
        arg3: *const sched_param,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
unsafe extern "C" {
    pub fn pthread_is_threaded_np() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_setname_np(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_main_np() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
unsafe extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
unsafe extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
        >,
        arg4: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        arg1: ::core::ffi::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_yield_np();
}
unsafe extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::core::ffi::c_int);
}
unsafe extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::core::ffi::c_int;
}
pub type pthread_jit_write_callback_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
unsafe extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
unsafe extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut usize) -> ::core::ffi::c_int;
}
pub type _z_task_t = pthread_t;
pub type z_task_attr_t = pthread_attr_t;
pub type _z_mutex_t = pthread_mutex_t;
pub type _z_mutex_rec_t = pthread_mutex_t;
pub type _z_condvar_t = pthread_cond_t;
pub type z_clock_t = timespec;
pub type z_time_t = timeval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_socket_t {
    pub __bindgen_anon_1: _z_sys_net_socket_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_socket_t__bindgen_ty_1 {
    pub _fd: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _z_sys_net_socket_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_sys_net_socket_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _z_sys_net_socket_t__bindgen_ty_1::_fd"]
        [::core::mem::offset_of!(_z_sys_net_socket_t__bindgen_ty_1, _fd) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_socket_t"][::core::mem::size_of::<_z_sys_net_socket_t>() - 4usize];
    ["Alignment of _z_sys_net_socket_t"][::core::mem::align_of::<_z_sys_net_socket_t>() - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_sys_net_endpoint_t {
    pub __bindgen_anon_1: _z_sys_net_endpoint_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_sys_net_endpoint_t__bindgen_ty_1 {
    pub _iptcp: *mut addrinfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_sys_net_endpoint_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_sys_net_endpoint_t__bindgen_ty_1::_iptcp"]
        [::core::mem::offset_of!(_z_sys_net_endpoint_t__bindgen_ty_1, _iptcp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sys_net_endpoint_t"][::core::mem::size_of::<_z_sys_net_endpoint_t>() - 8usize];
    ["Alignment of _z_sys_net_endpoint_t"]
        [::core::mem::align_of::<_z_sys_net_endpoint_t>() - 8usize];
};
unsafe extern "C" {
    pub fn _z_report_system_error(errcode: ::core::ffi::c_int);
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 8-bit integer."]
    pub fn z_random_u8() -> u8;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 16-bit integer."]
    pub fn z_random_u16() -> u16;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 32-bit integer."]
    pub fn z_random_u32() -> u32;
}
unsafe extern "C" {
    #[doc = " Generates a random unsigned 64-bit integer."]
    pub fn z_random_u64() -> u64;
}
unsafe extern "C" {
    #[doc = " Fills buffer with random data.\n\n Parameters:\n   buf: Pointer to the buffer that will be filled with random data.\n   len: Number of bytes to fill in the buffer."]
    pub fn z_random_fill(buf: *mut ::core::ffi::c_void, len: usize);
}
unsafe extern "C" {
    #[doc = " Allocates memory of the specified size.\n\n Parameters:\n   size: The number of bytes to allocate.\n\n Returns:\n   A pointer to the allocated memory, or NULL if the allocation fails."]
    pub fn z_malloc(size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Reallocates the given memory block to a new size.\n\n Parameters:\n   ptr: Pointer to the previously allocated memory. Can be NULL, in which case it behaves like z_malloc().\n   size: The new size for the memory block in bytes.\n\n Returns:\n   A pointer to the reallocated memory, or NULL if the reallocation fails."]
    pub fn z_realloc(ptr: *mut ::core::ffi::c_void, size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " Frees the memory previously allocated by z_malloc or z_realloc.\n\n Parameters:\n   ptr: Pointer to the memory to be freed. If NULL, no action is taken."]
    pub fn z_free(ptr: *mut ::core::ffi::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_task_t {
    pub _val: _z_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_task_t"][::core::mem::size_of::<z_owned_task_t>() - 8usize];
    ["Alignment of z_owned_task_t"][::core::mem::align_of::<z_owned_task_t>() - 8usize];
    ["Offset of field: z_owned_task_t::_val"]
        [::core::mem::offset_of!(z_owned_task_t, _val) - 0usize];
};
pub type z_loaned_task_t = _z_task_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_task_t {
    pub _this: z_owned_task_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_task_t"][::core::mem::size_of::<z_moved_task_t>() - 8usize];
    ["Alignment of z_moved_task_t"][::core::mem::align_of::<z_moved_task_t>() - 8usize];
    ["Offset of field: z_moved_task_t::_this"]
        [::core::mem::offset_of!(z_moved_task_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_task_null(obj: *mut z_owned_task_t);
}
unsafe extern "C" {
    pub fn z_task_take(obj: *mut z_owned_task_t, src: *mut z_moved_task_t);
}
unsafe extern "C" {
    pub fn z_task_loan(obj: *const z_owned_task_t) -> *const z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_loan_mut(obj: *mut z_owned_task_t) -> *mut z_loaned_task_t;
}
unsafe extern "C" {
    pub fn z_task_move(obj: *mut z_owned_task_t) -> *mut z_moved_task_t;
}
unsafe extern "C" {
    pub fn _z_task_init(
        task: *mut _z_task_t,
        attr: *mut z_task_attr_t,
        fun: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_join(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_detach(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_cancel(task: *mut _z_task_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_task_exit();
}
unsafe extern "C" {
    pub fn _z_task_free(task: *mut *mut _z_task_t);
}
unsafe extern "C" {
    #[doc = " Constructs a new task.\n\n Parameters:\n   task: An uninitialized memory location where task will be constructed.\n   attr: Attributes of the task.\n   fun: Function to be executed by the task.\n   arg: Argument that will be passed to the function `fun`.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_init(
        task: *mut z_owned_task_t,
        attr: *mut z_task_attr_t,
        fun: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
        >,
        arg: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Joins the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be joined.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_join(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Detaches the task and releases all allocated resources.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be detached.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_detach(task: *mut z_moved_task_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops the task. Same as :c:func:`z_task_detach`. Use :c:func:`z_task_join` to wait for the task completion.\n\n Parameters:\n   task: Pointer to a :c:type:`z_moved_task_t` representing the task to be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_task_drop(task: *mut z_moved_task_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_mutex_t {
    pub _val: _z_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_mutex_t"][::core::mem::size_of::<z_owned_mutex_t>() - 64usize];
    ["Alignment of z_owned_mutex_t"][::core::mem::align_of::<z_owned_mutex_t>() - 8usize];
    ["Offset of field: z_owned_mutex_t::_val"]
        [::core::mem::offset_of!(z_owned_mutex_t, _val) - 0usize];
};
pub type z_loaned_mutex_t = _z_mutex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_mutex_t {
    pub _this: z_owned_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_mutex_t"][::core::mem::size_of::<z_moved_mutex_t>() - 64usize];
    ["Alignment of z_moved_mutex_t"][::core::mem::align_of::<z_moved_mutex_t>() - 8usize];
    ["Offset of field: z_moved_mutex_t::_this"]
        [::core::mem::offset_of!(z_moved_mutex_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_mutex_null(obj: *mut z_owned_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_take(obj: *mut z_owned_mutex_t, src: *mut z_moved_mutex_t);
}
unsafe extern "C" {
    pub fn z_mutex_loan(obj: *const z_owned_mutex_t) -> *const z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_loan_mut(obj: *mut z_owned_mutex_t) -> *mut z_loaned_mutex_t;
}
unsafe extern "C" {
    pub fn z_mutex_move(obj: *mut z_owned_mutex_t) -> *mut z_moved_mutex_t;
}
unsafe extern "C" {
    pub fn _z_mutex_init(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_drop(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_lock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_try_lock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_unlock(m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_init(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_drop(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_lock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_try_lock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_mutex_rec_unlock(m: *mut _z_mutex_rec_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs a mutex.\n\n Parameters:\n   m: Pointer to an uninitialized :c:type:`z_owned_mutex_t` that will be constructed.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_init(m: *mut z_owned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Drops a mutex and resets it to its gravestone state.\n\n Parameters:\n   m: Pointer to a :c:type:`z_moved_mutex_t` that will be dropped.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_drop(m: *mut z_moved_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Locks a mutex. If the mutex is already locked, blocks the thread until it acquires the lock.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Tries to lock a mutex. If the mutex is already locked, the function returns immediately.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be locked if not already locked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_try_lock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Unlocks a previously locked mutex. If the mutex was not locked by the current thread, the behavior is undefined.\n\n Parameters:\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked.\n\n Returns:\n   ``0`` in case of success, negative error code otherwise."]
    pub fn z_mutex_unlock(m: *mut z_loaned_mutex_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_condvar_t {
    pub _val: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_condvar_t"][::core::mem::size_of::<z_owned_condvar_t>() - 48usize];
    ["Alignment of z_owned_condvar_t"][::core::mem::align_of::<z_owned_condvar_t>() - 8usize];
    ["Offset of field: z_owned_condvar_t::_val"]
        [::core::mem::offset_of!(z_owned_condvar_t, _val) - 0usize];
};
pub type z_loaned_condvar_t = _z_condvar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_condvar_t {
    pub _this: z_owned_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_condvar_t"][::core::mem::size_of::<z_moved_condvar_t>() - 48usize];
    ["Alignment of z_moved_condvar_t"][::core::mem::align_of::<z_moved_condvar_t>() - 8usize];
    ["Offset of field: z_moved_condvar_t::_this"]
        [::core::mem::offset_of!(z_moved_condvar_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_condvar_null(obj: *mut z_owned_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_take(obj: *mut z_owned_condvar_t, src: *mut z_moved_condvar_t);
}
unsafe extern "C" {
    pub fn z_condvar_loan(obj: *const z_owned_condvar_t) -> *const z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_loan_mut(obj: *mut z_owned_condvar_t) -> *mut z_loaned_condvar_t;
}
unsafe extern "C" {
    pub fn z_condvar_move(obj: *mut z_owned_condvar_t) -> *mut z_moved_condvar_t;
}
unsafe extern "C" {
    pub fn _z_condvar_init(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_drop(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_signal(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_signal_all(cv: *mut _z_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_wait(cv: *mut _z_condvar_t, m: *mut _z_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_condvar_wait_until(
        cv: *mut _z_condvar_t,
        m: *mut _z_mutex_t,
        abstime: *const z_clock_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initializes a condition variable.\n\n Parameters:\n   cv: Pointer to an uninitialized :c:type:`z_owned_condvar_t` that will be initialized.\n\n Returns:\n   ``0`` if the initialization is successful, a negative value otherwise."]
    pub fn z_condvar_init(cv: *mut z_owned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Destroys a condition variable and releases its resources.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_moved_condvar_t` that will be destroyed.\n\n Returns:\n   ``0`` if the destruction is successful, a negative value otherwise."]
    pub fn z_condvar_drop(cv: *mut z_moved_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Signals (wakes up) one thread waiting on the condition variable.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` that will be signaled.\n\n Returns:\n   ``0`` if the signal is successful, a negative value otherwise."]
    pub fn z_condvar_signal(cv: *mut z_loaned_condvar_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex.\n\n The calling thread is blocked until the condition variable is signaled.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n\n Returns:\n   ``0`` if the wait is successful, a negative value otherwise."]
    pub fn z_condvar_wait(cv: *mut z_loaned_condvar_t, m: *mut z_loaned_mutex_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Waits for a signal on the condition variable while holding a mutex until a specified time.\n\n The calling thread is blocked until the condition variable is signaled or the timeout occurs.\n The associated mutex must be locked by the calling thread, and it will be automatically unlocked while waiting.\n\n Parameters:\n   cv: Pointer to a :c:type:`z_loaned_condvar_t` on which to wait.\n   m: Pointer to a :c:type:`z_loaned_mutex_t` that will be unlocked during the wait.\n   abstime: Absolute end time.\n\n Returns:\n   ``0`` if the wait is successful, ``Z_ETIMEDOUT`` if a timeout occurred, other negative value otherwise."]
    pub fn z_condvar_wait_until(
        cv: *mut z_loaned_condvar_t,
        m: *mut z_loaned_mutex_t,
        abstime: *const z_clock_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in microseconds.\n\n Parameters:\n   time: The amount of time to sleep, in microseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_us(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in milliseconds.\n\n Parameters:\n   time: The amount of time to sleep, in milliseconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_ms(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Suspends execution for a specified amount of time in seconds.\n\n Parameters:\n   time: The amount of time to sleep, in seconds.\n\n Returns:\n   ``0`` if the sleep is successful, a negative value otherwise."]
    pub fn z_sleep_s(time: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns monotonic clock time point corresponding to the current time instant."]
    pub fn z_clock_now() -> z_clock_t;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_clock_elapsed_us(time: *mut z_clock_t) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_clock_elapsed_ms(time: *mut z_clock_t) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given clock time.\n\n Parameters:\n   time: Pointer to a `z_clock_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_clock_elapsed_s(time: *mut z_clock_t) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in microseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in microseconds."]
    pub fn z_clock_advance_us(clock: *mut z_clock_t, duration: ::core::ffi::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in milliseconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in milliseconds."]
    pub fn z_clock_advance_ms(clock: *mut z_clock_t, duration: ::core::ffi::c_ulong);
}
unsafe extern "C" {
    #[doc = " Offsets the clock by a specified duration in seconds.\n\n Parameters:\n   clock: Pointer to a `z_clock_t` to offset.\n   duration: The duration in seconds."]
    pub fn z_clock_advance_s(clock: *mut z_clock_t, duration: ::core::ffi::c_ulong);
}
unsafe extern "C" {
    #[doc = " Returns system clock time point corresponding to the current time instant."]
    pub fn z_time_now() -> z_time_t;
}
unsafe extern "C" {
    #[doc = " Gets the current time as a string.\n\n Parameters:\n   buf: Pointer to a buffer where the time string will be written.\n   buflen: The length of the buffer.\n\n Returns:\n   A pointer to the buffer containing the time string."]
    pub fn z_time_now_as_str(
        buf: *mut ::core::ffi::c_char,
        buflen: ::core::ffi::c_ulong,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in microseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in microseconds."]
    pub fn z_time_elapsed_us(time: *mut z_time_t) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in milliseconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in milliseconds."]
    pub fn z_time_elapsed_ms(time: *mut z_time_t) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    #[doc = " Returns the elapsed time in seconds since a given time.\n\n Parameters:\n   time: Pointer to a `z_time_t` representing the starting time.\n\n Returns:\n   The elapsed time in seconds."]
    pub fn z_time_elapsed_s(time: *mut z_time_t) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_time_since_epoch {
    pub secs: u32,
    pub nanos: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_time_since_epoch"][::core::mem::size_of::<_z_time_since_epoch>() - 8usize];
    ["Alignment of _z_time_since_epoch"][::core::mem::align_of::<_z_time_since_epoch>() - 4usize];
    ["Offset of field: _z_time_since_epoch::secs"]
        [::core::mem::offset_of!(_z_time_since_epoch, secs) - 0usize];
    ["Offset of field: _z_time_since_epoch::nanos"]
        [::core::mem::offset_of!(_z_time_since_epoch, nanos) - 4usize];
};
unsafe extern "C" {
    pub fn _z_get_time_since_epoch(t: *mut _z_time_since_epoch) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_set_non_blocking(sock: *const _z_sys_net_socket_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_accept(
        sock_in: *const _z_sys_net_socket_t,
        sock_out: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_socket_close(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_socket_wait_event(
        peers: *mut ::core::ffi::c_void,
        mutex: *mut _z_mutex_rec_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_slice_simple_rc_t {
    pub _val: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_slice_simple_rc_t"][::core::mem::size_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Alignment of _z_slice_simple_rc_t"][::core::mem::align_of::<_z_slice_simple_rc_t>() - 8usize];
    ["Offset of field: _z_slice_simple_rc_t::_val"]
        [::core::mem::offset_of!(_z_slice_simple_rc_t, _val) - 0usize];
};
#[doc = " An atomically reference counted subslice.\n\n Members:\n   _z_slice_simple_rc_t len: Rc counted slice.\n   size_t start: Offset to the subslice start.\n   size_t len: Length of the subslice."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_arc_slice_t {
    pub slice: _z_slice_simple_rc_t,
    pub start: usize,
    pub len: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_arc_slice_t"][::core::mem::size_of::<_z_arc_slice_t>() - 24usize];
    ["Alignment of _z_arc_slice_t"][::core::mem::align_of::<_z_arc_slice_t>() - 8usize];
    ["Offset of field: _z_arc_slice_t::slice"]
        [::core::mem::offset_of!(_z_arc_slice_t, slice) - 0usize];
    ["Offset of field: _z_arc_slice_t::start"]
        [::core::mem::offset_of!(_z_arc_slice_t, start) - 8usize];
    ["Offset of field: _z_arc_slice_t::len"]
        [::core::mem::offset_of!(_z_arc_slice_t, len) - 16usize];
};
unsafe extern "C" {
    pub fn _z_arc_slice_wrap(s: *mut _z_slice_t, offset: usize, len: usize) -> _z_arc_slice_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_get_subslice(
        s: *const _z_arc_slice_t,
        offset: usize,
        len: usize,
    ) -> _z_arc_slice_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_copy(dst: *mut _z_arc_slice_t, src: *const _z_arc_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_arc_slice_move(dst: *mut _z_arc_slice_t, src: *mut _z_arc_slice_t) -> z_result_t;
}
pub type z_element_size_f =
    ::core::option::Option<unsafe extern "C" fn(e: *mut ::core::ffi::c_void) -> usize>;
pub type z_element_clear_f =
    ::core::option::Option<unsafe extern "C" fn(e: *mut ::core::ffi::c_void)>;
pub type z_element_free_f =
    ::core::option::Option<unsafe extern "C" fn(e: *mut *mut ::core::ffi::c_void)>;
pub type z_element_copy_f = ::core::option::Option<
    unsafe extern "C" fn(dst: *mut ::core::ffi::c_void, src: *const ::core::ffi::c_void),
>;
pub type z_element_move_f = ::core::option::Option<
    unsafe extern "C" fn(dst: *mut ::core::ffi::c_void, src: *mut ::core::ffi::c_void),
>;
pub type z_element_clone_f = ::core::option::Option<
    unsafe extern "C" fn(e: *const ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
pub type z_element_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const ::core::ffi::c_void,
        right: *const ::core::ffi::c_void,
    ) -> bool,
>;
pub type z_element_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const ::core::ffi::c_void,
        right: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type z_element_hash_f =
    ::core::option::Option<unsafe extern "C" fn(e: *const ::core::ffi::c_void) -> usize>;
pub type _z_noop_t = ::core::ffi::c_void;
pub type _z_noop_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_noop_t, right: *const _z_noop_t) -> bool,
>;
pub type _z_noop_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_noop_t, right: *const _z_noop_t) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_vec_t {
    pub _capacity: usize,
    pub _len: usize,
    pub _val: *mut *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_vec_t"][::core::mem::size_of::<_z_vec_t>() - 24usize];
    ["Alignment of _z_vec_t"][::core::mem::align_of::<_z_vec_t>() - 8usize];
    ["Offset of field: _z_vec_t::_capacity"][::core::mem::offset_of!(_z_vec_t, _capacity) - 0usize];
    ["Offset of field: _z_vec_t::_len"][::core::mem::offset_of!(_z_vec_t, _len) - 8usize];
    ["Offset of field: _z_vec_t::_val"][::core::mem::offset_of!(_z_vec_t, _val) - 16usize];
};
unsafe extern "C" {
    pub fn _z_vec_make(capacity: usize) -> _z_vec_t;
}
unsafe extern "C" {
    pub fn _z_vec_copy(dst: *mut _z_vec_t, src: *const _z_vec_t, f: z_element_clone_f);
}
unsafe extern "C" {
    pub fn _z_vec_move(dst: *mut _z_vec_t, src: *mut _z_vec_t);
}
unsafe extern "C" {
    pub fn _z_vec_append(v: *mut _z_vec_t, e: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn _z_vec_set(
        sv: *mut _z_vec_t,
        pos: usize,
        e: *mut ::core::ffi::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_vec_remove(sv: *mut _z_vec_t, pos: usize, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_reset(v: *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_clear(v: *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_free(v: *mut *mut _z_vec_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_vec_release(v: *mut _z_vec_t);
}
#[doc = " A dynamically allocated vector. Elements are stored by value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_svec_t {
    pub _capacity: usize,
    pub _len: usize,
    pub _val: *mut ::core::ffi::c_void,
    pub _aliased: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_svec_t"][::core::mem::size_of::<_z_svec_t>() - 32usize];
    ["Alignment of _z_svec_t"][::core::mem::align_of::<_z_svec_t>() - 8usize];
    ["Offset of field: _z_svec_t::_capacity"]
        [::core::mem::offset_of!(_z_svec_t, _capacity) - 0usize];
    ["Offset of field: _z_svec_t::_len"][::core::mem::offset_of!(_z_svec_t, _len) - 8usize];
    ["Offset of field: _z_svec_t::_val"][::core::mem::offset_of!(_z_svec_t, _val) - 16usize];
    ["Offset of field: _z_svec_t::_aliased"]
        [::core::mem::offset_of!(_z_svec_t, _aliased) - 24usize];
};
unsafe extern "C" {
    pub fn _z_svec_init(v: *mut _z_svec_t, offset: usize, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_make(capacity: usize, element_size: usize) -> _z_svec_t;
}
unsafe extern "C" {
    pub fn _z_svec_copy(
        dst: *mut _z_svec_t,
        src: *const _z_svec_t,
        copy: z_element_copy_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_move(dst: *mut _z_svec_t, src: *mut _z_svec_t);
}
unsafe extern "C" {
    pub fn _z_svec_expand(
        v: *mut _z_svec_t,
        move_: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_append(
        v: *mut _z_svec_t,
        e: *const ::core::ffi::c_void,
        m: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_svec_set(
        sv: *mut _z_svec_t,
        pos: usize,
        e: *mut ::core::ffi::c_void,
        f: z_element_clear_f,
        element_size: usize,
    );
}
unsafe extern "C" {
    pub fn _z_svec_remove(
        sv: *mut _z_svec_t,
        pos: usize,
        f: z_element_clear_f,
        m: z_element_move_f,
        element_size: usize,
        use_elem_f: bool,
    );
}
unsafe extern "C" {
    pub fn _z_svec_reset(v: *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_clear(v: *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_free(v: *mut *mut _z_svec_t, f: z_element_clear_f, element_size: usize);
}
unsafe extern "C" {
    pub fn _z_svec_release(v: *mut _z_svec_t);
}
unsafe extern "C" {
    #[doc = " Offsets a ``uint8_t`` pointer by a given distance. Offsets can be both positive and negative values.\n\n Parameters:\n   ptr: The pointer to offset.\n   off: The offset distance to be applied.\n\n Returns:\n   Returns a ``const uint8_t`` pointer, pointing to the offset position."]
    pub fn _z_cptr_u8_offset(ptr: *const u8, off: isize) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Offsets a ``char`` pointer by a given distance. Offsets can be both positive and negative values.\n\n Parameters:\n   ptr: The pointer to offset.\n   off: The offset distance to be applied.\n\n Returns:\n   Returns a ``const char`` pointer, pointing to the offset position."]
    pub fn _z_cptr_char_offset(
        ptr: *const ::core::ffi::c_char,
        off: isize,
    ) -> *const ::core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_iosli_t {
    pub _r_pos: usize,
    pub _w_pos: usize,
    pub _capacity: usize,
    pub _buf: *mut u8,
    pub _is_alloc: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_iosli_t"][::core::mem::size_of::<_z_iosli_t>() - 40usize];
    ["Alignment of _z_iosli_t"][::core::mem::align_of::<_z_iosli_t>() - 8usize];
    ["Offset of field: _z_iosli_t::_r_pos"][::core::mem::offset_of!(_z_iosli_t, _r_pos) - 0usize];
    ["Offset of field: _z_iosli_t::_w_pos"][::core::mem::offset_of!(_z_iosli_t, _w_pos) - 8usize];
    ["Offset of field: _z_iosli_t::_capacity"]
        [::core::mem::offset_of!(_z_iosli_t, _capacity) - 16usize];
    ["Offset of field: _z_iosli_t::_buf"][::core::mem::offset_of!(_z_iosli_t, _buf) - 24usize];
    ["Offset of field: _z_iosli_t::_is_alloc"]
        [::core::mem::offset_of!(_z_iosli_t, _is_alloc) - 32usize];
};
unsafe extern "C" {
    pub fn _z_iosli_make(capacity: usize) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_new(capacity: usize) -> *mut _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_wrap(buf: *const u8, length: usize, r_pos: usize, w_pos: usize) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_steal(ios: *mut _z_iosli_t) -> _z_iosli_t;
}
unsafe extern "C" {
    pub fn _z_iosli_to_bytes(ios: *const _z_iosli_t) -> _z_slice_t;
}
unsafe extern "C" {
    pub fn _z_iosli_clear(ios: *mut _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_free(ios: *mut *mut _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_copy(dst: *mut _z_iosli_t, src: *const _z_iosli_t);
}
unsafe extern "C" {
    pub fn _z_iosli_clone(src: *const _z_iosli_t) -> *mut _z_iosli_t;
}
pub type _z_iosli_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_iosli_t, right: *const _z_iosli_t) -> bool,
>;
pub type _z_iosli_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_iosli_t, right: *const _z_iosli_t) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_iosli_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_zbuf_t {
    pub _ios: _z_iosli_t,
    pub _slice: _z_slice_simple_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_zbuf_t"][::core::mem::size_of::<_z_zbuf_t>() - 48usize];
    ["Alignment of _z_zbuf_t"][::core::mem::align_of::<_z_zbuf_t>() - 8usize];
    ["Offset of field: _z_zbuf_t::_ios"][::core::mem::offset_of!(_z_zbuf_t, _ios) - 0usize];
    ["Offset of field: _z_zbuf_t::_slice"][::core::mem::offset_of!(_z_zbuf_t, _slice) - 40usize];
};
unsafe extern "C" {
    pub fn _z_zbuf_make(capacity: usize) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_zbuf_view(zbf: *mut _z_zbuf_t, length: usize) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_slice_as_zbuf(slice: _z_slice_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_zbuf_copy_bytes(dst: *mut _z_zbuf_t, src: *const _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_copy(dst: *mut _z_zbuf_t, src: *const _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_read_bytes(zbf: *mut _z_zbuf_t, dest: *mut u8, offset: usize, length: usize);
}
unsafe extern "C" {
    pub fn _z_zbuf_compact(zbf: *mut _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_clear(zbf: *mut _z_zbuf_t);
}
unsafe extern "C" {
    pub fn _z_zbuf_free(zbf: *mut *mut _z_zbuf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_wbuf_t {
    pub _ioss: _z_iosli_svec_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
    pub _expansion_step: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_wbuf_t"][::core::mem::size_of::<_z_wbuf_t>() - 56usize];
    ["Alignment of _z_wbuf_t"][::core::mem::align_of::<_z_wbuf_t>() - 8usize];
    ["Offset of field: _z_wbuf_t::_ioss"][::core::mem::offset_of!(_z_wbuf_t, _ioss) - 0usize];
    ["Offset of field: _z_wbuf_t::_r_idx"][::core::mem::offset_of!(_z_wbuf_t, _r_idx) - 32usize];
    ["Offset of field: _z_wbuf_t::_w_idx"][::core::mem::offset_of!(_z_wbuf_t, _w_idx) - 40usize];
    ["Offset of field: _z_wbuf_t::_expansion_step"]
        [::core::mem::offset_of!(_z_wbuf_t, _expansion_step) - 48usize];
};
unsafe extern "C" {
    pub fn _z_wbuf_make(capacity: usize, is_expandable: bool) -> _z_wbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_capacity(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_len(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_space_left(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_write(wbf: *mut _z_wbuf_t, b: u8) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_write_bytes(
        wbf: *mut _z_wbuf_t,
        bs: *const u8,
        offset: usize,
        length: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_wrap_bytes(
        wbf: *mut _z_wbuf_t,
        bs: *const u8,
        offset: usize,
        length: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_put(wbf: *mut _z_wbuf_t, b: u8, pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_get_rpos(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_get_wpos(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_set_rpos(wbf: *mut _z_wbuf_t, r_pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_set_wpos(wbf: *mut _z_wbuf_t, w_pos: usize);
}
unsafe extern "C" {
    pub fn _z_wbuf_len_iosli(wbf: *const _z_wbuf_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_wbuf_to_zbuf(wbf: *const _z_wbuf_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_moved_as_zbuf(wbf: *mut _z_wbuf_t) -> _z_zbuf_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_siphon(dst: *mut _z_wbuf_t, src: *mut _z_wbuf_t, length: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_wbuf_copy(dst: *mut _z_wbuf_t, src: *const _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_reset(wbf: *mut _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_clear(wbf: *mut _z_wbuf_t);
}
unsafe extern "C" {
    pub fn _z_wbuf_free(wbf: *mut *mut _z_wbuf_t);
}
pub type _z_arc_slice_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_arc_slice_t, right: *const _z_arc_slice_t) -> bool,
>;
pub type _z_arc_slice_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_arc_slice_t,
        right: *const _z_arc_slice_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_arc_slice_svec_t = _z_svec_t;
#[doc = " A container for slices.\n\n Members:\n   _z_slice_vec_t _slices: contents of the container."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_t {
    pub _slices: _z_arc_slice_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_t"][::core::mem::size_of::<_z_bytes_t>() - 32usize];
    ["Alignment of _z_bytes_t"][::core::mem::align_of::<_z_bytes_t>() - 8usize];
    ["Offset of field: _z_bytes_t::_slices"][::core::mem::offset_of!(_z_bytes_t, _slices) - 0usize];
};
unsafe extern "C" {
    pub fn _z_bytes_check(bytes: *const _z_bytes_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_append_bytes(dst: *mut _z_bytes_t, src: *mut _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_append_slice(dst: *mut _z_bytes_t, s: *mut _z_arc_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_copy(dst: *mut _z_bytes_t, src: *const _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_duplicate(src: *const _z_bytes_t) -> _z_bytes_t;
}
unsafe extern "C" {
    pub fn _z_bytes_move(dst: *mut _z_bytes_t, src: *mut _z_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_free(bs: *mut *mut _z_bytes_t);
}
unsafe extern "C" {
    pub fn _z_bytes_len(bs: *const _z_bytes_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_bytes_is_empty(bs: *const _z_bytes_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_to_slice(bytes: *const _z_bytes_t, s: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_from_slice(b: *mut _z_bytes_t, s: *mut _z_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_to_buf(bytes: *const _z_bytes_t, dst: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_bytes_from_buf(b: *mut _z_bytes_t, src: *const u8, len: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_try_get_contiguous(bs: *const _z_bytes_t) -> _z_slice_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_reader_t {
    pub slice_idx: usize,
    pub in_slice_idx: usize,
    pub byte_idx: usize,
    pub bytes: *const _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_reader_t"][::core::mem::size_of::<_z_bytes_reader_t>() - 32usize];
    ["Alignment of _z_bytes_reader_t"][::core::mem::align_of::<_z_bytes_reader_t>() - 8usize];
    ["Offset of field: _z_bytes_reader_t::slice_idx"]
        [::core::mem::offset_of!(_z_bytes_reader_t, slice_idx) - 0usize];
    ["Offset of field: _z_bytes_reader_t::in_slice_idx"]
        [::core::mem::offset_of!(_z_bytes_reader_t, in_slice_idx) - 8usize];
    ["Offset of field: _z_bytes_reader_t::byte_idx"]
        [::core::mem::offset_of!(_z_bytes_reader_t, byte_idx) - 16usize];
    ["Offset of field: _z_bytes_reader_t::bytes"]
        [::core::mem::offset_of!(_z_bytes_reader_t, bytes) - 24usize];
};
unsafe extern "C" {
    pub fn _z_bytes_get_reader(bytes: *const _z_bytes_t) -> _z_bytes_reader_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_seek(
        reader: *mut _z_bytes_reader_t,
        offset: i64,
        origin: ::core::ffi::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_tell(reader: *const _z_bytes_reader_t) -> i64;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_read_slices(
        reader: *mut _z_bytes_reader_t,
        len: usize,
        out: *mut _z_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_read(reader: *mut _z_bytes_reader_t, buf: *mut u8, len: usize) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_bytes_writer_t {
    pub cache: *mut _z_arc_slice_t,
    pub bytes: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_bytes_writer_t"][::core::mem::size_of::<_z_bytes_writer_t>() - 40usize];
    ["Alignment of _z_bytes_writer_t"][::core::mem::align_of::<_z_bytes_writer_t>() - 8usize];
    ["Offset of field: _z_bytes_writer_t::cache"]
        [::core::mem::offset_of!(_z_bytes_writer_t, cache) - 0usize];
    ["Offset of field: _z_bytes_writer_t::bytes"]
        [::core::mem::offset_of!(_z_bytes_writer_t, bytes) - 8usize];
};
unsafe extern "C" {
    pub fn _z_bytes_writer_is_empty(writer: *const _z_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_check(writer: *const _z_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_from_bytes(bytes: *mut _z_bytes_t) -> _z_bytes_writer_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_empty() -> _z_bytes_writer_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_write_all(
        writer: *mut _z_bytes_writer_t,
        src: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_append_z_bytes(
        writer: *mut _z_bytes_writer_t,
        bytes: *mut _z_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_append_slice(
        writer: *mut _z_bytes_writer_t,
        bytes: *mut _z_arc_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_finish(writer: *mut _z_bytes_writer_t) -> _z_bytes_t;
}
unsafe extern "C" {
    pub fn _z_bytes_writer_clear(writer: *mut _z_bytes_writer_t);
}
unsafe extern "C" {
    pub fn _z_bytes_writer_move(
        dst: *mut _z_bytes_writer_t,
        src: *mut _z_bytes_writer_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_bytes_reader_remaining(reader: *const _z_bytes_reader_t) -> usize;
}
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_l_t {
    pub _val: *mut ::core::ffi::c_void,
    pub _next: *mut _z_l_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_l_t"][::core::mem::size_of::<_z_l_t>() - 16usize];
    ["Alignment of _z_l_t"][::core::mem::align_of::<_z_l_t>() - 8usize];
    ["Offset of field: _z_l_t::_val"][::core::mem::offset_of!(_z_l_t, _val) - 0usize];
    ["Offset of field: _z_l_t::_next"][::core::mem::offset_of!(_z_l_t, _next) - 8usize];
};
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_list_t = _z_l_t;
unsafe extern "C" {
    pub fn _z_list_len(xs: *const _z_list_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_list_push(xs: *mut _z_list_t, x: *mut ::core::ffi::c_void) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_after(xs: *mut _z_list_t, x: *mut ::core::ffi::c_void) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_back(xs: *mut _z_list_t, x: *mut ::core::ffi::c_void) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_push_sorted(
        xs: *mut _z_list_t,
        c_f: z_element_cmp_f,
        x: *mut ::core::ffi::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_pop(
        xs: *mut _z_list_t,
        f_f: z_element_free_f,
        x: *mut *mut ::core::ffi::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_find(
        xs: *const _z_list_t,
        f_f: z_element_eq_f,
        e: *const ::core::ffi::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_drop_element(
        list: *mut _z_list_t,
        prev: *mut _z_list_t,
        f_f: z_element_free_f,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_drop_filter(
        xs: *mut _z_list_t,
        f_f: z_element_free_f,
        c_f: z_element_eq_f,
        left: *const ::core::ffi::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_clone(xs: *const _z_list_t, d_f: z_element_clone_f) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_list_free(xs: *mut *mut _z_list_t, f_f: z_element_free_f);
}
pub type _z_slist_t = ::core::ffi::c_void;
unsafe extern "C" {
    pub fn _z_slist_push_empty(node: *mut _z_slist_t, value_size: usize) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_push(
        node: *mut _z_slist_t,
        value: *const ::core::ffi::c_void,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_push_back(
        node: *mut _z_slist_t,
        value: *const ::core::ffi::c_void,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_value(node: *const _z_slist_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_slist_next(node: *const _z_slist_t) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_len(node: *const _z_slist_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_slist_pop(node: *mut _z_slist_t, f_f: z_element_clear_f) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_find(
        node: *const _z_slist_t,
        c_f: z_element_eq_f,
        target_val: *const ::core::ffi::c_void,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_drop_element(
        list: *mut _z_slist_t,
        prev: *mut _z_slist_t,
        f_f: z_element_clear_f,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_drop_filter(
        head: *mut _z_slist_t,
        f_f: z_element_clear_f,
        c_f: z_element_eq_f,
        target_val: *const ::core::ffi::c_void,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_clone(
        node: *const _z_slist_t,
        value_size: usize,
        d_f: z_element_copy_f,
        use_elem_f: bool,
    ) -> *mut _z_slist_t;
}
unsafe extern "C" {
    pub fn _z_slist_free(node: *mut *mut _z_slist_t, f: z_element_clear_f);
}
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_entry_t {
    pub _key: *mut ::core::ffi::c_void,
    pub _val: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_entry_t"][::core::mem::size_of::<_z_hashmap_entry_t>() - 16usize];
    ["Alignment of _z_hashmap_entry_t"][::core::mem::align_of::<_z_hashmap_entry_t>() - 8usize];
    ["Offset of field: _z_hashmap_entry_t::_key"]
        [::core::mem::offset_of!(_z_hashmap_entry_t, _key) - 0usize];
    ["Offset of field: _z_hashmap_entry_t::_val"]
        [::core::mem::offset_of!(_z_hashmap_entry_t, _val) - 8usize];
};
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_t {
    pub _capacity: usize,
    pub _vals: *mut *mut _z_list_t,
    pub _f_hash: z_element_hash_f,
    pub _f_equals: z_element_eq_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_t"][::core::mem::size_of::<_z_hashmap_t>() - 32usize];
    ["Alignment of _z_hashmap_t"][::core::mem::align_of::<_z_hashmap_t>() - 8usize];
    ["Offset of field: _z_hashmap_t::_capacity"]
        [::core::mem::offset_of!(_z_hashmap_t, _capacity) - 0usize];
    ["Offset of field: _z_hashmap_t::_vals"][::core::mem::offset_of!(_z_hashmap_t, _vals) - 8usize];
    ["Offset of field: _z_hashmap_t::_f_hash"]
        [::core::mem::offset_of!(_z_hashmap_t, _f_hash) - 16usize];
    ["Offset of field: _z_hashmap_t::_f_equals"]
        [::core::mem::offset_of!(_z_hashmap_t, _f_equals) - 24usize];
};
#[doc = " Iterator for a generic key-value hashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hashmap_iterator_t {
    pub _entry: *mut _z_hashmap_entry_t,
    pub _map: *const _z_hashmap_t,
    pub _idx: usize,
    pub _list_ptr: *mut _z_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hashmap_iterator_t"][::core::mem::size_of::<_z_hashmap_iterator_t>() - 32usize];
    ["Alignment of _z_hashmap_iterator_t"]
        [::core::mem::align_of::<_z_hashmap_iterator_t>() - 8usize];
    ["Offset of field: _z_hashmap_iterator_t::_entry"]
        [::core::mem::offset_of!(_z_hashmap_iterator_t, _entry) - 0usize];
    ["Offset of field: _z_hashmap_iterator_t::_map"]
        [::core::mem::offset_of!(_z_hashmap_iterator_t, _map) - 8usize];
    ["Offset of field: _z_hashmap_iterator_t::_idx"]
        [::core::mem::offset_of!(_z_hashmap_iterator_t, _idx) - 16usize];
    ["Offset of field: _z_hashmap_iterator_t::_list_ptr"]
        [::core::mem::offset_of!(_z_hashmap_iterator_t, _list_ptr) - 24usize];
};
unsafe extern "C" {
    pub fn _z_hashmap_init(
        map: *mut _z_hashmap_t,
        capacity: usize,
        f_hash: z_element_hash_f,
        f_equals: z_element_eq_f,
    );
}
unsafe extern "C" {
    pub fn _z_hashmap_make(
        capacity: usize,
        f_hash: z_element_hash_f,
        f_equals: z_element_eq_f,
    ) -> _z_hashmap_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_insert(
        map: *mut _z_hashmap_t,
        key: *mut ::core::ffi::c_void,
        val: *mut ::core::ffi::c_void,
        f: z_element_free_f,
        replace: bool,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_get(
        map: *const _z_hashmap_t,
        key: *const ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_get_all(
        map: *const _z_hashmap_t,
        key: *const ::core::ffi::c_void,
    ) -> *mut _z_list_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_remove(
        map: *mut _z_hashmap_t,
        key: *const ::core::ffi::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_hashmap_capacity(map: *const _z_hashmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_hashmap_len(map: *const _z_hashmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_hashmap_is_empty(map: *const _z_hashmap_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_hashmap_copy(
        dst: *mut _z_hashmap_t,
        src: *const _z_hashmap_t,
        f_c: z_element_clone_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_clone(
        src: *const _z_hashmap_t,
        f_c: z_element_clone_f,
        f_f: z_element_free_f,
    ) -> _z_hashmap_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_clear(map: *mut _z_hashmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_hashmap_free(map: *mut *mut _z_hashmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_make(map: *const _z_hashmap_t) -> _z_hashmap_iterator_t;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_next(iter: *mut _z_hashmap_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_key(iter: *const _z_hashmap_iterator_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_hashmap_iterator_value(
        iter: *const _z_hashmap_iterator_t,
    ) -> *mut ::core::ffi::c_void;
}
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_int_void_map_t = _z_hashmap_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_int_void_map_entry_t = _z_hashmap_entry_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_int_void_map_iterator_t = _z_hashmap_iterator_t;
pub type _z_str_t = *mut ::core::ffi::c_char;
unsafe extern "C" {
    pub fn _z_str_clone(src: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_str_n_clone(src: *const ::core::ffi::c_char, len: usize) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_str_clear(src: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn _z_str_free(src: *mut *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn _z_str_eq(left: *const ::core::ffi::c_char, right: *const ::core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    pub fn _z_str_cmp(
        left: *const ::core::ffi::c_char,
        right: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_str_size(src: *const ::core::ffi::c_char) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_copy(dst: *mut ::core::ffi::c_char, src: *const ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn _z_str_n_copy(
        dst: *mut ::core::ffi::c_char,
        src: *const ::core::ffi::c_char,
        size: usize,
    );
}
pub type _z_str_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const ::core::ffi::c_char,
        right: *const ::core::ffi::c_char,
    ) -> bool,
>;
pub type _z_str_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const ::core::ffi::c_char,
        right: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
pub type _z_str_vec_t = _z_vec_t;
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_str_list_t = _z_list_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_str_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_str_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_str_intmap_iterator_t = _z_int_void_map_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_str_intmapping_t {
    pub _str: *mut ::core::ffi::c_char,
    pub _key: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_str_intmapping_t"][::core::mem::size_of::<_z_str_intmapping_t>() - 16usize];
    ["Alignment of _z_str_intmapping_t"][::core::mem::align_of::<_z_str_intmapping_t>() - 8usize];
    ["Offset of field: _z_str_intmapping_t::_str"]
        [::core::mem::offset_of!(_z_str_intmapping_t, _str) - 0usize];
    ["Offset of field: _z_str_intmapping_t::_key"]
        [::core::mem::offset_of!(_z_str_intmapping_t, _key) - 8usize];
};
unsafe extern "C" {
    pub fn _z_str_intmap_strlen(
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_intmap_onto_str(
        dst: *mut ::core::ffi::c_char,
        dst_len: usize,
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    );
}
unsafe extern "C" {
    pub fn _z_str_intmap_to_str(
        s: *const _z_str_intmap_t,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_str_intmap_from_str(
        strint: *mut _z_str_intmap_t,
        s: *const ::core::ffi::c_char,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_str_intmap_from_strn(
        strint: *mut _z_str_intmap_t,
        s: *const ::core::ffi::c_char,
        argc: u8,
        argv: *mut _z_str_intmapping_t,
        n: usize,
    ) -> z_result_t;
}
#[doc = " A string with no terminator.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_string_t {
    pub _slice: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_string_t"][::core::mem::size_of::<_z_string_t>() - 32usize];
    ["Alignment of _z_string_t"][::core::mem::align_of::<_z_string_t>() - 8usize];
    ["Offset of field: _z_string_t::_slice"][::core::mem::offset_of!(_z_string_t, _slice) - 0usize];
};
unsafe extern "C" {
    pub fn _z_string_copy_from_str(value: *const ::core::ffi::c_char) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_from_substr(value: *const ::core::ffi::c_char, len: usize)
    -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_from_str_as_ptr(value: *const ::core::ffi::c_char) -> *mut _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_rchr(
        str_: *mut _z_string_t,
        filter: ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_string_pbrk(
        str_: *mut _z_string_t,
        filter: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_string_copy(dst: *mut _z_string_t, src: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_copy_substring(
        dst: *mut _z_string_t,
        src: *const _z_string_t,
        offset: usize,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_move(dst: *mut _z_string_t, src: *mut _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_string_steal(str_: *mut _z_string_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_move_str(dst: *mut _z_string_t, src: *mut ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn _z_string_free(s: *mut *mut _z_string_t);
}
unsafe extern "C" {
    pub fn _z_string_compare(
        left: *const _z_string_t,
        right: *const _z_string_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_string_equals(left: *const _z_string_t, right: *const _z_string_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_string_convert_bytes_le(bs: *const _z_slice_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_string_preallocate(len: usize) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_str_from_string_clone(str_: *const _z_string_t) -> *mut ::core::ffi::c_char;
}
pub type _z_string_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_string_t, right: *const _z_string_t) -> bool,
>;
pub type _z_string_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_string_t, right: *const _z_string_t) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_string_svec_t = _z_svec_t;
#[doc = " A single-linked list. Elements are stored as pointers.\n\n  Members:\n   void *lal: The pointer to the inner value.\n   struct z_list *tail: A pointer to the next element in the list."]
pub type _z_string_list_t = _z_list_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_string_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_string_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_string_intmap_iterator_t = _z_int_void_map_iterator_t;
pub const z_what_t_Z_WHAT_ROUTER: z_what_t = 1;
pub const z_what_t_Z_WHAT_PEER: z_what_t = 2;
pub const z_what_t_Z_WHAT_CLIENT: z_what_t = 4;
pub const z_what_t_Z_WHAT_ROUTER_PEER: z_what_t = 3;
pub const z_what_t_Z_WHAT_ROUTER_CLIENT: z_what_t = 5;
pub const z_what_t_Z_WHAT_PEER_CLIENT: z_what_t = 6;
pub const z_what_t_Z_WHAT_ROUTER_PEER_CLIENT: z_what_t = 7;
#[doc = " What bitmask for scouting.\n\n Enumerators:\n   Z_WHAT_ROUTER: Router.\n   Z_WHAT_PEER: Peer.\n   Z_WHAT_CLIENT: Client."]
pub type z_what_t = ::core::ffi::c_uint;
pub const z_whatami_t_Z_WHATAMI_ROUTER: z_whatami_t = 1;
pub const z_whatami_t_Z_WHATAMI_PEER: z_whatami_t = 2;
pub const z_whatami_t_Z_WHATAMI_CLIENT: z_whatami_t = 4;
#[doc = " Whatami values, defined as a bitmask.\n\n Enumerators:\n   Z_WHATAMI_ROUTER: Bitmask to filter Zenoh routers.\n   Z_WHATAMI_PEER: Bitmask to filter for Zenoh peers.\n   Z_WHATAMI_CLIENT: Bitmask to filter for Zenoh clients."]
pub type z_whatami_t = ::core::ffi::c_uint;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_SUCCESS: zp_keyexpr_canon_status_t = 0;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_LONE_DOLLAR_STAR: zp_keyexpr_canon_status_t =
    -1;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_SINGLE_STAR_AFTER_DOUBLE_STAR:
    zp_keyexpr_canon_status_t = -2;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_DOUBLE_STAR_AFTER_DOUBLE_STAR:
    zp_keyexpr_canon_status_t = -3;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_EMPTY_CHUNK: zp_keyexpr_canon_status_t = -4;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_STARS_IN_CHUNK: zp_keyexpr_canon_status_t = -5;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_DOLLAR_AFTER_DOLLAR_OR_STAR:
    zp_keyexpr_canon_status_t = -6;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_CONTAINS_SHARP_OR_QMARK:
    zp_keyexpr_canon_status_t = -7;
pub const zp_keyexpr_canon_status_t_Z_KEYEXPR_CANON_CONTAINS_UNBOUND_DOLLAR:
    zp_keyexpr_canon_status_t = -8;
#[doc = " Status values for keyexpr canonization operation.\n Used as return value of canonization-related functions,\n like :c:func:`z_keyexpr_is_canon` or :c:func:`z_keyexpr_canonize`.\n\n Enumerators:\n   Z_KEYEXPR_CANON_SUCCESS: The key expression is canon.\n   Z_KEYEXPR_CANON_LONE_DOLLAR_STAR: The key contains a ``$*`` chunk, which must be replaced by ``*``.\n   Z_KEYEXPR_CANON_SINGLE_STAR_AFTER_DOUBLE_STAR: The key contains ``** / *``, which must be replaced by ``* / **``.\n   Z_KEYEXPR_CANON_DOUBLE_STAR_AFTER_DOUBLE_STAR: The key contains ``** / **``, which must be replaced by ``**``.\n   Z_KEYEXPR_CANON_EMPTY_CHUNK: The key contains empty chunks.\n   Z_KEYEXPR_CANON_STARS_IN_CHUNK: The key contains a ``*`` in a chunk without being escaped by a DSL, which is\n     forbidden.\n   Z_KEYEXPR_CANON_DOLLAR_AFTER_DOLLAR_OR_STAR: The key contains ``$*$`` or ``$$``, which is forbidden.\n   Z_KEYEXPR_CANON_CONTAINS_SHARP_OR_QMARK: The key contains ``#`` or ``?``, which is forbidden.\n   Z_KEYEXPR_CANON_CONTAINS_UNBOUND_DOLLAR: The key contains a ``$`` which is not bound to a DSL."]
pub type zp_keyexpr_canon_status_t = ::core::ffi::c_int;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT:
    z_keyexpr_intersection_level_t = 0;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS:
    z_keyexpr_intersection_level_t = 1;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES:
    z_keyexpr_intersection_level_t = 2;
pub const z_keyexpr_intersection_level_t_Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS:
    z_keyexpr_intersection_level_t = 3;
#[doc = " Intersection level of two key expressions.\n\n Enumerators:\n   Z_KEYEXPR_INTERSECTION_LEVEL_DISJOINT: The two key expressions do not intersect.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INTERSECTS: The two key expressions intersect, i.e. there exists at least one key\n     expression that is included by both.\n   Z_KEYEXPR_INTERSECTION_LEVEL_INCLUDES: The first key expression is the superset of the second one.\n   Z_KEYEXPR_INTERSECTION_LEVEL_EQUALS: The two key expressions are equal."]
pub type z_keyexpr_intersection_level_t = ::core::ffi::c_uint;
pub const z_sample_kind_t_Z_SAMPLE_KIND_PUT: z_sample_kind_t = 0;
pub const z_sample_kind_t_Z_SAMPLE_KIND_DELETE: z_sample_kind_t = 1;
#[doc = " Sample kind values.\n\n Enumerators:\n   Z_SAMPLE_KIND_PUT: The Sample was issued by a ``put`` operation.\n   Z_SAMPLE_KIND_DELETE: The Sample was issued by a ``delete`` operation."]
pub type z_sample_kind_t = ::core::ffi::c_uint;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_AUTO: z_consolidation_mode_t = -1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_NONE: z_consolidation_mode_t = 0;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_MONOTONIC: z_consolidation_mode_t = 1;
pub const z_consolidation_mode_t_Z_CONSOLIDATION_MODE_LATEST: z_consolidation_mode_t = 2;
#[doc = " Consolidation mode values.\n\n Enumerators:\n   Z_CONSOLIDATION_MODE_AUTO: Let Zenoh decide the best consolidation mode depending on the query selector.\n   Z_CONSOLIDATION_MODE_NONE: No consolidation is applied. Replies may come in any order and any number.\n   Z_CONSOLIDATION_MODE_MONOTONIC: It guarantees that any reply for a given key expression will be monotonic in time\n     w.r.t. the previous received replies for the same key expression. I.e., for the same key expression multiple\n     replies may be received. It is guaranteed that two replies received at t1 and t2 will have timestamp\n     ts2 > ts1. It optimizes latency.\n   Z_CONSOLIDATION_MODE_LATEST: It guarantees unicity of replies for the same key expression.\n     It optimizes bandwidth."]
pub type z_consolidation_mode_t = ::core::ffi::c_int;
pub const z_reliability_t_Z_RELIABILITY_BEST_EFFORT: z_reliability_t = 1;
pub const z_reliability_t_Z_RELIABILITY_RELIABLE: z_reliability_t = 0;
#[doc = " Reliability values.\n\n Enumerators:\n   Z_RELIABILITY_BEST_EFFORT: Defines reliability as ``BEST_EFFORT``\n   Z_RELIABILITY_RELIABLE: Defines reliability as ``RELIABLE``\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
pub type z_reliability_t = ::core::ffi::c_uint;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_BLOCK: z_congestion_control_t = 1;
pub const z_congestion_control_t_Z_CONGESTION_CONTROL_DROP: z_congestion_control_t = 0;
#[doc = " Congestion control values.\n\n Enumerators:\n   Z_CONGESTION_CONTROL_BLOCK: Defines congestion control as ``BLOCK``. Messages are not dropped in case of\n     congestion control.\n   Z_CONGESTION_CONTROL_DROP: Defines congestion control as ``DROP``. Messages are dropped in case\n     of congestion control."]
pub type z_congestion_control_t = ::core::ffi::c_uint;
pub const z_priority_t__Z_PRIORITY_CONTROL: z_priority_t = 0;
pub const z_priority_t_Z_PRIORITY_REAL_TIME: z_priority_t = 1;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_HIGH: z_priority_t = 2;
pub const z_priority_t_Z_PRIORITY_INTERACTIVE_LOW: z_priority_t = 3;
pub const z_priority_t_Z_PRIORITY_DATA_HIGH: z_priority_t = 4;
pub const z_priority_t_Z_PRIORITY_DATA: z_priority_t = 5;
pub const z_priority_t_Z_PRIORITY_DATA_LOW: z_priority_t = 6;
pub const z_priority_t_Z_PRIORITY_BACKGROUND: z_priority_t = 7;
#[doc = " Priority of Zenoh messages values.\n\n Enumerators:\n   _Z_PRIORITY_CONTROL: Priority for ``Control`` messages.\n   Z_PRIORITY_REAL_TIME: Priority for ``RealTime`` messages.\n   Z_PRIORITY_INTERACTIVE_HIGH: Highest priority for ``Interactive`` messages.\n   Z_PRIORITY_INTERACTIVE_LOW: Lowest priority for ``Interactive`` messages.\n   Z_PRIORITY_DATA_HIGH: Highest priority for ``Data`` messages.\n   Z_PRIORITY_DATA: Default priority for ``Data`` messages.\n   Z_PRIORITY_DATA_LOW: Lowest priority for ``Data`` messages.\n   Z_PRIORITY_BACKGROUND: Priority for ``Background traffic`` messages."]
pub type z_priority_t = ::core::ffi::c_uint;
pub const z_query_target_t_Z_QUERY_TARGET_BEST_MATCHING: z_query_target_t = 0;
pub const z_query_target_t_Z_QUERY_TARGET_ALL: z_query_target_t = 1;
pub const z_query_target_t_Z_QUERY_TARGET_ALL_COMPLETE: z_query_target_t = 2;
#[doc = " Query target values.\n\n Enumerators:\n   Z_QUERY_TARGET_BEST_MATCHING: The nearest complete queryable if any else all matching queryables.\n   Z_QUERY_TARGET_ALL: All matching queryables.\n   Z_QUERY_TARGET_ALL_COMPLETE: A set of complete queryables."]
pub type z_query_target_t = ::core::ffi::c_uint;
#[doc = " A zenoh encoding."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_encoding_t {
    pub schema: _z_string_t,
    pub id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_encoding_t"][::core::mem::size_of::<_z_encoding_t>() - 40usize];
    ["Alignment of _z_encoding_t"][::core::mem::align_of::<_z_encoding_t>() - 8usize];
    ["Offset of field: _z_encoding_t::schema"]
        [::core::mem::offset_of!(_z_encoding_t, schema) - 0usize];
    ["Offset of field: _z_encoding_t::id"][::core::mem::offset_of!(_z_encoding_t, id) - 32usize];
};
unsafe extern "C" {
    pub fn _z_encoding_wrap(id: u16, schema: *const ::core::ffi::c_char) -> _z_encoding_t;
}
unsafe extern "C" {
    pub fn _z_encoding_make(
        encoding: *mut _z_encoding_t,
        id: u16,
        schema: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_encoding_copy(dst: *mut _z_encoding_t, src: *const _z_encoding_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_encoding_move(dst: *mut _z_encoding_t, src: *mut _z_encoding_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_str_se_t {
    pub start: *const ::core::ffi::c_char,
    pub end: *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_str_se_t"][::core::mem::size_of::<_z_str_se_t>() - 16usize];
    ["Alignment of _z_str_se_t"][::core::mem::align_of::<_z_str_se_t>() - 8usize];
    ["Offset of field: _z_str_se_t::start"][::core::mem::offset_of!(_z_str_se_t, start) - 0usize];
    ["Offset of field: _z_str_se_t::end"][::core::mem::offset_of!(_z_str_se_t, end) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_splitstr_t {
    pub s: _z_str_se_t,
    pub delimiter: *const ::core::ffi::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_splitstr_t"][::core::mem::size_of::<_z_splitstr_t>() - 24usize];
    ["Alignment of _z_splitstr_t"][::core::mem::align_of::<_z_splitstr_t>() - 8usize];
    ["Offset of field: _z_splitstr_t::s"][::core::mem::offset_of!(_z_splitstr_t, s) - 0usize];
    ["Offset of field: _z_splitstr_t::delimiter"]
        [::core::mem::offset_of!(_z_splitstr_t, delimiter) - 16usize];
};
unsafe extern "C" {
    #[doc = " Creates a `_z_str_se_t` from a null-terminated C string."]
    pub fn _z_bstrnew(start: *const ::core::ffi::c_char) -> _z_str_se_t;
}
unsafe extern "C" {
    #[doc = " The reverse equivalent of libc's `strstr`.\n\n Returns NULL if the needle is not found.\n If found, the return pointer will point to the end of the last occurring\n needle within the haystack."]
    pub fn _z_rstrstr(
        haystack_start: *const ::core::ffi::c_char,
        haystack_end: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " A non-null-terminated haystack equivalent of libc's `strstr`.\n\n Returns NULL if the needle is not found.\n If found, the return pointer will point to the start of the first occurrence\n of the needle within the haystack."]
    pub fn _z_strstr(
        haystack_start: *const ::core::ffi::c_char,
        haystack_end: *const ::core::ffi::c_char,
        needle_start: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_strstr_skipneedle(
        haystack_start: *const ::core::ffi::c_char,
        haystack_end: *const ::core::ffi::c_char,
        needle_start: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_bstrstr_skipneedle(
        haystack: _z_str_se_t,
        needle: _z_str_se_t,
    ) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_splitstr_is_empty(src: *const _z_splitstr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_splitstr_next(str_: *mut _z_splitstr_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_splitstr_split_once(src: _z_splitstr_t, next: *mut _z_str_se_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_splitstr_nextback(str_: *mut _z_splitstr_t) -> _z_str_se_t;
}
unsafe extern "C" {
    pub fn _z_strcnt(
        haystack_start: *const ::core::ffi::c_char,
        harstack_end: *const ::core::ffi::c_char,
        needle_start: *const ::core::ffi::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_startswith(
        s: *const ::core::ffi::c_char,
        needle: *const ::core::ffi::c_char,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_str_se_atoui(str_: *const _z_str_se_t, result: *mut u32) -> bool;
}
#[doc = " A variable-length encoding unsigned integer."]
pub type _z_zint_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_id_t {
    pub id: [u8; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_id_t"][::core::mem::size_of::<_z_id_t>() - 16usize];
    ["Alignment of _z_id_t"][::core::mem::align_of::<_z_id_t>() - 1usize];
    ["Offset of field: _z_id_t::id"][::core::mem::offset_of!(_z_id_t, id) - 0usize];
};
unsafe extern "C" {
    pub static empty_id: _z_id_t;
}
unsafe extern "C" {
    pub fn _z_id_len(id: _z_id_t) -> u8;
}
unsafe extern "C" {
    pub fn _z_id_cmp(left: *const _z_id_t, right: *const _z_id_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_id_hash(id: *const _z_id_t) -> usize;
}
pub type _z_id_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_id_t, right: *const _z_id_t) -> bool,
>;
pub type _z_id_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_id_t, right: *const _z_id_t) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_entity_global_id_t {
    pub zid: _z_id_t,
    pub eid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_entity_global_id_t"][::core::mem::size_of::<_z_entity_global_id_t>() - 20usize];
    ["Alignment of _z_entity_global_id_t"]
        [::core::mem::align_of::<_z_entity_global_id_t>() - 4usize];
    ["Offset of field: _z_entity_global_id_t::zid"]
        [::core::mem::offset_of!(_z_entity_global_id_t, zid) - 0usize];
    ["Offset of field: _z_entity_global_id_t::eid"]
        [::core::mem::offset_of!(_z_entity_global_id_t, eid) - 16usize];
};
unsafe extern "C" {
    pub fn _z_entity_global_id_hash(id: *const _z_entity_global_id_t) -> usize;
}
pub type _z_entity_global_id_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_entity_global_id_t,
        right: *const _z_entity_global_id_t,
    ) -> bool,
>;
pub type _z_entity_global_id_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_entity_global_id_t,
        right: *const _z_entity_global_id_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " NTP64 time."]
pub type _z_ntp64_t = u64;
#[doc = " A zenoh timestamp."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_timestamp_t {
    pub valid: bool,
    pub id: _z_id_t,
    pub time: _z_ntp64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_timestamp_t"][::core::mem::size_of::<_z_timestamp_t>() - 32usize];
    ["Alignment of _z_timestamp_t"][::core::mem::align_of::<_z_timestamp_t>() - 8usize];
    ["Offset of field: _z_timestamp_t::valid"]
        [::core::mem::offset_of!(_z_timestamp_t, valid) - 0usize];
    ["Offset of field: _z_timestamp_t::id"][::core::mem::offset_of!(_z_timestamp_t, id) - 1usize];
    ["Offset of field: _z_timestamp_t::time"]
        [::core::mem::offset_of!(_z_timestamp_t, time) - 24usize];
};
unsafe extern "C" {
    pub fn _z_timestamp_copy(dst: *mut _z_timestamp_t, src: *const _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_duplicate(tstamp: *const _z_timestamp_t) -> _z_timestamp_t;
}
unsafe extern "C" {
    pub fn _z_timestamp_clear(tstamp: *mut _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_move(dst: *mut _z_timestamp_t, src: *mut _z_timestamp_t);
}
unsafe extern "C" {
    pub fn _z_timestamp_cmp(
        left: *const _z_timestamp_t,
        right: *const _z_timestamp_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_timestamp_ntp64_from_time(seconds: u32, nanos: u32) -> _z_ntp64_t;
}
pub type _z_timestamp_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_timestamp_t, right: *const _z_timestamp_t) -> bool,
>;
pub type _z_timestamp_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_timestamp_t,
        right: *const _z_timestamp_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_keyexpr_t {
    pub _id: u16,
    pub _mapping: usize,
    pub _suffix: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_keyexpr_t"][::core::mem::size_of::<_z_keyexpr_t>() - 48usize];
    ["Alignment of _z_keyexpr_t"][::core::mem::align_of::<_z_keyexpr_t>() - 8usize];
    ["Offset of field: _z_keyexpr_t::_id"][::core::mem::offset_of!(_z_keyexpr_t, _id) - 0usize];
    ["Offset of field: _z_keyexpr_t::_mapping"]
        [::core::mem::offset_of!(_z_keyexpr_t, _mapping) - 8usize];
    ["Offset of field: _z_keyexpr_t::_suffix"]
        [::core::mem::offset_of!(_z_keyexpr_t, _suffix) - 16usize];
};
unsafe extern "C" {
    #[doc = " Create a resource key from a resource name.\n\n Parameters:\n     rname: The resource name. The caller keeps its ownership.\n\n Returns:\n     A :c:type:`_z_keyexpr_t` containing a new resource key."]
    pub fn _z_rname(rname: *const ::core::ffi::c_char) -> _z_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Create a resource key from a resource id and a suffix.\n\n Parameters:\n     id: The resource id.\n     suffix: The suffix.\n\n Returns:\n     A :c:type:`_z_keyexpr_t` containing a new resource key."]
    pub fn _z_rid_with_suffix(rid: u16, suffix: *const ::core::ffi::c_char) -> _z_keyexpr_t;
}
unsafe extern "C" {
    pub fn _z_rid_with_substr_suffix(
        rid: u16,
        suffix: *const ::core::ffi::c_char,
        suffix_len: usize,
    ) -> _z_keyexpr_t;
}
#[doc = " QoS settings of zenoh message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_qos_t {
    pub _val: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_qos_t"][::core::mem::size_of::<_z_qos_t>() - 1usize];
    ["Alignment of _z_qos_t"][::core::mem::align_of::<_z_qos_t>() - 1usize];
    ["Offset of field: _z_qos_t::_val"][::core::mem::offset_of!(_z_qos_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh value.\n\n Members:\n   _z_bytes_t payload: The payload of this zenoh value.\n   _z_encoding_t encoding: The encoding of the `payload`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_value_t {
    pub payload: _z_bytes_t,
    pub encoding: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_value_t"][::core::mem::size_of::<_z_value_t>() - 72usize];
    ["Alignment of _z_value_t"][::core::mem::align_of::<_z_value_t>() - 8usize];
    ["Offset of field: _z_value_t::payload"][::core::mem::offset_of!(_z_value_t, payload) - 0usize];
    ["Offset of field: _z_value_t::encoding"]
        [::core::mem::offset_of!(_z_value_t, encoding) - 32usize];
};
unsafe extern "C" {
    pub fn _z_value_steal(value: *mut _z_value_t) -> _z_value_t;
}
unsafe extern "C" {
    pub fn _z_value_copy(dst: *mut _z_value_t, src: *const _z_value_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_value_move(dst: *mut _z_value_t, src: *mut _z_value_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_value_clear(src: *mut _z_value_t);
}
unsafe extern "C" {
    pub fn _z_value_free(hello: *mut *mut _z_value_t);
}
#[doc = " A hello message returned by a zenoh entity to a scout message sent with :c:func:`_z_scout`.\n\n Members:\n   _z_slice_t zid: The Zenoh ID of the scouted entity (empty if absent).\n   _z_string_vec_t locators: The locators of the scouted entity.\n   z_whatami_t whatami: The kind of zenoh entity."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_hello_t {
    pub _zid: _z_id_t,
    pub _locators: _z_string_svec_t,
    pub _whatami: z_whatami_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_hello_t"][::core::mem::size_of::<_z_hello_t>() - 56usize];
    ["Alignment of _z_hello_t"][::core::mem::align_of::<_z_hello_t>() - 8usize];
    ["Offset of field: _z_hello_t::_zid"][::core::mem::offset_of!(_z_hello_t, _zid) - 0usize];
    ["Offset of field: _z_hello_t::_locators"]
        [::core::mem::offset_of!(_z_hello_t, _locators) - 16usize];
    ["Offset of field: _z_hello_t::_whatami"]
        [::core::mem::offset_of!(_z_hello_t, _whatami) - 48usize];
    ["Offset of field: _z_hello_t::_version"]
        [::core::mem::offset_of!(_z_hello_t, _version) - 52usize];
};
unsafe extern "C" {
    pub fn _z_hello_clear(src: *mut _z_hello_t);
}
unsafe extern "C" {
    pub fn _z_hello_free(hello: *mut *mut _z_hello_t);
}
unsafe extern "C" {
    pub fn _z_hello_copy(dst: *mut _z_hello_t, src: *const _z_hello_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hello_move(dst: *mut _z_hello_t, src: *mut _z_hello_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_hello_check(hello: *const _z_hello_t) -> bool;
}
pub type _z_hello_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_hello_t, right: *const _z_hello_t) -> bool,
>;
pub type _z_hello_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_hello_t, right: *const _z_hello_t) -> ::core::ffi::c_int,
>;
pub type _z_hello_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_target_complete_body_t {
    pub n: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_target_complete_body_t"]
        [::core::mem::size_of::<_z_target_complete_body_t>() - 8usize];
    ["Alignment of _z_target_complete_body_t"]
        [::core::mem::align_of::<_z_target_complete_body_t>() - 8usize];
    ["Offset of field: _z_target_complete_body_t::n"]
        [::core::mem::offset_of!(_z_target_complete_body_t, n) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_source_info_t {
    pub _source_id: _z_entity_global_id_t,
    pub _source_sn: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_source_info_t"][::core::mem::size_of::<_z_source_info_t>() - 24usize];
    ["Alignment of _z_source_info_t"][::core::mem::align_of::<_z_source_info_t>() - 4usize];
    ["Offset of field: _z_source_info_t::_source_id"]
        [::core::mem::offset_of!(_z_source_info_t, _source_id) - 0usize];
    ["Offset of field: _z_source_info_t::_source_sn"]
        [::core::mem::offset_of!(_z_source_info_t, _source_sn) - 20usize];
};
unsafe extern "C" {
    pub fn _z_source_info_copy(
        dst: *mut _z_source_info_t,
        src: *const _z_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_source_info_move(
        dst: *mut _z_source_info_t,
        src: *mut _z_source_info_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_reply_context_t {
    pub _request_id: u32,
    pub _entity_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_context_t"][::core::mem::size_of::<_z_reply_context_t>() - 8usize];
    ["Alignment of _z_reply_context_t"][::core::mem::align_of::<_z_reply_context_t>() - 4usize];
    ["Offset of field: _z_reply_context_t::_request_id"]
        [::core::mem::offset_of!(_z_reply_context_t, _request_id) - 0usize];
    ["Offset of field: _z_reply_context_t::_entity_id"]
        [::core::mem::offset_of!(_z_reply_context_t, _entity_id) - 4usize];
};
unsafe extern "C" {
    pub fn _z_keyexpr_is_canon(
        start: *const ::core::ffi::c_char,
        len: usize,
    ) -> zp_keyexpr_canon_status_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_canonize(
        start: *mut ::core::ffi::c_char,
        len: *mut usize,
    ) -> zp_keyexpr_canon_status_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_includes(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_intersects(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_suffix_equals(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_compare(
        first: *mut _z_keyexpr_t,
        second: *mut _z_keyexpr_t,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_keyexpr_from_string(dst: *mut _z_keyexpr_t, rid: u16, str_: *const _z_string_t);
}
unsafe extern "C" {
    pub fn _z_keyexpr_from_substr(
        dst: *mut _z_keyexpr_t,
        rid: u16,
        str_: *const ::core::ffi::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    pub fn _z_keyexpr_size(p: *mut _z_keyexpr_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_keyexpr_copy(dst: *mut _z_keyexpr_t, src: *const _z_keyexpr_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_duplicate(src: *const _z_keyexpr_t) -> _z_keyexpr_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_clone(src: *const _z_keyexpr_t) -> *mut _z_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Returns either keyexpr defined by id + mapping with null suffix if id is non-zero,\n or keyexpr defined by its suffix only, with 0 id and no mapping. This is to be used only when forwarding\n keyexpr in user api to properly separate declared keyexpr from its suffix."]
    pub fn _z_keyexpr_alias_from_user_defined(dst: *mut _z_keyexpr_t, src: *const _z_keyexpr_t);
}
unsafe extern "C" {
    pub fn _z_keyexpr_remove_wilds(
        base_key: *mut _z_keyexpr_t,
        wild_loc: *mut *mut ::core::ffi::c_char,
        wild_suffix_size: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_equals(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_keyexpr_move(dst: *mut _z_keyexpr_t, src: *mut _z_keyexpr_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_keyexpr_free(rk: *mut *mut _z_keyexpr_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_kexpr_t {
    pub _id: u16,
    pub _keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_kexpr_t"][::core::mem::size_of::<_z_decl_kexpr_t>() - 56usize];
    ["Alignment of _z_decl_kexpr_t"][::core::mem::align_of::<_z_decl_kexpr_t>() - 8usize];
    ["Offset of field: _z_decl_kexpr_t::_id"]
        [::core::mem::offset_of!(_z_decl_kexpr_t, _id) - 0usize];
    ["Offset of field: _z_decl_kexpr_t::_keyexpr"]
        [::core::mem::offset_of!(_z_decl_kexpr_t, _keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_kexpr_t {
    pub _id: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_kexpr_t"][::core::mem::size_of::<_z_undecl_kexpr_t>() - 2usize];
    ["Alignment of _z_undecl_kexpr_t"][::core::mem::align_of::<_z_undecl_kexpr_t>() - 2usize];
    ["Offset of field: _z_undecl_kexpr_t::_id"]
        [::core::mem::offset_of!(_z_undecl_kexpr_t, _id) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_subscriber_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_subscriber_t"][::core::mem::size_of::<_z_decl_subscriber_t>() - 56usize];
    ["Alignment of _z_decl_subscriber_t"][::core::mem::align_of::<_z_decl_subscriber_t>() - 8usize];
    ["Offset of field: _z_decl_subscriber_t::_keyexpr"]
        [::core::mem::offset_of!(_z_decl_subscriber_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_subscriber_t::_id"]
        [::core::mem::offset_of!(_z_decl_subscriber_t, _id) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_subscriber_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_subscriber_t"][::core::mem::size_of::<_z_undecl_subscriber_t>() - 56usize];
    ["Alignment of _z_undecl_subscriber_t"]
        [::core::mem::align_of::<_z_undecl_subscriber_t>() - 8usize];
    ["Offset of field: _z_undecl_subscriber_t::_id"]
        [::core::mem::offset_of!(_z_undecl_subscriber_t, _id) - 0usize];
    ["Offset of field: _z_undecl_subscriber_t::_ext_keyexpr"]
        [::core::mem::offset_of!(_z_undecl_subscriber_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_queryable_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
    pub _ext_queryable_info: _z_decl_queryable_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_queryable_t__bindgen_ty_1 {
    pub _complete: bool,
    pub _distance: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_queryable_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_decl_queryable_t__bindgen_ty_1>() - 4usize];
    ["Alignment of _z_decl_queryable_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_decl_queryable_t__bindgen_ty_1>() - 2usize];
    ["Offset of field: _z_decl_queryable_t__bindgen_ty_1::_complete"]
        [::core::mem::offset_of!(_z_decl_queryable_t__bindgen_ty_1, _complete) - 0usize];
    ["Offset of field: _z_decl_queryable_t__bindgen_ty_1::_distance"]
        [::core::mem::offset_of!(_z_decl_queryable_t__bindgen_ty_1, _distance) - 2usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_queryable_t"][::core::mem::size_of::<_z_decl_queryable_t>() - 56usize];
    ["Alignment of _z_decl_queryable_t"][::core::mem::align_of::<_z_decl_queryable_t>() - 8usize];
    ["Offset of field: _z_decl_queryable_t::_keyexpr"]
        [::core::mem::offset_of!(_z_decl_queryable_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_queryable_t::_id"]
        [::core::mem::offset_of!(_z_decl_queryable_t, _id) - 48usize];
    ["Offset of field: _z_decl_queryable_t::_ext_queryable_info"]
        [::core::mem::offset_of!(_z_decl_queryable_t, _ext_queryable_info) - 52usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_queryable_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_queryable_t"][::core::mem::size_of::<_z_undecl_queryable_t>() - 56usize];
    ["Alignment of _z_undecl_queryable_t"]
        [::core::mem::align_of::<_z_undecl_queryable_t>() - 8usize];
    ["Offset of field: _z_undecl_queryable_t::_id"]
        [::core::mem::offset_of!(_z_undecl_queryable_t, _id) - 0usize];
    ["Offset of field: _z_undecl_queryable_t::_ext_keyexpr"]
        [::core::mem::offset_of!(_z_undecl_queryable_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_token_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_token_t"][::core::mem::size_of::<_z_decl_token_t>() - 56usize];
    ["Alignment of _z_decl_token_t"][::core::mem::align_of::<_z_decl_token_t>() - 8usize];
    ["Offset of field: _z_decl_token_t::_keyexpr"]
        [::core::mem::offset_of!(_z_decl_token_t, _keyexpr) - 0usize];
    ["Offset of field: _z_decl_token_t::_id"]
        [::core::mem::offset_of!(_z_decl_token_t, _id) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_undecl_token_t {
    pub _id: u32,
    pub _ext_keyexpr: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_undecl_token_t"][::core::mem::size_of::<_z_undecl_token_t>() - 56usize];
    ["Alignment of _z_undecl_token_t"][::core::mem::align_of::<_z_undecl_token_t>() - 8usize];
    ["Offset of field: _z_undecl_token_t::_id"]
        [::core::mem::offset_of!(_z_undecl_token_t, _id) - 0usize];
    ["Offset of field: _z_undecl_token_t::_ext_keyexpr"]
        [::core::mem::offset_of!(_z_undecl_token_t, _ext_keyexpr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_decl_final_t {
    pub _placeholder: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_decl_final_t"][::core::mem::size_of::<_z_decl_final_t>() - 1usize];
    ["Alignment of _z_decl_final_t"][::core::mem::align_of::<_z_decl_final_t>() - 1usize];
    ["Offset of field: _z_decl_final_t::_placeholder"]
        [::core::mem::offset_of!(_z_decl_final_t, _placeholder) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_declaration_t {
    pub _tag: _z_declaration_t__bindgen_ty_1,
    pub _body: _z_declaration_t__bindgen_ty_2,
}
pub const _z_declaration_t__Z_DECL_KEXPR: _z_declaration_t__bindgen_ty_1 = 0;
pub const _z_declaration_t__Z_UNDECL_KEXPR: _z_declaration_t__bindgen_ty_1 = 1;
pub const _z_declaration_t__Z_DECL_SUBSCRIBER: _z_declaration_t__bindgen_ty_1 = 2;
pub const _z_declaration_t__Z_UNDECL_SUBSCRIBER: _z_declaration_t__bindgen_ty_1 = 3;
pub const _z_declaration_t__Z_DECL_QUERYABLE: _z_declaration_t__bindgen_ty_1 = 4;
pub const _z_declaration_t__Z_UNDECL_QUERYABLE: _z_declaration_t__bindgen_ty_1 = 5;
pub const _z_declaration_t__Z_DECL_TOKEN: _z_declaration_t__bindgen_ty_1 = 6;
pub const _z_declaration_t__Z_UNDECL_TOKEN: _z_declaration_t__bindgen_ty_1 = 7;
pub const _z_declaration_t__Z_DECL_FINAL: _z_declaration_t__bindgen_ty_1 = 8;
pub type _z_declaration_t__bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_declaration_t__bindgen_ty_2 {
    pub _decl_kexpr: _z_decl_kexpr_t,
    pub _undecl_kexpr: _z_undecl_kexpr_t,
    pub _decl_subscriber: _z_decl_subscriber_t,
    pub _undecl_subscriber: _z_undecl_subscriber_t,
    pub _decl_queryable: _z_decl_queryable_t,
    pub _undecl_queryable: _z_undecl_queryable_t,
    pub _decl_token: _z_decl_token_t,
    pub _undecl_token: _z_undecl_token_t,
    pub _decl_final: _z_decl_final_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declaration_t__bindgen_ty_2"]
        [::core::mem::size_of::<_z_declaration_t__bindgen_ty_2>() - 56usize];
    ["Alignment of _z_declaration_t__bindgen_ty_2"]
        [::core::mem::align_of::<_z_declaration_t__bindgen_ty_2>() - 8usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_kexpr"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_kexpr) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_kexpr"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_kexpr) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_subscriber"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_subscriber) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_subscriber"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_subscriber) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_queryable"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_queryable) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_queryable"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_queryable) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_token"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_token) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_undecl_token"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _undecl_token) - 0usize];
    ["Offset of field: _z_declaration_t__bindgen_ty_2::_decl_final"]
        [::core::mem::offset_of!(_z_declaration_t__bindgen_ty_2, _decl_final) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declaration_t"][::core::mem::size_of::<_z_declaration_t>() - 64usize];
    ["Alignment of _z_declaration_t"][::core::mem::align_of::<_z_declaration_t>() - 8usize];
    ["Offset of field: _z_declaration_t::_tag"]
        [::core::mem::offset_of!(_z_declaration_t, _tag) - 0usize];
    ["Offset of field: _z_declaration_t::_body"]
        [::core::mem::offset_of!(_z_declaration_t, _body) - 8usize];
};
unsafe extern "C" {
    pub fn _z_declaration_clear(decl: *mut _z_declaration_t);
}
unsafe extern "C" {
    pub fn _z_make_decl_keyexpr(id: u16, key: *mut _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_keyexpr(id: u16) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_subscriber(key: *mut _z_keyexpr_t, id: u32) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_subscriber(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_queryable(
        key: *mut _z_keyexpr_t,
        id: u32,
        complete: bool,
        distance: u16,
    ) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_queryable(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_token(key: *mut _z_keyexpr_t, id: u32) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_undecl_token(id: u32, key: *const _z_keyexpr_t) -> _z_declaration_t;
}
unsafe extern "C" {
    pub fn _z_make_decl_final() -> _z_declaration_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_interest_t {
    pub _keyexpr: _z_keyexpr_t,
    pub _id: u32,
    pub flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_interest_t"][::core::mem::size_of::<_z_interest_t>() - 56usize];
    ["Alignment of _z_interest_t"][::core::mem::align_of::<_z_interest_t>() - 8usize];
    ["Offset of field: _z_interest_t::_keyexpr"]
        [::core::mem::offset_of!(_z_interest_t, _keyexpr) - 0usize];
    ["Offset of field: _z_interest_t::_id"][::core::mem::offset_of!(_z_interest_t, _id) - 48usize];
    ["Offset of field: _z_interest_t::flags"]
        [::core::mem::offset_of!(_z_interest_t, flags) - 52usize];
};
unsafe extern "C" {
    pub fn _z_interest_clear(decl: *mut _z_interest_t);
}
unsafe extern "C" {
    pub fn _z_make_interest(key: *mut _z_keyexpr_t, id: u32, flags: u8) -> _z_interest_t;
}
unsafe extern "C" {
    pub fn _z_make_interest_final(id: u32) -> _z_interest_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_err_t {
    pub _encoding: _z_encoding_t,
    pub _ext_source_info: _z_source_info_t,
    pub _payload: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_err_t"][::core::mem::size_of::<_z_msg_err_t>() - 96usize];
    ["Alignment of _z_msg_err_t"][::core::mem::align_of::<_z_msg_err_t>() - 8usize];
    ["Offset of field: _z_msg_err_t::_encoding"]
        [::core::mem::offset_of!(_z_msg_err_t, _encoding) - 0usize];
    ["Offset of field: _z_msg_err_t::_ext_source_info"]
        [::core::mem::offset_of!(_z_msg_err_t, _ext_source_info) - 40usize];
    ["Offset of field: _z_msg_err_t::_payload"]
        [::core::mem::offset_of!(_z_msg_err_t, _payload) - 64usize];
};
unsafe extern "C" {
    pub fn _z_msg_err_clear(err: *mut _z_msg_err_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_m_push_commons_t {
    pub _timestamp: _z_timestamp_t,
    pub _source_info: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_m_push_commons_t"][::core::mem::size_of::<_z_m_push_commons_t>() - 56usize];
    ["Alignment of _z_m_push_commons_t"][::core::mem::align_of::<_z_m_push_commons_t>() - 8usize];
    ["Offset of field: _z_m_push_commons_t::_timestamp"]
        [::core::mem::offset_of!(_z_m_push_commons_t, _timestamp) - 0usize];
    ["Offset of field: _z_m_push_commons_t::_source_info"]
        [::core::mem::offset_of!(_z_m_push_commons_t, _source_info) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_del_t {
    pub _commons: _z_m_push_commons_t,
    pub _attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_del_t"][::core::mem::size_of::<_z_msg_del_t>() - 88usize];
    ["Alignment of _z_msg_del_t"][::core::mem::align_of::<_z_msg_del_t>() - 8usize];
    ["Offset of field: _z_msg_del_t::_commons"]
        [::core::mem::offset_of!(_z_msg_del_t, _commons) - 0usize];
    ["Offset of field: _z_msg_del_t::_attachment"]
        [::core::mem::offset_of!(_z_msg_del_t, _attachment) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_put_t {
    pub _commons: _z_m_push_commons_t,
    pub _payload: _z_bytes_t,
    pub _encoding: _z_encoding_t,
    pub _attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_put_t"][::core::mem::size_of::<_z_msg_put_t>() - 160usize];
    ["Alignment of _z_msg_put_t"][::core::mem::align_of::<_z_msg_put_t>() - 8usize];
    ["Offset of field: _z_msg_put_t::_commons"]
        [::core::mem::offset_of!(_z_msg_put_t, _commons) - 0usize];
    ["Offset of field: _z_msg_put_t::_payload"]
        [::core::mem::offset_of!(_z_msg_put_t, _payload) - 56usize];
    ["Offset of field: _z_msg_put_t::_encoding"]
        [::core::mem::offset_of!(_z_msg_put_t, _encoding) - 88usize];
    ["Offset of field: _z_msg_put_t::_attachment"]
        [::core::mem::offset_of!(_z_msg_put_t, _attachment) - 128usize];
};
unsafe extern "C" {
    pub fn _z_msg_put_clear(arg1: *mut _z_msg_put_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_query_t {
    pub _parameters: _z_slice_t,
    pub _ext_info: _z_source_info_t,
    pub _ext_value: _z_value_t,
    pub _consolidation: z_consolidation_mode_t,
    pub _ext_attachment: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_query_t"][::core::mem::size_of::<_z_msg_query_t>() - 168usize];
    ["Alignment of _z_msg_query_t"][::core::mem::align_of::<_z_msg_query_t>() - 8usize];
    ["Offset of field: _z_msg_query_t::_parameters"]
        [::core::mem::offset_of!(_z_msg_query_t, _parameters) - 0usize];
    ["Offset of field: _z_msg_query_t::_ext_info"]
        [::core::mem::offset_of!(_z_msg_query_t, _ext_info) - 32usize];
    ["Offset of field: _z_msg_query_t::_ext_value"]
        [::core::mem::offset_of!(_z_msg_query_t, _ext_value) - 56usize];
    ["Offset of field: _z_msg_query_t::_consolidation"]
        [::core::mem::offset_of!(_z_msg_query_t, _consolidation) - 128usize];
    ["Offset of field: _z_msg_query_t::_ext_attachment"]
        [::core::mem::offset_of!(_z_msg_query_t, _ext_attachment) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_query_reqexts_t {
    pub info: bool,
    pub body: bool,
    pub attachment: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_query_reqexts_t"][::core::mem::size_of::<_z_msg_query_reqexts_t>() - 3usize];
    ["Alignment of _z_msg_query_reqexts_t"]
        [::core::mem::align_of::<_z_msg_query_reqexts_t>() - 1usize];
    ["Offset of field: _z_msg_query_reqexts_t::info"]
        [::core::mem::offset_of!(_z_msg_query_reqexts_t, info) - 0usize];
    ["Offset of field: _z_msg_query_reqexts_t::body"]
        [::core::mem::offset_of!(_z_msg_query_reqexts_t, body) - 1usize];
    ["Offset of field: _z_msg_query_reqexts_t::attachment"]
        [::core::mem::offset_of!(_z_msg_query_reqexts_t, attachment) - 2usize];
};
unsafe extern "C" {
    pub fn _z_msg_query_required_extensions(msg: *const _z_msg_query_t) -> _z_msg_query_reqexts_t;
}
unsafe extern "C" {
    pub fn _z_msg_query_clear(msg: *mut _z_msg_query_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_body_t {
    pub _is_put: bool,
    pub _body: _z_reply_body_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_reply_body_t__bindgen_ty_1 {
    pub _del: _z_msg_del_t,
    pub _put: _z_msg_put_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_body_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_reply_body_t__bindgen_ty_1>() - 160usize];
    ["Alignment of _z_reply_body_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_reply_body_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_reply_body_t__bindgen_ty_1::_del"]
        [::core::mem::offset_of!(_z_reply_body_t__bindgen_ty_1, _del) - 0usize];
    ["Offset of field: _z_reply_body_t__bindgen_ty_1::_put"]
        [::core::mem::offset_of!(_z_reply_body_t__bindgen_ty_1, _put) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_body_t"][::core::mem::size_of::<_z_reply_body_t>() - 168usize];
    ["Alignment of _z_reply_body_t"][::core::mem::align_of::<_z_reply_body_t>() - 8usize];
    ["Offset of field: _z_reply_body_t::_is_put"]
        [::core::mem::offset_of!(_z_reply_body_t, _is_put) - 0usize];
    ["Offset of field: _z_reply_body_t::_body"]
        [::core::mem::offset_of!(_z_reply_body_t, _body) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_msg_reply_t {
    pub _consolidation: z_consolidation_mode_t,
    pub _body: _z_reply_body_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_reply_t"][::core::mem::size_of::<_z_msg_reply_t>() - 176usize];
    ["Alignment of _z_msg_reply_t"][::core::mem::align_of::<_z_msg_reply_t>() - 8usize];
    ["Offset of field: _z_msg_reply_t::_consolidation"]
        [::core::mem::offset_of!(_z_msg_reply_t, _consolidation) - 0usize];
    ["Offset of field: _z_msg_reply_t::_body"]
        [::core::mem::offset_of!(_z_msg_reply_t, _body) - 8usize];
};
unsafe extern "C" {
    pub fn _z_msg_reply_clear(msg: *mut _z_msg_reply_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_unit_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_unit_t"][::core::mem::size_of::<_z_msg_ext_unit_t>() - 1usize];
    ["Alignment of _z_msg_ext_unit_t"][::core::mem::align_of::<_z_msg_ext_unit_t>() - 1usize];
    ["Offset of field: _z_msg_ext_unit_t::__dummy"]
        [::core::mem::offset_of!(_z_msg_ext_unit_t, __dummy) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_unit(ext: *mut _z_msg_ext_unit_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_zint_t {
    pub _val: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_zint_t"][::core::mem::size_of::<_z_msg_ext_zint_t>() - 8usize];
    ["Alignment of _z_msg_ext_zint_t"][::core::mem::align_of::<_z_msg_ext_zint_t>() - 8usize];
    ["Offset of field: _z_msg_ext_zint_t::_val"]
        [::core::mem::offset_of!(_z_msg_ext_zint_t, _val) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_zint(ext: *mut _z_msg_ext_zint_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_msg_ext_zbuf_t {
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_zbuf_t"][::core::mem::size_of::<_z_msg_ext_zbuf_t>() - 32usize];
    ["Alignment of _z_msg_ext_zbuf_t"][::core::mem::align_of::<_z_msg_ext_zbuf_t>() - 8usize];
    ["Offset of field: _z_msg_ext_zbuf_t::_val"]
        [::core::mem::offset_of!(_z_msg_ext_zbuf_t, _val) - 0usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear_zbuf(ext: *mut _z_msg_ext_zbuf_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_msg_ext_body_t {
    pub _unit: _z_msg_ext_unit_t,
    pub _zint: _z_msg_ext_zint_t,
    pub _zbuf: _z_msg_ext_zbuf_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_body_t"][::core::mem::size_of::<_z_msg_ext_body_t>() - 32usize];
    ["Alignment of _z_msg_ext_body_t"][::core::mem::align_of::<_z_msg_ext_body_t>() - 8usize];
    ["Offset of field: _z_msg_ext_body_t::_unit"]
        [::core::mem::offset_of!(_z_msg_ext_body_t, _unit) - 0usize];
    ["Offset of field: _z_msg_ext_body_t::_zint"]
        [::core::mem::offset_of!(_z_msg_ext_body_t, _zint) - 0usize];
    ["Offset of field: _z_msg_ext_body_t::_zbuf"]
        [::core::mem::offset_of!(_z_msg_ext_body_t, _zbuf) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_msg_ext_t {
    pub _body: _z_msg_ext_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_msg_ext_t"][::core::mem::size_of::<_z_msg_ext_t>() - 40usize];
    ["Alignment of _z_msg_ext_t"][::core::mem::align_of::<_z_msg_ext_t>() - 8usize];
    ["Offset of field: _z_msg_ext_t::_body"][::core::mem::offset_of!(_z_msg_ext_t, _body) - 0usize];
    ["Offset of field: _z_msg_ext_t::_header"]
        [::core::mem::offset_of!(_z_msg_ext_t, _header) - 32usize];
};
unsafe extern "C" {
    pub fn _z_msg_ext_clear(ext: *mut _z_msg_ext_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_unit(id: u8) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_zint(id: u8, zid: _z_zint_t) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_make_zbuf(id: u8, zbuf: _z_slice_t) -> _z_msg_ext_t;
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy(clone: *mut _z_msg_ext_t, ext: *const _z_msg_ext_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_unit(clone: *mut _z_msg_ext_unit_t, ext: *const _z_msg_ext_unit_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_zint(clone: *mut _z_msg_ext_zint_t, ext: *const _z_msg_ext_zint_t);
}
unsafe extern "C" {
    pub fn _z_msg_ext_copy_zbuf(clone: *mut _z_msg_ext_zbuf_t, ext: *const _z_msg_ext_zbuf_t);
}
pub type _z_msg_ext_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_msg_ext_t, right: *const _z_msg_ext_t) -> bool,
>;
pub type _z_msg_ext_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_msg_ext_t,
        right: *const _z_msg_ext_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored as pointers."]
pub type _z_msg_ext_vec_t = _z_vec_t;
#[doc = " QoS settings of zenoh message."]
pub type _z_n_qos_t = _z_qos_t;
unsafe extern "C" {
    pub static _Z_N_QOS_DEFAULT: _z_qos_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_request_t {
    pub _rid: _z_zint_t,
    pub _key: _z_keyexpr_t,
    pub _ext_timestamp: _z_timestamp_t,
    pub _ext_qos: _z_n_qos_t,
    pub _ext_target: z_query_target_t,
    pub _ext_budget: u32,
    pub _ext_timeout_ms: u64,
    pub _tag: _z_n_msg_request_t__bindgen_ty_1,
    pub _body: _z_n_msg_request_t__bindgen_ty_2,
}
pub const _z_n_msg_request_t__Z_REQUEST_QUERY: _z_n_msg_request_t__bindgen_ty_1 = 0;
pub const _z_n_msg_request_t__Z_REQUEST_PUT: _z_n_msg_request_t__bindgen_ty_1 = 1;
pub const _z_n_msg_request_t__Z_REQUEST_DEL: _z_n_msg_request_t__bindgen_ty_1 = 2;
pub type _z_n_msg_request_t__bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_n_msg_request_t__bindgen_ty_2 {
    pub _query: _z_msg_query_t,
    pub _put: _z_msg_put_t,
    pub _del: _z_msg_del_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_t__bindgen_ty_2"]
        [::core::mem::size_of::<_z_n_msg_request_t__bindgen_ty_2>() - 168usize];
    ["Alignment of _z_n_msg_request_t__bindgen_ty_2"]
        [::core::mem::align_of::<_z_n_msg_request_t__bindgen_ty_2>() - 8usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_query"]
        [::core::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _query) - 0usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_put"]
        [::core::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _put) - 0usize];
    ["Offset of field: _z_n_msg_request_t__bindgen_ty_2::_del"]
        [::core::mem::offset_of!(_z_n_msg_request_t__bindgen_ty_2, _del) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_t"][::core::mem::size_of::<_z_n_msg_request_t>() - 288usize];
    ["Alignment of _z_n_msg_request_t"][::core::mem::align_of::<_z_n_msg_request_t>() - 8usize];
    ["Offset of field: _z_n_msg_request_t::_rid"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _rid) - 0usize];
    ["Offset of field: _z_n_msg_request_t::_key"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _key) - 8usize];
    ["Offset of field: _z_n_msg_request_t::_ext_timestamp"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _ext_timestamp) - 56usize];
    ["Offset of field: _z_n_msg_request_t::_ext_qos"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _ext_qos) - 88usize];
    ["Offset of field: _z_n_msg_request_t::_ext_target"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _ext_target) - 92usize];
    ["Offset of field: _z_n_msg_request_t::_ext_budget"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _ext_budget) - 96usize];
    ["Offset of field: _z_n_msg_request_t::_ext_timeout_ms"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _ext_timeout_ms) - 104usize];
    ["Offset of field: _z_n_msg_request_t::_tag"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _tag) - 112usize];
    ["Offset of field: _z_n_msg_request_t::_body"]
        [::core::mem::offset_of!(_z_n_msg_request_t, _body) - 120usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_request_exts_t {
    pub ext_qos: bool,
    pub ext_tstamp: bool,
    pub ext_target: bool,
    pub ext_budget: bool,
    pub ext_timeout_ms: bool,
    pub n: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_request_exts_t"][::core::mem::size_of::<_z_n_msg_request_exts_t>() - 6usize];
    ["Alignment of _z_n_msg_request_exts_t"]
        [::core::mem::align_of::<_z_n_msg_request_exts_t>() - 1usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_qos"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, ext_qos) - 0usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_tstamp"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, ext_tstamp) - 1usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_target"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, ext_target) - 2usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_budget"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, ext_budget) - 3usize];
    ["Offset of field: _z_n_msg_request_exts_t::ext_timeout_ms"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, ext_timeout_ms) - 4usize];
    ["Offset of field: _z_n_msg_request_exts_t::n"]
        [::core::mem::offset_of!(_z_n_msg_request_exts_t, n) - 5usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_request_needed_exts(msg: *const _z_n_msg_request_t) -> _z_n_msg_request_exts_t;
}
unsafe extern "C" {
    pub fn _z_n_msg_request_clear(msg: *mut _z_n_msg_request_t);
}
pub type _z_push_body_t = _z_reply_body_t;
unsafe extern "C" {
    pub fn _z_push_body_steal(msg: *mut _z_push_body_t) -> _z_push_body_t;
}
unsafe extern "C" {
    pub fn _z_push_body_clear(msg: *mut _z_push_body_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_response_final_t {
    pub _request_id: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_final_t"]
        [::core::mem::size_of::<_z_n_msg_response_final_t>() - 8usize];
    ["Alignment of _z_n_msg_response_final_t"]
        [::core::mem::align_of::<_z_n_msg_response_final_t>() - 8usize];
    ["Offset of field: _z_n_msg_response_final_t::_request_id"]
        [::core::mem::offset_of!(_z_n_msg_response_final_t, _request_id) - 0usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_response_final_clear(msg: *mut _z_n_msg_response_final_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_push_t {
    pub _key: _z_keyexpr_t,
    pub _timestamp: _z_timestamp_t,
    pub _qos: _z_n_qos_t,
    pub _body: _z_push_body_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_push_t"][::core::mem::size_of::<_z_n_msg_push_t>() - 256usize];
    ["Alignment of _z_n_msg_push_t"][::core::mem::align_of::<_z_n_msg_push_t>() - 8usize];
    ["Offset of field: _z_n_msg_push_t::_key"]
        [::core::mem::offset_of!(_z_n_msg_push_t, _key) - 0usize];
    ["Offset of field: _z_n_msg_push_t::_timestamp"]
        [::core::mem::offset_of!(_z_n_msg_push_t, _timestamp) - 48usize];
    ["Offset of field: _z_n_msg_push_t::_qos"]
        [::core::mem::offset_of!(_z_n_msg_push_t, _qos) - 80usize];
    ["Offset of field: _z_n_msg_push_t::_body"]
        [::core::mem::offset_of!(_z_n_msg_push_t, _body) - 88usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_push_clear(msg: *mut _z_n_msg_push_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_response_t {
    pub _ext_timestamp: _z_timestamp_t,
    pub _request_id: _z_zint_t,
    pub _key: _z_keyexpr_t,
    pub _ext_qos: _z_n_qos_t,
    pub _ext_responder: _z_n_msg_response_t__bindgen_ty_1,
    pub _tag: _z_n_msg_response_t__bindgen_ty_2,
    pub _body: _z_n_msg_response_t__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_response_t__bindgen_ty_1 {
    pub _zid: _z_id_t,
    pub _eid: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_n_msg_response_t__bindgen_ty_1>() - 20usize];
    ["Alignment of _z_n_msg_response_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_n_msg_response_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_1::_zid"]
        [::core::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_1, _zid) - 0usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_1::_eid"]
        [::core::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_1, _eid) - 16usize];
};
pub const _z_n_msg_response_t__Z_RESPONSE_BODY_REPLY: _z_n_msg_response_t__bindgen_ty_2 = 0;
pub const _z_n_msg_response_t__Z_RESPONSE_BODY_ERR: _z_n_msg_response_t__bindgen_ty_2 = 1;
pub type _z_n_msg_response_t__bindgen_ty_2 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_n_msg_response_t__bindgen_ty_3 {
    pub _reply: _z_msg_reply_t,
    pub _err: _z_msg_err_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t__bindgen_ty_3"]
        [::core::mem::size_of::<_z_n_msg_response_t__bindgen_ty_3>() - 176usize];
    ["Alignment of _z_n_msg_response_t__bindgen_ty_3"]
        [::core::mem::align_of::<_z_n_msg_response_t__bindgen_ty_3>() - 8usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_3::_reply"]
        [::core::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_3, _reply) - 0usize];
    ["Offset of field: _z_n_msg_response_t__bindgen_ty_3::_err"]
        [::core::mem::offset_of!(_z_n_msg_response_t__bindgen_ty_3, _err) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_response_t"][::core::mem::size_of::<_z_n_msg_response_t>() - 296usize];
    ["Alignment of _z_n_msg_response_t"][::core::mem::align_of::<_z_n_msg_response_t>() - 8usize];
    ["Offset of field: _z_n_msg_response_t::_ext_timestamp"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _ext_timestamp) - 0usize];
    ["Offset of field: _z_n_msg_response_t::_request_id"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _request_id) - 32usize];
    ["Offset of field: _z_n_msg_response_t::_key"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _key) - 40usize];
    ["Offset of field: _z_n_msg_response_t::_ext_qos"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _ext_qos) - 88usize];
    ["Offset of field: _z_n_msg_response_t::_ext_responder"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _ext_responder) - 92usize];
    ["Offset of field: _z_n_msg_response_t::_tag"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _tag) - 112usize];
    ["Offset of field: _z_n_msg_response_t::_body"]
        [::core::mem::offset_of!(_z_n_msg_response_t, _body) - 120usize];
};
unsafe extern "C" {
    pub fn _z_n_msg_response_clear(msg: *mut _z_n_msg_response_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_n_msg_declare_t {
    pub _decl: _z_declaration_t,
    pub _ext_timestamp: _z_timestamp_t,
    pub _ext_qos: _z_n_qos_t,
    pub _interest_id: u32,
    pub has_interest_id: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_declare_t"][::core::mem::size_of::<_z_n_msg_declare_t>() - 112usize];
    ["Alignment of _z_n_msg_declare_t"][::core::mem::align_of::<_z_n_msg_declare_t>() - 8usize];
    ["Offset of field: _z_n_msg_declare_t::_decl"]
        [::core::mem::offset_of!(_z_n_msg_declare_t, _decl) - 0usize];
    ["Offset of field: _z_n_msg_declare_t::_ext_timestamp"]
        [::core::mem::offset_of!(_z_n_msg_declare_t, _ext_timestamp) - 64usize];
    ["Offset of field: _z_n_msg_declare_t::_ext_qos"]
        [::core::mem::offset_of!(_z_n_msg_declare_t, _ext_qos) - 96usize];
    ["Offset of field: _z_n_msg_declare_t::_interest_id"]
        [::core::mem::offset_of!(_z_n_msg_declare_t, _interest_id) - 100usize];
    ["Offset of field: _z_n_msg_declare_t::has_interest_id"]
        [::core::mem::offset_of!(_z_n_msg_declare_t, has_interest_id) - 104usize];
};
#[doc = " Flags:\n - C: Current       If C==1 then interest concerns current declarations\n - F: Future        If F==1 then interest concerns future declarations\n - Z: Extension     If Z==1 then Zenoh extensions are present\n If C==0 and F==0, then interest is final\n\n 7 6 5 4 3 2 1 0\n +-+-+-+-+-+-+-+-+\n |Z|F|C|INTEREST |\n +-+-+-+---------+\n ~    id:z32     ~\n +---------------+\n |A|M|N|R|T|Q|S|K|  (*) if interest is not final\n +---------------+\n ~ key_scope:z16 ~  if interest is not final && R==1\n +---------------+\n ~  key_suffix   ~  if interest is not final && R==1 && N==1 -- <u8;z16>\n +---------------+\n ~  [int_exts]   ~  if Z==1\n +---------------+\n\n (*) - if K==1 then the interest refers to key expressions\n     - if S==1 then the interest refers to subscribers\n     - if Q==1 then the interest refers to queryables\n     - if T==1 then the interest refers to tokens\n     - if R==1 then the interest is restricted to the matching key expression, else it is for all key expressions.\n     - if N==1 then the key expr has name/suffix. If R==0 then N should be set to 0.\n     - if M==1 then key expr mapping is the one declared by the sender, else it is the one declared by the receiver.\n               If R==0 then M should be set to 0.\n     - if A==1 then the replies SHOULD be aggregated\n ```"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_n_msg_interest_t {
    pub _interest: _z_interest_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_n_msg_interest_t"][::core::mem::size_of::<_z_n_msg_interest_t>() - 56usize];
    ["Alignment of _z_n_msg_interest_t"][::core::mem::align_of::<_z_n_msg_interest_t>() - 8usize];
    ["Offset of field: _z_n_msg_interest_t::_interest"]
        [::core::mem::offset_of!(_z_n_msg_interest_t, _interest) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_network_body_t {
    pub _declare: _z_n_msg_declare_t,
    pub _push: _z_n_msg_push_t,
    pub _request: _z_n_msg_request_t,
    pub _response: _z_n_msg_response_t,
    pub _response_final: _z_n_msg_response_final_t,
    pub _interest: _z_n_msg_interest_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_network_body_t"][::core::mem::size_of::<_z_network_body_t>() - 296usize];
    ["Alignment of _z_network_body_t"][::core::mem::align_of::<_z_network_body_t>() - 8usize];
    ["Offset of field: _z_network_body_t::_declare"]
        [::core::mem::offset_of!(_z_network_body_t, _declare) - 0usize];
    ["Offset of field: _z_network_body_t::_push"]
        [::core::mem::offset_of!(_z_network_body_t, _push) - 0usize];
    ["Offset of field: _z_network_body_t::_request"]
        [::core::mem::offset_of!(_z_network_body_t, _request) - 0usize];
    ["Offset of field: _z_network_body_t::_response"]
        [::core::mem::offset_of!(_z_network_body_t, _response) - 0usize];
    ["Offset of field: _z_network_body_t::_response_final"]
        [::core::mem::offset_of!(_z_network_body_t, _response_final) - 0usize];
    ["Offset of field: _z_network_body_t::_interest"]
        [::core::mem::offset_of!(_z_network_body_t, _interest) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_network_message_t {
    pub _tag: _z_network_message_t__bindgen_ty_1,
    pub _body: _z_network_body_t,
    pub _reliability: z_reliability_t,
}
pub const _z_network_message_t__Z_N_DECLARE: _z_network_message_t__bindgen_ty_1 = 0;
pub const _z_network_message_t__Z_N_PUSH: _z_network_message_t__bindgen_ty_1 = 1;
pub const _z_network_message_t__Z_N_REQUEST: _z_network_message_t__bindgen_ty_1 = 2;
pub const _z_network_message_t__Z_N_RESPONSE: _z_network_message_t__bindgen_ty_1 = 3;
pub const _z_network_message_t__Z_N_RESPONSE_FINAL: _z_network_message_t__bindgen_ty_1 = 4;
pub const _z_network_message_t__Z_N_INTEREST: _z_network_message_t__bindgen_ty_1 = 5;
pub type _z_network_message_t__bindgen_ty_1 = ::core::ffi::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_network_message_t"][::core::mem::size_of::<_z_network_message_t>() - 312usize];
    ["Alignment of _z_network_message_t"][::core::mem::align_of::<_z_network_message_t>() - 8usize];
    ["Offset of field: _z_network_message_t::_tag"]
        [::core::mem::offset_of!(_z_network_message_t, _tag) - 0usize];
    ["Offset of field: _z_network_message_t::_body"]
        [::core::mem::offset_of!(_z_network_message_t, _body) - 8usize];
    ["Offset of field: _z_network_message_t::_reliability"]
        [::core::mem::offset_of!(_z_network_message_t, _reliability) - 304usize];
};
pub type _z_zenoh_message_t = _z_network_message_t;
unsafe extern "C" {
    pub fn _z_n_msg_clear(m: *mut _z_network_message_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_free(m: *mut *mut _z_network_message_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_copy(
        dst: *mut _z_network_message_t,
        src: *const _z_network_message_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_n_msg_clone(src: *const _z_network_message_t) -> *mut _z_network_message_t;
}
pub type _z_network_message_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_network_message_t,
        right: *const _z_network_message_t,
    ) -> bool,
>;
pub type _z_network_message_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_network_message_t,
        right: *const _z_network_message_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_network_message_svec_t = _z_svec_t;
pub type _z_network_message_slist_t = _z_slist_t;
unsafe extern "C" {
    pub fn _z_n_msg_make_response_final(msg: *mut _z_network_message_t, rid: _z_zint_t);
}
unsafe extern "C" {
    pub fn _z_n_msg_make_declare(
        msg: *mut _z_network_message_t,
        declaration: _z_declaration_t,
        has_interest_id: bool,
        interest_id: u32,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_query(
        msg: *mut _z_zenoh_message_t,
        key: *const _z_keyexpr_t,
        parameters: *const _z_slice_t,
        qid: _z_zint_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        timeout_ms: u64,
        attachment: *const _z_bytes_t,
        qos: _z_n_qos_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_push_put(
        dst: *mut _z_network_message_t,
        key: *const _z_keyexpr_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        attachment: *const _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_push_del(
        dst: *mut _z_network_message_t,
        key: *const _z_keyexpr_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_ok_put(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        key: *const _z_keyexpr_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        source_info: *const _z_source_info_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        attachment: *const _z_bytes_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_ok_del(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        key: *const _z_keyexpr_t,
        reliability: z_reliability_t,
        consolidation: z_consolidation_mode_t,
        qos: _z_n_qos_t,
        timestamp: *const _z_timestamp_t,
        source_info: *const _z_source_info_t,
        attachment: *const _z_bytes_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_reply_err(
        dst: *mut _z_network_message_t,
        zid: *const _z_id_t,
        rid: _z_zint_t,
        reliability: z_reliability_t,
        qos: _z_n_qos_t,
        payload: *const _z_bytes_t,
        encoding: *const _z_encoding_t,
        source_info: *const _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_n_msg_make_interest(msg: *mut _z_network_message_t, interest: _z_interest_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_locator_t {
    pub _metadata: _z_str_intmap_t,
    pub _protocol: _z_string_t,
    pub _address: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_locator_t"][::core::mem::size_of::<_z_locator_t>() - 96usize];
    ["Alignment of _z_locator_t"][::core::mem::align_of::<_z_locator_t>() - 8usize];
    ["Offset of field: _z_locator_t::_metadata"]
        [::core::mem::offset_of!(_z_locator_t, _metadata) - 0usize];
    ["Offset of field: _z_locator_t::_protocol"]
        [::core::mem::offset_of!(_z_locator_t, _protocol) - 32usize];
    ["Offset of field: _z_locator_t::_address"]
        [::core::mem::offset_of!(_z_locator_t, _address) - 64usize];
};
unsafe extern "C" {
    pub fn _z_locator_eq(left: *const _z_locator_t, right: *const _z_locator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_locator_init(locator: *mut _z_locator_t);
}
unsafe extern "C" {
    pub fn _z_locator_to_string(loc: *const _z_locator_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_locator_from_string(lc: *mut _z_locator_t, s: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_locator_size(lc: *mut _z_locator_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_locator_clear(lc: *mut _z_locator_t);
}
pub type _z_locator_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_locator_t, right: *const _z_locator_t) -> bool,
>;
pub type _z_locator_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_locator_t,
        right: *const _z_locator_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_locator_array_t {
    pub _len: usize,
    pub _val: *mut _z_locator_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_locator_array_t"][::core::mem::size_of::<_z_locator_array_t>() - 16usize];
    ["Alignment of _z_locator_array_t"][::core::mem::align_of::<_z_locator_array_t>() - 8usize];
    ["Offset of field: _z_locator_array_t::_len"]
        [::core::mem::offset_of!(_z_locator_array_t, _len) - 0usize];
    ["Offset of field: _z_locator_array_t::_val"]
        [::core::mem::offset_of!(_z_locator_array_t, _val) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_endpoint_t {
    pub _locator: _z_locator_t,
    pub _config: _z_str_intmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_endpoint_t"][::core::mem::size_of::<_z_endpoint_t>() - 128usize];
    ["Alignment of _z_endpoint_t"][::core::mem::align_of::<_z_endpoint_t>() - 8usize];
    ["Offset of field: _z_endpoint_t::_locator"]
        [::core::mem::offset_of!(_z_endpoint_t, _locator) - 0usize];
    ["Offset of field: _z_endpoint_t::_config"]
        [::core::mem::offset_of!(_z_endpoint_t, _config) - 96usize];
};
unsafe extern "C" {
    pub fn _z_endpoint_to_string(e: *const _z_endpoint_t) -> _z_string_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_from_string(ep: *mut _z_endpoint_t, s: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_clear(ep: *mut _z_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_endpoint_free(ep: *mut *mut _z_endpoint_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_tcp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_tcp_socket_t"][::core::mem::size_of::<_z_tcp_socket_t>() - 16usize];
    ["Alignment of _z_tcp_socket_t"][::core::mem::align_of::<_z_tcp_socket_t>() - 8usize];
    ["Offset of field: _z_tcp_socket_t::_sock"]
        [::core::mem::offset_of!(_z_tcp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_tcp_socket_t::_rep"]
        [::core::mem::offset_of!(_z_tcp_socket_t, _rep) - 8usize];
};
unsafe extern "C" {
    pub fn _z_create_endpoint_tcp(
        ep: *mut _z_sys_net_endpoint_t,
        s_address: *const ::core::ffi::c_char,
        s_port: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_endpoint_tcp(ep: *mut _z_sys_net_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_open_tcp(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_tcp(sock: *mut _z_sys_net_socket_t, rep: _z_sys_net_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_tcp(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_read_exact_tcp(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_tcp(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_tcp(sock: _z_sys_net_socket_t, ptr: *const u8, len: usize) -> usize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_udp_socket_t {
    pub _sock: _z_sys_net_socket_t,
    pub _msock: _z_sys_net_socket_t,
    pub _rep: _z_sys_net_endpoint_t,
    pub _lep: _z_sys_net_endpoint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_udp_socket_t"][::core::mem::size_of::<_z_udp_socket_t>() - 24usize];
    ["Alignment of _z_udp_socket_t"][::core::mem::align_of::<_z_udp_socket_t>() - 8usize];
    ["Offset of field: _z_udp_socket_t::_sock"]
        [::core::mem::offset_of!(_z_udp_socket_t, _sock) - 0usize];
    ["Offset of field: _z_udp_socket_t::_msock"]
        [::core::mem::offset_of!(_z_udp_socket_t, _msock) - 4usize];
    ["Offset of field: _z_udp_socket_t::_rep"]
        [::core::mem::offset_of!(_z_udp_socket_t, _rep) - 8usize];
    ["Offset of field: _z_udp_socket_t::_lep"]
        [::core::mem::offset_of!(_z_udp_socket_t, _lep) - 16usize];
};
unsafe extern "C" {
    pub fn _z_create_endpoint_udp(
        ep: *mut _z_sys_net_endpoint_t,
        s_address: *const ::core::ffi::c_char,
        s_port: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_endpoint_udp(ep: *mut _z_sys_net_endpoint_t);
}
unsafe extern "C" {
    pub fn _z_open_udp_unicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_udp_unicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_udp_unicast(sock: *mut _z_sys_net_socket_t);
}
unsafe extern "C" {
    pub fn _z_read_exact_udp_unicast(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_udp_unicast(sock: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_udp_unicast(
        sock: _z_sys_net_socket_t,
        ptr: *const u8,
        len: usize,
        rep: _z_sys_net_endpoint_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_open_udp_multicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        lep: *mut _z_sys_net_endpoint_t,
        tout: u32,
        iface: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_udp_multicast(
        sock: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        tout: u32,
        iface: *const ::core::ffi::c_char,
        join: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_close_udp_multicast(
        sockrecv: *mut _z_sys_net_socket_t,
        socksend: *mut _z_sys_net_socket_t,
        rep: _z_sys_net_endpoint_t,
        lep: _z_sys_net_endpoint_t,
    );
}
unsafe extern "C" {
    pub fn _z_read_exact_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *mut u8,
        len: usize,
        lep: _z_sys_net_endpoint_t,
        ep: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_read_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *mut u8,
        len: usize,
        lep: _z_sys_net_endpoint_t,
        ep: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_send_udp_multicast(
        sock: _z_sys_net_socket_t,
        ptr: *const u8,
        len: usize,
        rep: _z_sys_net_endpoint_t,
    ) -> usize;
}
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_UNICAST: _z_link_cap_transport_t = 0;
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_MULTICAST: _z_link_cap_transport_t = 1;
pub const _z_link_cap_transport_t_Z_LINK_CAP_TRANSPORT_RAWETH: _z_link_cap_transport_t = 2;
#[doc = " Link transport capability enum.\n\n Enumerators:\n     Z_LINK_CAP_TRANSPORT_UNICAST: Link has unicast capabilities.\n     Z_LINK_CAP_TRANSPORT_MULTICAST: Link has multicast capabilities."]
pub type _z_link_cap_transport_t = ::core::ffi::c_uint;
pub const _z_link_cap_flow_t_Z_LINK_CAP_FLOW_DATAGRAM: _z_link_cap_flow_t = 0;
pub const _z_link_cap_flow_t_Z_LINK_CAP_FLOW_STREAM: _z_link_cap_flow_t = 1;
#[doc = " Link flow capability enum.\n\n Enumerators:\n     Z_LINK_CAP_FLOW_STREAM: Link use datagrams.\n     Z_LINK_CAP_FLOW_DATAGRAM: Link use byte stream."]
pub type _z_link_cap_flow_t = ::core::ffi::c_uint;
#[doc = " Link capabilities, stored as a register-like object.\n\n Fields:\n     transport: 2 bits, see _z_link_cap_transport_t enum.\n     flow: 1 bit, see _z_link_cap_flow_t enum.\n     reliable: 1 bit, 1 if the link is reliable (network definition)\n     reserved: 4 bits, reserved for future use"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_link_capabilities_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_capabilities_t"][::core::mem::size_of::<_z_link_capabilities_t>() - 1usize];
    ["Alignment of _z_link_capabilities_t"]
        [::core::mem::align_of::<_z_link_capabilities_t>() - 1usize];
};
impl _z_link_capabilities_t {
    #[inline]
    pub fn _transport(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set__transport(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _transport_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                2u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__transport_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _flow(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__flow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flow_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__flow_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _is_reliable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set__is_reliable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _is_reliable_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__is_reliable_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn _reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set__reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _reserved_raw(this: *const Self) -> u8 {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set__reserved_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _transport: u8,
        _flow: u8,
        _is_reliable: u8,
        _reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let _transport: u8 = unsafe { ::core::mem::transmute(_transport) };
            _transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let _flow: u8 = unsafe { ::core::mem::transmute(_flow) };
            _flow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let _is_reliable: u8 = unsafe { ::core::mem::transmute(_is_reliable) };
            _is_reliable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let _reserved: u8 = unsafe { ::core::mem::transmute(_reserved) };
            _reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type _z_f_link_open =
    ::core::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_listen =
    ::core::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t) -> z_result_t>;
pub type _z_f_link_close = ::core::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
pub type _z_f_link_write = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *const u8,
        len: usize,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_write_all = ::core::option::Option<
    unsafe extern "C" fn(self_: *const _z_link_t, ptr: *const u8, len: usize) -> usize,
>;
pub type _z_f_link_read = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
    ) -> usize,
>;
pub type _z_f_link_read_exact = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *const _z_link_t,
        ptr: *mut u8,
        len: usize,
        addr: *mut _z_slice_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize,
>;
pub type _z_f_link_read_socket = ::core::option::Option<
    unsafe extern "C" fn(socket: _z_sys_net_socket_t, ptr: *mut u8, len: usize) -> usize,
>;
pub type _z_f_link_free = ::core::option::Option<unsafe extern "C" fn(self_: *mut _z_link_t)>;
pub const _z_link_type_e__Z_LINK_TYPE_TCP: _z_link_type_e = 0;
pub const _z_link_type_e__Z_LINK_TYPE_UDP: _z_link_type_e = 1;
pub const _z_link_type_e__Z_LINK_TYPE_BT: _z_link_type_e = 2;
pub const _z_link_type_e__Z_LINK_TYPE_SERIAL: _z_link_type_e = 3;
pub const _z_link_type_e__Z_LINK_TYPE_WS: _z_link_type_e = 4;
pub const _z_link_type_e__Z_LINK_TYPE_RAWETH: _z_link_type_e = 5;
pub type _z_link_type_e = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_link_t {
    pub _endpoint: _z_endpoint_t,
    pub _type: ::core::ffi::c_int,
    pub _socket: _z_link_t__bindgen_ty_1,
    pub _open_f: _z_f_link_open,
    pub _listen_f: _z_f_link_listen,
    pub _close_f: _z_f_link_close,
    pub _write_f: _z_f_link_write,
    pub _write_all_f: _z_f_link_write_all,
    pub _read_f: _z_f_link_read,
    pub _read_exact_f: _z_f_link_read_exact,
    pub _read_socket_f: _z_f_link_read_socket,
    pub _free_f: _z_f_link_free,
    pub _mtu: u16,
    pub _cap: _z_link_capabilities_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_link_t__bindgen_ty_1 {
    pub _tcp: _z_tcp_socket_t,
    pub _udp: _z_udp_socket_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_link_t__bindgen_ty_1>() - 24usize];
    ["Alignment of _z_link_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_link_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_tcp"]
        [::core::mem::offset_of!(_z_link_t__bindgen_ty_1, _tcp) - 0usize];
    ["Offset of field: _z_link_t__bindgen_ty_1::_udp"]
        [::core::mem::offset_of!(_z_link_t__bindgen_ty_1, _udp) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_link_t"][::core::mem::size_of::<_z_link_t>() - 240usize];
    ["Alignment of _z_link_t"][::core::mem::align_of::<_z_link_t>() - 8usize];
    ["Offset of field: _z_link_t::_endpoint"]
        [::core::mem::offset_of!(_z_link_t, _endpoint) - 0usize];
    ["Offset of field: _z_link_t::_type"][::core::mem::offset_of!(_z_link_t, _type) - 128usize];
    ["Offset of field: _z_link_t::_socket"][::core::mem::offset_of!(_z_link_t, _socket) - 136usize];
    ["Offset of field: _z_link_t::_open_f"][::core::mem::offset_of!(_z_link_t, _open_f) - 160usize];
    ["Offset of field: _z_link_t::_listen_f"]
        [::core::mem::offset_of!(_z_link_t, _listen_f) - 168usize];
    ["Offset of field: _z_link_t::_close_f"]
        [::core::mem::offset_of!(_z_link_t, _close_f) - 176usize];
    ["Offset of field: _z_link_t::_write_f"]
        [::core::mem::offset_of!(_z_link_t, _write_f) - 184usize];
    ["Offset of field: _z_link_t::_write_all_f"]
        [::core::mem::offset_of!(_z_link_t, _write_all_f) - 192usize];
    ["Offset of field: _z_link_t::_read_f"][::core::mem::offset_of!(_z_link_t, _read_f) - 200usize];
    ["Offset of field: _z_link_t::_read_exact_f"]
        [::core::mem::offset_of!(_z_link_t, _read_exact_f) - 208usize];
    ["Offset of field: _z_link_t::_read_socket_f"]
        [::core::mem::offset_of!(_z_link_t, _read_socket_f) - 216usize];
    ["Offset of field: _z_link_t::_free_f"][::core::mem::offset_of!(_z_link_t, _free_f) - 224usize];
    ["Offset of field: _z_link_t::_mtu"][::core::mem::offset_of!(_z_link_t, _mtu) - 232usize];
    ["Offset of field: _z_link_t::_cap"][::core::mem::offset_of!(_z_link_t, _cap) - 234usize];
};
unsafe extern "C" {
    pub fn _z_link_clear(zl: *mut _z_link_t);
}
unsafe extern "C" {
    pub fn _z_link_free(zl: *mut *mut _z_link_t);
}
unsafe extern "C" {
    pub fn _z_open_socket(
        locator: *const _z_string_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_open_link(zl: *mut _z_link_t, locator: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_listen_link(zl: *mut _z_link_t, locator: *const _z_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_link_send_wbuf(
        zl: *const _z_link_t,
        wbf: *const _z_wbuf_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_link_recv_zbuf(
        zl: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        addr: *mut _z_slice_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_recv_exact_zbuf(
        zl: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        len: usize,
        addr: *mut _z_slice_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_socket_recv_zbuf(
        link: *const _z_link_t,
        zbf: *mut _z_zbuf_t,
        socket: _z_sys_net_socket_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn _z_link_get_socket(link: *const _z_link_t) -> *const _z_sys_net_socket_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_tcp_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_peer_tcp(
        endpoint: *mut _z_endpoint_t,
        socket: *mut _z_sys_net_socket_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_tcp(zl: *mut _z_link_t, ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_udp_unicast_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_udp_unicast(zl: *mut _z_link_t, ep: _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_endpoint_udp_multicast_valid(ep: *mut _z_endpoint_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_link_udp_multicast(zl: *mut _z_link_t, ep: _z_endpoint_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_s_msg_scout_t {
    pub _zid: _z_id_t,
    pub _what: z_what_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_s_msg_scout_t"][::core::mem::size_of::<_z_s_msg_scout_t>() - 24usize];
    ["Alignment of _z_s_msg_scout_t"][::core::mem::align_of::<_z_s_msg_scout_t>() - 4usize];
    ["Offset of field: _z_s_msg_scout_t::_zid"]
        [::core::mem::offset_of!(_z_s_msg_scout_t, _zid) - 0usize];
    ["Offset of field: _z_s_msg_scout_t::_what"]
        [::core::mem::offset_of!(_z_s_msg_scout_t, _what) - 16usize];
    ["Offset of field: _z_s_msg_scout_t::_version"]
        [::core::mem::offset_of!(_z_s_msg_scout_t, _version) - 20usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_scout_clear(msg: *mut _z_s_msg_scout_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_s_msg_hello_t {
    pub _zid: _z_id_t,
    pub _locators: _z_locator_array_t,
    pub _whatami: z_whatami_t,
    pub _version: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_s_msg_hello_t"][::core::mem::size_of::<_z_s_msg_hello_t>() - 40usize];
    ["Alignment of _z_s_msg_hello_t"][::core::mem::align_of::<_z_s_msg_hello_t>() - 8usize];
    ["Offset of field: _z_s_msg_hello_t::_zid"]
        [::core::mem::offset_of!(_z_s_msg_hello_t, _zid) - 0usize];
    ["Offset of field: _z_s_msg_hello_t::_locators"]
        [::core::mem::offset_of!(_z_s_msg_hello_t, _locators) - 16usize];
    ["Offset of field: _z_s_msg_hello_t::_whatami"]
        [::core::mem::offset_of!(_z_s_msg_hello_t, _whatami) - 32usize];
    ["Offset of field: _z_s_msg_hello_t::_version"]
        [::core::mem::offset_of!(_z_s_msg_hello_t, _version) - 36usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_hello_clear(msg: *mut _z_s_msg_hello_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_coundit_sn_t {
    pub _reliable: _z_zint_t,
    pub _best_effort: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_coundit_sn_t"][::core::mem::size_of::<_z_coundit_sn_t>() - 16usize];
    ["Alignment of _z_coundit_sn_t"][::core::mem::align_of::<_z_coundit_sn_t>() - 8usize];
    ["Offset of field: _z_coundit_sn_t::_reliable"]
        [::core::mem::offset_of!(_z_coundit_sn_t, _reliable) - 0usize];
    ["Offset of field: _z_coundit_sn_t::_best_effort"]
        [::core::mem::offset_of!(_z_coundit_sn_t, _best_effort) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_conduit_sn_list_t {
    pub _val: _z_conduit_sn_list_t__bindgen_ty_1,
    pub _is_qos: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_conduit_sn_list_t__bindgen_ty_1 {
    pub _plain: _z_coundit_sn_t,
    pub _qos: [_z_coundit_sn_t; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 128usize];
    ["Alignment of _z_conduit_sn_list_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_conduit_sn_list_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_plain"]
        [::core::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _plain) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t__bindgen_ty_1::_qos"]
        [::core::mem::offset_of!(_z_conduit_sn_list_t__bindgen_ty_1, _qos) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_conduit_sn_list_t"][::core::mem::size_of::<_z_conduit_sn_list_t>() - 136usize];
    ["Alignment of _z_conduit_sn_list_t"][::core::mem::align_of::<_z_conduit_sn_list_t>() - 8usize];
    ["Offset of field: _z_conduit_sn_list_t::_val"]
        [::core::mem::offset_of!(_z_conduit_sn_list_t, _val) - 0usize];
    ["Offset of field: _z_conduit_sn_list_t::_is_qos"]
        [::core::mem::offset_of!(_z_conduit_sn_list_t, _is_qos) - 128usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_t_msg_join_t {
    pub _zid: _z_id_t,
    pub _lease: _z_zint_t,
    pub _next_sn: _z_conduit_sn_list_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_join_t"][::core::mem::size_of::<_z_t_msg_join_t>() - 176usize];
    ["Alignment of _z_t_msg_join_t"][::core::mem::align_of::<_z_t_msg_join_t>() - 8usize];
    ["Offset of field: _z_t_msg_join_t::_zid"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_join_t::_lease"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _lease) - 16usize];
    ["Offset of field: _z_t_msg_join_t::_next_sn"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _next_sn) - 24usize];
    ["Offset of field: _z_t_msg_join_t::_batch_size"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _batch_size) - 160usize];
    ["Offset of field: _z_t_msg_join_t::_whatami"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _whatami) - 164usize];
    ["Offset of field: _z_t_msg_join_t::_req_id_res"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _req_id_res) - 168usize];
    ["Offset of field: _z_t_msg_join_t::_seq_num_res"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _seq_num_res) - 169usize];
    ["Offset of field: _z_t_msg_join_t::_version"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _version) - 170usize];
    ["Offset of field: _z_t_msg_join_t::_patch"]
        [::core::mem::offset_of!(_z_t_msg_join_t, _patch) - 171usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_join_clear(msg: *mut _z_t_msg_join_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_init_t {
    pub _zid: _z_id_t,
    pub _cookie: _z_slice_t,
    pub _batch_size: u16,
    pub _whatami: z_whatami_t,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _version: u8,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_init_t"][::core::mem::size_of::<_z_t_msg_init_t>() - 64usize];
    ["Alignment of _z_t_msg_init_t"][::core::mem::align_of::<_z_t_msg_init_t>() - 8usize];
    ["Offset of field: _z_t_msg_init_t::_zid"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _zid) - 0usize];
    ["Offset of field: _z_t_msg_init_t::_cookie"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _cookie) - 16usize];
    ["Offset of field: _z_t_msg_init_t::_batch_size"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _batch_size) - 48usize];
    ["Offset of field: _z_t_msg_init_t::_whatami"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _whatami) - 52usize];
    ["Offset of field: _z_t_msg_init_t::_req_id_res"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _req_id_res) - 56usize];
    ["Offset of field: _z_t_msg_init_t::_seq_num_res"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _seq_num_res) - 57usize];
    ["Offset of field: _z_t_msg_init_t::_version"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _version) - 58usize];
    ["Offset of field: _z_t_msg_init_t::_patch"]
        [::core::mem::offset_of!(_z_t_msg_init_t, _patch) - 59usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_init_clear(msg: *mut _z_t_msg_init_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_open_t {
    pub _lease: _z_zint_t,
    pub _initial_sn: _z_zint_t,
    pub _cookie: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_open_t"][::core::mem::size_of::<_z_t_msg_open_t>() - 48usize];
    ["Alignment of _z_t_msg_open_t"][::core::mem::align_of::<_z_t_msg_open_t>() - 8usize];
    ["Offset of field: _z_t_msg_open_t::_lease"]
        [::core::mem::offset_of!(_z_t_msg_open_t, _lease) - 0usize];
    ["Offset of field: _z_t_msg_open_t::_initial_sn"]
        [::core::mem::offset_of!(_z_t_msg_open_t, _initial_sn) - 8usize];
    ["Offset of field: _z_t_msg_open_t::_cookie"]
        [::core::mem::offset_of!(_z_t_msg_open_t, _cookie) - 16usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_open_clear(msg: *mut _z_t_msg_open_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_close_t {
    pub _reason: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_close_t"][::core::mem::size_of::<_z_t_msg_close_t>() - 1usize];
    ["Alignment of _z_t_msg_close_t"][::core::mem::align_of::<_z_t_msg_close_t>() - 1usize];
    ["Offset of field: _z_t_msg_close_t::_reason"]
        [::core::mem::offset_of!(_z_t_msg_close_t, _reason) - 0usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_close_clear(msg: *mut _z_t_msg_close_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_keep_alive_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_keep_alive_t"][::core::mem::size_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Alignment of _z_t_msg_keep_alive_t"]
        [::core::mem::align_of::<_z_t_msg_keep_alive_t>() - 1usize];
    ["Offset of field: _z_t_msg_keep_alive_t::__dummy"]
        [::core::mem::offset_of!(_z_t_msg_keep_alive_t, __dummy) - 0usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_keep_alive_clear(msg: *mut _z_t_msg_keep_alive_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_frame_t {
    pub _payload: *mut _z_zbuf_t,
    pub _sn: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_frame_t"][::core::mem::size_of::<_z_t_msg_frame_t>() - 16usize];
    ["Alignment of _z_t_msg_frame_t"][::core::mem::align_of::<_z_t_msg_frame_t>() - 8usize];
    ["Offset of field: _z_t_msg_frame_t::_payload"]
        [::core::mem::offset_of!(_z_t_msg_frame_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_frame_t::_sn"]
        [::core::mem::offset_of!(_z_t_msg_frame_t, _sn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_frame_clear(msg: *mut _z_t_msg_frame_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_t_msg_fragment_t {
    pub _payload: _z_slice_t,
    pub _sn: _z_zint_t,
    pub first: bool,
    pub drop: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_t_msg_fragment_t"][::core::mem::size_of::<_z_t_msg_fragment_t>() - 48usize];
    ["Alignment of _z_t_msg_fragment_t"][::core::mem::align_of::<_z_t_msg_fragment_t>() - 8usize];
    ["Offset of field: _z_t_msg_fragment_t::_payload"]
        [::core::mem::offset_of!(_z_t_msg_fragment_t, _payload) - 0usize];
    ["Offset of field: _z_t_msg_fragment_t::_sn"]
        [::core::mem::offset_of!(_z_t_msg_fragment_t, _sn) - 32usize];
    ["Offset of field: _z_t_msg_fragment_t::first"]
        [::core::mem::offset_of!(_z_t_msg_fragment_t, first) - 40usize];
    ["Offset of field: _z_t_msg_fragment_t::drop"]
        [::core::mem::offset_of!(_z_t_msg_fragment_t, drop) - 41usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_fragment_clear(msg: *mut _z_t_msg_fragment_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_body_t {
    pub _join: _z_t_msg_join_t,
    pub _init: _z_t_msg_init_t,
    pub _open: _z_t_msg_open_t,
    pub _close: _z_t_msg_close_t,
    pub _keep_alive: _z_t_msg_keep_alive_t,
    pub _frame: _z_t_msg_frame_t,
    pub _fragment: _z_t_msg_fragment_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_body_t"][::core::mem::size_of::<_z_transport_body_t>() - 176usize];
    ["Alignment of _z_transport_body_t"][::core::mem::align_of::<_z_transport_body_t>() - 8usize];
    ["Offset of field: _z_transport_body_t::_join"]
        [::core::mem::offset_of!(_z_transport_body_t, _join) - 0usize];
    ["Offset of field: _z_transport_body_t::_init"]
        [::core::mem::offset_of!(_z_transport_body_t, _init) - 0usize];
    ["Offset of field: _z_transport_body_t::_open"]
        [::core::mem::offset_of!(_z_transport_body_t, _open) - 0usize];
    ["Offset of field: _z_transport_body_t::_close"]
        [::core::mem::offset_of!(_z_transport_body_t, _close) - 0usize];
    ["Offset of field: _z_transport_body_t::_keep_alive"]
        [::core::mem::offset_of!(_z_transport_body_t, _keep_alive) - 0usize];
    ["Offset of field: _z_transport_body_t::_frame"]
        [::core::mem::offset_of!(_z_transport_body_t, _frame) - 0usize];
    ["Offset of field: _z_transport_body_t::_fragment"]
        [::core::mem::offset_of!(_z_transport_body_t, _fragment) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_message_t {
    pub _body: _z_transport_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_message_t"][::core::mem::size_of::<_z_transport_message_t>() - 184usize];
    ["Alignment of _z_transport_message_t"]
        [::core::mem::align_of::<_z_transport_message_t>() - 8usize];
    ["Offset of field: _z_transport_message_t::_body"]
        [::core::mem::offset_of!(_z_transport_message_t, _body) - 0usize];
    ["Offset of field: _z_transport_message_t::_header"]
        [::core::mem::offset_of!(_z_transport_message_t, _header) - 176usize];
};
unsafe extern "C" {
    pub fn _z_t_msg_clear(msg: *mut _z_transport_message_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_get_reliability(msg: *mut _z_transport_message_t) -> z_reliability_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_join(
        whatami: z_whatami_t,
        lease: _z_zint_t,
        zid: _z_id_t,
        next_sn: _z_conduit_sn_list_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_init_syn(whatami: z_whatami_t, zid: _z_id_t) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_init_ack(
        whatami: z_whatami_t,
        zid: _z_id_t,
        cookie: _z_slice_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_open_syn(
        lease: _z_zint_t,
        initial_sn: _z_zint_t,
        cookie: _z_slice_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_open_ack(
        lease: _z_zint_t,
        initial_sn: _z_zint_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_close(reason: u8, link_only: bool) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_keep_alive() -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_frame(
        sn: _z_zint_t,
        payload: *mut _z_zbuf_t,
        reliability: z_reliability_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_frame_header(
        sn: _z_zint_t,
        reliability: z_reliability_t,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_fragment_header(
        sn: _z_zint_t,
        reliability: z_reliability_t,
        is_last: bool,
        first: bool,
        drop: bool,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_make_fragment(
        sn: _z_zint_t,
        messages: _z_slice_t,
        reliability: z_reliability_t,
        is_last: bool,
        first: bool,
        drop: bool,
    ) -> _z_transport_message_t;
}
unsafe extern "C" {
    pub fn _z_t_msg_copy(clone: *mut _z_transport_message_t, msg: *mut _z_transport_message_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_join(clone: *mut _z_t_msg_join_t, msg: *mut _z_t_msg_join_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_init(clone: *mut _z_t_msg_init_t, msg: *mut _z_t_msg_init_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_open(clone: *mut _z_t_msg_open_t, msg: *mut _z_t_msg_open_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_close(clone: *mut _z_t_msg_close_t, msg: *mut _z_t_msg_close_t);
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_keep_alive(
        clone: *mut _z_t_msg_keep_alive_t,
        msg: *mut _z_t_msg_keep_alive_t,
    );
}
unsafe extern "C" {
    pub fn _z_t_msg_copy_frame(clone: *mut _z_t_msg_frame_t, msg: *mut _z_t_msg_frame_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_scouting_body_t {
    pub _scout: _z_s_msg_scout_t,
    pub _hello: _z_s_msg_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_scouting_body_t"][::core::mem::size_of::<_z_scouting_body_t>() - 40usize];
    ["Alignment of _z_scouting_body_t"][::core::mem::align_of::<_z_scouting_body_t>() - 8usize];
    ["Offset of field: _z_scouting_body_t::_scout"]
        [::core::mem::offset_of!(_z_scouting_body_t, _scout) - 0usize];
    ["Offset of field: _z_scouting_body_t::_hello"]
        [::core::mem::offset_of!(_z_scouting_body_t, _hello) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_scouting_message_t {
    pub _body: _z_scouting_body_t,
    pub _header: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_scouting_message_t"][::core::mem::size_of::<_z_scouting_message_t>() - 48usize];
    ["Alignment of _z_scouting_message_t"]
        [::core::mem::align_of::<_z_scouting_message_t>() - 8usize];
    ["Offset of field: _z_scouting_message_t::_body"]
        [::core::mem::offset_of!(_z_scouting_message_t, _body) - 0usize];
    ["Offset of field: _z_scouting_message_t::_header"]
        [::core::mem::offset_of!(_z_scouting_message_t, _header) - 40usize];
};
unsafe extern "C" {
    pub fn _z_s_msg_clear(msg: *mut _z_scouting_message_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_make_scout(what: z_what_t, zid: _z_id_t) -> _z_scouting_message_t;
}
unsafe extern "C" {
    pub fn _z_s_msg_make_hello(
        whatami: z_whatami_t,
        zid: _z_id_t,
        locators: _z_locator_array_t,
    ) -> _z_scouting_message_t;
}
unsafe extern "C" {
    pub fn _z_s_msg_copy(clone: *mut _z_scouting_message_t, msg: *mut _z_scouting_message_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_copy_scout(clone: *mut _z_s_msg_scout_t, msg: *mut _z_s_msg_scout_t);
}
unsafe extern "C" {
    pub fn _z_s_msg_copy_hello(clone: *mut _z_s_msg_hello_t, msg: *mut _z_s_msg_hello_t);
}
pub const _z_dbuf_state_e__Z_DBUF_STATE_NULL: _z_dbuf_state_e = 0;
pub const _z_dbuf_state_e__Z_DBUF_STATE_INIT: _z_dbuf_state_e = 1;
pub const _z_dbuf_state_e__Z_DBUF_STATE_OVERFLOW: _z_dbuf_state_e = 2;
pub type _z_dbuf_state_e = ::core::ffi::c_uint;
pub const _z_batching_state_e__Z_BATCHING_IDLE: _z_batching_state_e = 0;
pub const _z_batching_state_e__Z_BATCHING_ACTIVE: _z_batching_state_e = 1;
pub type _z_batching_state_e = ::core::ffi::c_uint;
pub type _z_resource_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_peer_common_t {
    pub _remote_zid: _z_id_t,
    pub _received: bool,
    pub _remote_resources: *mut _z_resource_slist_t,
    pub _state_reliable: u8,
    pub _state_best_effort: u8,
    pub _dbuf_reliable: _z_wbuf_t,
    pub _dbuf_best_effort: _z_wbuf_t,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_common_t"]
        [::core::mem::size_of::<_z_transport_peer_common_t>() - 160usize];
    ["Alignment of _z_transport_peer_common_t"]
        [::core::mem::align_of::<_z_transport_peer_common_t>() - 8usize];
    ["Offset of field: _z_transport_peer_common_t::_remote_zid"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _remote_zid) - 0usize];
    ["Offset of field: _z_transport_peer_common_t::_received"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _received) - 16usize];
    ["Offset of field: _z_transport_peer_common_t::_remote_resources"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _remote_resources) - 24usize];
    ["Offset of field: _z_transport_peer_common_t::_state_reliable"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _state_reliable) - 32usize];
    ["Offset of field: _z_transport_peer_common_t::_state_best_effort"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _state_best_effort) - 33usize];
    ["Offset of field: _z_transport_peer_common_t::_dbuf_reliable"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _dbuf_reliable) - 40usize];
    ["Offset of field: _z_transport_peer_common_t::_dbuf_best_effort"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _dbuf_best_effort) - 96usize];
    ["Offset of field: _z_transport_peer_common_t::_patch"]
        [::core::mem::offset_of!(_z_transport_peer_common_t, _patch) - 152usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_common_clear(src: *mut _z_transport_peer_common_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_common_copy(
        dst: *mut _z_transport_peer_common_t,
        src: *const _z_transport_peer_common_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_common_eq(
        left: *const _z_transport_peer_common_t,
        right: *const _z_transport_peer_common_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_peer_multicast_t {
    pub common: _z_transport_peer_common_t,
    pub _remote_addr: _z_slice_t,
    pub _sn_rx_sns: _z_conduit_sn_list_t,
    pub _sn_res: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _next_lease: _z_zint_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_multicast_t"]
        [::core::mem::size_of::<_z_transport_peer_multicast_t>() - 352usize];
    ["Alignment of _z_transport_peer_multicast_t"]
        [::core::mem::align_of::<_z_transport_peer_multicast_t>() - 8usize];
    ["Offset of field: _z_transport_peer_multicast_t::common"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, common) - 0usize];
    ["Offset of field: _z_transport_peer_multicast_t::_remote_addr"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, _remote_addr) - 160usize];
    ["Offset of field: _z_transport_peer_multicast_t::_sn_rx_sns"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, _sn_rx_sns) - 192usize];
    ["Offset of field: _z_transport_peer_multicast_t::_sn_res"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, _sn_res) - 328usize];
    ["Offset of field: _z_transport_peer_multicast_t::_lease"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, _lease) - 336usize];
    ["Offset of field: _z_transport_peer_multicast_t::_next_lease"]
        [::core::mem::offset_of!(_z_transport_peer_multicast_t, _next_lease) - 344usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_size(src: *const _z_transport_peer_multicast_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_clear(src: *mut _z_transport_peer_multicast_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_copy(
        dst: *mut _z_transport_peer_multicast_t,
        src: *const _z_transport_peer_multicast_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_multicast_eq(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> bool;
}
pub type _z_transport_peer_multicast_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> bool,
>;
pub type _z_transport_peer_multicast_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_multicast_t,
        right: *const _z_transport_peer_multicast_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_transport_peer_multicast_slist_t = _z_slist_t;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_INACTIVE: _z_unicast_peer_flow_state_e = 0;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_PENDING_SIZE: _z_unicast_peer_flow_state_e = 1;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_PENDING_DATA: _z_unicast_peer_flow_state_e = 2;
pub const _z_unicast_peer_flow_state_e__Z_FLOW_STATE_READY: _z_unicast_peer_flow_state_e = 3;
pub type _z_unicast_peer_flow_state_e = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_peer_unicast_t {
    pub common: _z_transport_peer_common_t,
    pub _socket: _z_sys_net_socket_t,
    pub _sn_rx_reliable: _z_zint_t,
    pub _sn_rx_best_effort: _z_zint_t,
    pub _pending: bool,
    pub flow_state: u8,
    pub flow_curr_size: u16,
    pub flow_buff: _z_zbuf_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_peer_unicast_t"]
        [::core::mem::size_of::<_z_transport_peer_unicast_t>() - 240usize];
    ["Alignment of _z_transport_peer_unicast_t"]
        [::core::mem::align_of::<_z_transport_peer_unicast_t>() - 8usize];
    ["Offset of field: _z_transport_peer_unicast_t::common"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, common) - 0usize];
    ["Offset of field: _z_transport_peer_unicast_t::_socket"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, _socket) - 160usize];
    ["Offset of field: _z_transport_peer_unicast_t::_sn_rx_reliable"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, _sn_rx_reliable) - 168usize];
    ["Offset of field: _z_transport_peer_unicast_t::_sn_rx_best_effort"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, _sn_rx_best_effort) - 176usize];
    ["Offset of field: _z_transport_peer_unicast_t::_pending"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, _pending) - 184usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_state"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, flow_state) - 185usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_curr_size"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, flow_curr_size) - 186usize];
    ["Offset of field: _z_transport_peer_unicast_t::flow_buff"]
        [::core::mem::offset_of!(_z_transport_peer_unicast_t, flow_buff) - 192usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_clear(src: *mut _z_transport_peer_unicast_t);
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_copy(
        dst: *mut _z_transport_peer_unicast_t,
        src: *const _z_transport_peer_unicast_t,
    );
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_size(src: *const _z_transport_peer_unicast_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_eq(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> bool;
}
pub type _z_transport_peer_unicast_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> bool,
>;
pub type _z_transport_peer_unicast_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_transport_peer_unicast_t,
        right: *const _z_transport_peer_unicast_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_transport_peer_unicast_slist_t = _z_slist_t;
pub type _z_session_rc_ref_t = _z_session_rc_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_common_t {
    pub _session: *mut _z_session_rc_ref_t,
    pub _link: _z_link_t,
    pub _wbuf: _z_wbuf_t,
    pub _zbuf: _z_zbuf_t,
    pub _sn_res: _z_zint_t,
    pub _sn_tx_reliable: _z_zint_t,
    pub _sn_tx_best_effort: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _transmitted: bool,
    pub _mutex_rx: _z_mutex_t,
    pub _mutex_tx: _z_mutex_t,
    pub _mutex_peer: _z_mutex_rec_t,
    pub _read_task: *mut _z_task_t,
    pub _lease_task: *mut _z_task_t,
    pub _accept_task_running: *mut bool,
    pub _read_task_running: bool,
    pub _lease_task_running: bool,
    pub _batch_state: u8,
    pub _batch_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_common_t"][::core::mem::size_of::<_z_transport_common_t>() - 624usize];
    ["Alignment of _z_transport_common_t"]
        [::core::mem::align_of::<_z_transport_common_t>() - 8usize];
    ["Offset of field: _z_transport_common_t::_session"]
        [::core::mem::offset_of!(_z_transport_common_t, _session) - 0usize];
    ["Offset of field: _z_transport_common_t::_link"]
        [::core::mem::offset_of!(_z_transport_common_t, _link) - 8usize];
    ["Offset of field: _z_transport_common_t::_wbuf"]
        [::core::mem::offset_of!(_z_transport_common_t, _wbuf) - 248usize];
    ["Offset of field: _z_transport_common_t::_zbuf"]
        [::core::mem::offset_of!(_z_transport_common_t, _zbuf) - 304usize];
    ["Offset of field: _z_transport_common_t::_sn_res"]
        [::core::mem::offset_of!(_z_transport_common_t, _sn_res) - 352usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_reliable"]
        [::core::mem::offset_of!(_z_transport_common_t, _sn_tx_reliable) - 360usize];
    ["Offset of field: _z_transport_common_t::_sn_tx_best_effort"]
        [::core::mem::offset_of!(_z_transport_common_t, _sn_tx_best_effort) - 368usize];
    ["Offset of field: _z_transport_common_t::_lease"]
        [::core::mem::offset_of!(_z_transport_common_t, _lease) - 376usize];
    ["Offset of field: _z_transport_common_t::_transmitted"]
        [::core::mem::offset_of!(_z_transport_common_t, _transmitted) - 384usize];
    ["Offset of field: _z_transport_common_t::_mutex_rx"]
        [::core::mem::offset_of!(_z_transport_common_t, _mutex_rx) - 392usize];
    ["Offset of field: _z_transport_common_t::_mutex_tx"]
        [::core::mem::offset_of!(_z_transport_common_t, _mutex_tx) - 456usize];
    ["Offset of field: _z_transport_common_t::_mutex_peer"]
        [::core::mem::offset_of!(_z_transport_common_t, _mutex_peer) - 520usize];
    ["Offset of field: _z_transport_common_t::_read_task"]
        [::core::mem::offset_of!(_z_transport_common_t, _read_task) - 584usize];
    ["Offset of field: _z_transport_common_t::_lease_task"]
        [::core::mem::offset_of!(_z_transport_common_t, _lease_task) - 592usize];
    ["Offset of field: _z_transport_common_t::_accept_task_running"]
        [::core::mem::offset_of!(_z_transport_common_t, _accept_task_running) - 600usize];
    ["Offset of field: _z_transport_common_t::_read_task_running"]
        [::core::mem::offset_of!(_z_transport_common_t, _read_task_running) - 608usize];
    ["Offset of field: _z_transport_common_t::_lease_task_running"]
        [::core::mem::offset_of!(_z_transport_common_t, _lease_task_running) - 609usize];
    ["Offset of field: _z_transport_common_t::_batch_state"]
        [::core::mem::offset_of!(_z_transport_common_t, _batch_state) - 610usize];
    ["Offset of field: _z_transport_common_t::_batch_count"]
        [::core::mem::offset_of!(_z_transport_common_t, _batch_count) - 616usize];
};
pub type _zp_f_send_tmsg = ::core::option::Option<
    unsafe extern "C" fn(
        self_: *mut _z_transport_common_t,
        t_msg: *const _z_transport_message_t,
    ) -> z_result_t,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_unicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_unicast_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_unicast_t"][::core::mem::size_of::<_z_transport_unicast_t>() - 632usize];
    ["Alignment of _z_transport_unicast_t"]
        [::core::mem::align_of::<_z_transport_unicast_t>() - 8usize];
    ["Offset of field: _z_transport_unicast_t::_common"]
        [::core::mem::offset_of!(_z_transport_unicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_unicast_t::_peers"]
        [::core::mem::offset_of!(_z_transport_unicast_t, _peers) - 624usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_multicast_t {
    pub _common: _z_transport_common_t,
    pub _peers: *mut _z_transport_peer_multicast_slist_t,
    pub _send_f: _zp_f_send_tmsg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_multicast_t"]
        [::core::mem::size_of::<_z_transport_multicast_t>() - 640usize];
    ["Alignment of _z_transport_multicast_t"]
        [::core::mem::align_of::<_z_transport_multicast_t>() - 8usize];
    ["Offset of field: _z_transport_multicast_t::_common"]
        [::core::mem::offset_of!(_z_transport_multicast_t, _common) - 0usize];
    ["Offset of field: _z_transport_multicast_t::_peers"]
        [::core::mem::offset_of!(_z_transport_multicast_t, _peers) - 624usize];
    ["Offset of field: _z_transport_multicast_t::_send_f"]
        [::core::mem::offset_of!(_z_transport_multicast_t, _send_f) - 632usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_t {
    pub _transport: _z_transport_t__bindgen_ty_1,
    pub _type: _z_transport_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_transport_t__bindgen_ty_1 {
    pub _unicast: _z_transport_unicast_t,
    pub _multicast: _z_transport_multicast_t,
    pub _raweth: _z_transport_multicast_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_transport_t__bindgen_ty_1>() - 640usize];
    ["Alignment of _z_transport_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_transport_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_unicast"]
        [::core::mem::offset_of!(_z_transport_t__bindgen_ty_1, _unicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_multicast"]
        [::core::mem::offset_of!(_z_transport_t__bindgen_ty_1, _multicast) - 0usize];
    ["Offset of field: _z_transport_t__bindgen_ty_1::_raweth"]
        [::core::mem::offset_of!(_z_transport_t__bindgen_ty_1, _raweth) - 0usize];
};
pub const _z_transport_t__Z_TRANSPORT_UNICAST_TYPE: _z_transport_t__bindgen_ty_2 = 0;
pub const _z_transport_t__Z_TRANSPORT_MULTICAST_TYPE: _z_transport_t__bindgen_ty_2 = 1;
pub const _z_transport_t__Z_TRANSPORT_RAWETH_TYPE: _z_transport_t__bindgen_ty_2 = 2;
pub const _z_transport_t__Z_TRANSPORT_NONE: _z_transport_t__bindgen_ty_2 = 3;
pub type _z_transport_t__bindgen_ty_2 = ::core::ffi::c_uint;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_t"][::core::mem::size_of::<_z_transport_t>() - 648usize];
    ["Alignment of _z_transport_t"][::core::mem::align_of::<_z_transport_t>() - 8usize];
    ["Offset of field: _z_transport_t::_transport"]
        [::core::mem::offset_of!(_z_transport_t, _transport) - 0usize];
    ["Offset of field: _z_transport_t::_type"]
        [::core::mem::offset_of!(_z_transport_t, _type) - 640usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_transport_unicast_establish_param_t {
    pub _remote_zid: _z_id_t,
    pub _batch_size: u16,
    pub _initial_sn_rx: _z_zint_t,
    pub _initial_sn_tx: _z_zint_t,
    pub _lease: _z_zint_t,
    pub _whatami: z_whatami_t,
    pub _key_id_res: u8,
    pub _req_id_res: u8,
    pub _seq_num_res: u8,
    pub _is_qos: bool,
    pub _patch: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_unicast_establish_param_t"]
        [::core::mem::size_of::<_z_transport_unicast_establish_param_t>() - 64usize];
    ["Alignment of _z_transport_unicast_establish_param_t"]
        [::core::mem::align_of::<_z_transport_unicast_establish_param_t>() - 8usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_remote_zid"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _remote_zid) - 0usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_batch_size"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _batch_size) - 16usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_initial_sn_rx"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _initial_sn_rx) - 24usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_initial_sn_tx"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _initial_sn_tx) - 32usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_lease"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _lease) - 40usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_whatami"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _whatami) - 48usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_key_id_res"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _key_id_res) - 52usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_req_id_res"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _req_id_res) - 53usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_seq_num_res"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _seq_num_res) - 54usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_is_qos"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _is_qos) - 55usize];
    ["Offset of field: _z_transport_unicast_establish_param_t::_patch"]
        [::core::mem::offset_of!(_z_transport_unicast_establish_param_t, _patch) - 56usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_transport_multicast_establish_param_t {
    pub _initial_sn_tx: _z_conduit_sn_list_t,
    pub _seq_num_res: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_transport_multicast_establish_param_t"]
        [::core::mem::size_of::<_z_transport_multicast_establish_param_t>() - 144usize];
    ["Alignment of _z_transport_multicast_establish_param_t"]
        [::core::mem::align_of::<_z_transport_multicast_establish_param_t>() - 8usize];
    ["Offset of field: _z_transport_multicast_establish_param_t::_initial_sn_tx"][::core::mem::offset_of!(
        _z_transport_multicast_establish_param_t,
        _initial_sn_tx
    ) - 0usize];
    ["Offset of field: _z_transport_multicast_establish_param_t::_seq_num_res"][::core::mem::offset_of!(
        _z_transport_multicast_establish_param_t,
        _seq_num_res
    ) - 136usize];
};
unsafe extern "C" {
    pub fn _z_transport_peer_unicast_add(
        ztu: *mut _z_transport_unicast_t,
        param: *mut _z_transport_unicast_establish_param_t,
        socket: _z_sys_net_socket_t,
        output_peer: *mut *mut _z_transport_peer_unicast_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_transport_get_common(zt: *mut _z_transport_t) -> *mut _z_transport_common_t;
}
unsafe extern "C" {
    pub fn _z_transport_close(zt: *mut _z_transport_t, reason: u8) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_transport_clear(zt: *mut _z_transport_t);
}
unsafe extern "C" {
    pub fn _z_transport_free(zt: *mut *mut _z_transport_t);
}
unsafe extern "C" {
    pub fn _z_transport_start_batching(zt: *mut _z_transport_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_transport_stop_batching(zt: *mut _z_transport_t);
}
pub const _z_peer_op_e__Z_PEER_OP_OPEN: _z_peer_op_e = 0;
pub const _z_peer_op_e__Z_PEER_OP_LISTEN: _z_peer_op_e = 1;
pub type _z_peer_op_e = ::core::ffi::c_uint;
unsafe extern "C" {
    pub fn _z_new_transport(
        zt: *mut _z_transport_t,
        bs: *const _z_id_t,
        locator: *const _z_string_t,
        mode: z_whatami_t,
        peer_op: ::core::ffi::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_new_peer(
        zt: *mut _z_transport_t,
        session_id: *const _z_id_t,
        locator: *const _z_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_free_transport(zt: *mut *mut _z_transport_t);
}
#[doc = " The callback signature of the cleanup functions."]
pub type _z_drop_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg: *mut ::core::ffi::c_void)>;
pub const _z_subscriber_kind_t__Z_SUBSCRIBER_KIND_SUBSCRIBER: _z_subscriber_kind_t = 0;
pub const _z_subscriber_kind_t__Z_SUBSCRIBER_KIND_LIVELINESS_SUBSCRIBER: _z_subscriber_kind_t = 1;
pub type _z_subscriber_kind_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_resource_t {
    pub _key: _z_keyexpr_t,
    pub _id: u16,
    pub _refcount: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_resource_t"][::core::mem::size_of::<_z_resource_t>() - 56usize];
    ["Alignment of _z_resource_t"][::core::mem::align_of::<_z_resource_t>() - 8usize];
    ["Offset of field: _z_resource_t::_key"][::core::mem::offset_of!(_z_resource_t, _key) - 0usize];
    ["Offset of field: _z_resource_t::_id"][::core::mem::offset_of!(_z_resource_t, _id) - 48usize];
    ["Offset of field: _z_resource_t::_refcount"]
        [::core::mem::offset_of!(_z_resource_t, _refcount) - 50usize];
};
unsafe extern "C" {
    pub fn _z_resource_eq(one: *const _z_resource_t, two: *const _z_resource_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_resource_clear(res: *mut _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_copy(dst: *mut _z_resource_t, src: *const _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_free(res: *mut *mut _z_resource_t);
}
unsafe extern "C" {
    pub fn _z_resource_size(p: *mut _z_resource_t) -> usize;
}
pub type _z_resource_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_resource_t, right: *const _z_resource_t) -> bool,
>;
pub type _z_resource_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_resource_t,
        right: *const _z_resource_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_keyexpr_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_keyexpr_t, right: *const _z_keyexpr_t) -> bool,
>;
pub type _z_keyexpr_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_keyexpr_t,
        right: *const _z_keyexpr_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_keyexpr_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_keyexpr_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_keyexpr_intmap_iterator_t = _z_int_void_map_iterator_t;
#[doc = " The callback signature of the functions handling data messages."]
pub type _z_closure_sample_callback_t = ::core::option::Option<
    unsafe extern "C" fn(sample: *mut _z_sample_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_t {
    pub _key: _z_keyexpr_t,
    pub _declared_key: _z_keyexpr_t,
    pub _key_id: u16,
    pub _id: u32,
    pub _callback: _z_closure_sample_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_t"][::core::mem::size_of::<_z_subscription_t>() - 128usize];
    ["Alignment of _z_subscription_t"][::core::mem::align_of::<_z_subscription_t>() - 8usize];
    ["Offset of field: _z_subscription_t::_key"]
        [::core::mem::offset_of!(_z_subscription_t, _key) - 0usize];
    ["Offset of field: _z_subscription_t::_declared_key"]
        [::core::mem::offset_of!(_z_subscription_t, _declared_key) - 48usize];
    ["Offset of field: _z_subscription_t::_key_id"]
        [::core::mem::offset_of!(_z_subscription_t, _key_id) - 96usize];
    ["Offset of field: _z_subscription_t::_id"]
        [::core::mem::offset_of!(_z_subscription_t, _id) - 100usize];
    ["Offset of field: _z_subscription_t::_callback"]
        [::core::mem::offset_of!(_z_subscription_t, _callback) - 104usize];
    ["Offset of field: _z_subscription_t::_dropper"]
        [::core::mem::offset_of!(_z_subscription_t, _dropper) - 112usize];
    ["Offset of field: _z_subscription_t::_arg"]
        [::core::mem::offset_of!(_z_subscription_t, _arg) - 120usize];
};
unsafe extern "C" {
    pub fn _z_subscription_eq(one: *const _z_subscription_t, two: *const _z_subscription_t)
    -> bool;
}
unsafe extern "C" {
    pub fn _z_subscription_clear(sub: *mut _z_subscription_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_rc_t {
    pub _val: *mut _z_subscription_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_rc_t"][::core::mem::size_of::<_z_subscription_rc_t>() - 16usize];
    ["Alignment of _z_subscription_rc_t"][::core::mem::align_of::<_z_subscription_rc_t>() - 8usize];
    ["Offset of field: _z_subscription_rc_t::_val"]
        [::core::mem::offset_of!(_z_subscription_rc_t, _val) - 0usize];
    ["Offset of field: _z_subscription_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_subscription_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_weak_t {
    pub _val: *mut _z_subscription_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_weak_t"][::core::mem::size_of::<_z_subscription_weak_t>() - 16usize];
    ["Alignment of _z_subscription_weak_t"]
        [::core::mem::align_of::<_z_subscription_weak_t>() - 8usize];
    ["Offset of field: _z_subscription_weak_t::_val"]
        [::core::mem::offset_of!(_z_subscription_weak_t, _val) - 0usize];
    ["Offset of field: _z_subscription_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_subscription_weak_t, _cnt) - 8usize];
};
pub type _z_subscriber_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_subscription_t, right: *const _z_subscription_t) -> bool,
>;
pub type _z_subscriber_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_t,
        right: *const _z_subscription_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_subscription_rc_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_rc_t,
        right: *const _z_subscription_rc_t,
    ) -> bool,
>;
pub type _z_subscription_rc_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_rc_t,
        right: *const _z_subscription_rc_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_subscription_rc_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_publication_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_publication_t"][::core::mem::size_of::<_z_publication_t>() - 56usize];
    ["Alignment of _z_publication_t"][::core::mem::align_of::<_z_publication_t>() - 8usize];
    ["Offset of field: _z_publication_t::_key"]
        [::core::mem::offset_of!(_z_publication_t, _key) - 0usize];
    ["Offset of field: _z_publication_t::_id"]
        [::core::mem::offset_of!(_z_publication_t, _id) - 48usize];
};
#[doc = " The callback signature of the functions handling query messages."]
pub type _z_closure_query_callback_t = ::core::option::Option<
    unsafe extern "C" fn(query: *mut _z_query_rc_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_t {
    pub _key: _z_keyexpr_t,
    pub _declared_key: _z_keyexpr_t,
    pub _id: u32,
    pub _callback: _z_closure_query_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::core::ffi::c_void,
    pub _complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_t"][::core::mem::size_of::<_z_session_queryable_t>() - 136usize];
    ["Alignment of _z_session_queryable_t"]
        [::core::mem::align_of::<_z_session_queryable_t>() - 8usize];
    ["Offset of field: _z_session_queryable_t::_key"]
        [::core::mem::offset_of!(_z_session_queryable_t, _key) - 0usize];
    ["Offset of field: _z_session_queryable_t::_declared_key"]
        [::core::mem::offset_of!(_z_session_queryable_t, _declared_key) - 48usize];
    ["Offset of field: _z_session_queryable_t::_id"]
        [::core::mem::offset_of!(_z_session_queryable_t, _id) - 96usize];
    ["Offset of field: _z_session_queryable_t::_callback"]
        [::core::mem::offset_of!(_z_session_queryable_t, _callback) - 104usize];
    ["Offset of field: _z_session_queryable_t::_dropper"]
        [::core::mem::offset_of!(_z_session_queryable_t, _dropper) - 112usize];
    ["Offset of field: _z_session_queryable_t::_arg"]
        [::core::mem::offset_of!(_z_session_queryable_t, _arg) - 120usize];
    ["Offset of field: _z_session_queryable_t::_complete"]
        [::core::mem::offset_of!(_z_session_queryable_t, _complete) - 128usize];
};
unsafe extern "C" {
    pub fn _z_session_queryable_eq(
        one: *const _z_session_queryable_t,
        two: *const _z_session_queryable_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_session_queryable_clear(res: *mut _z_session_queryable_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_rc_t {
    pub _val: *mut _z_session_queryable_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_rc_t"]
        [::core::mem::size_of::<_z_session_queryable_rc_t>() - 16usize];
    ["Alignment of _z_session_queryable_rc_t"]
        [::core::mem::align_of::<_z_session_queryable_rc_t>() - 8usize];
    ["Offset of field: _z_session_queryable_rc_t::_val"]
        [::core::mem::offset_of!(_z_session_queryable_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_queryable_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_session_queryable_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_queryable_weak_t {
    pub _val: *mut _z_session_queryable_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_queryable_weak_t"]
        [::core::mem::size_of::<_z_session_queryable_weak_t>() - 16usize];
    ["Alignment of _z_session_queryable_weak_t"]
        [::core::mem::align_of::<_z_session_queryable_weak_t>() - 8usize];
    ["Offset of field: _z_session_queryable_weak_t::_val"]
        [::core::mem::offset_of!(_z_session_queryable_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_queryable_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_session_queryable_weak_t, _cnt) - 8usize];
};
pub type _z_session_queryable_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_t,
        right: *const _z_session_queryable_t,
    ) -> bool,
>;
pub type _z_session_queryable_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_t,
        right: *const _z_session_queryable_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_session_queryable_rc_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_rc_t,
        right: *const _z_session_queryable_rc_t,
    ) -> bool,
>;
pub type _z_session_queryable_rc_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_queryable_rc_t,
        right: *const _z_session_queryable_rc_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_session_queryable_rc_slist_t = _z_slist_t;
pub type _z_pending_reply_slist_t = _z_slist_t;
#[doc = " The callback signature of the functions handling query replies."]
pub type _z_closure_reply_callback_t = ::core::option::Option<
    unsafe extern "C" fn(reply: *mut _z_reply_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_pending_query_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _callback: _z_closure_reply_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _start_time: z_clock_t,
    pub _timeout: u64,
    pub _arg: *mut ::core::ffi::c_void,
    pub _pending_replies: *mut _z_pending_reply_slist_t,
    pub _target: z_query_target_t,
    pub _consolidation: z_consolidation_mode_t,
    pub _anykey: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_pending_query_t"][::core::mem::size_of::<_z_pending_query_t>() - 128usize];
    ["Alignment of _z_pending_query_t"][::core::mem::align_of::<_z_pending_query_t>() - 8usize];
    ["Offset of field: _z_pending_query_t::_key"]
        [::core::mem::offset_of!(_z_pending_query_t, _key) - 0usize];
    ["Offset of field: _z_pending_query_t::_id"]
        [::core::mem::offset_of!(_z_pending_query_t, _id) - 48usize];
    ["Offset of field: _z_pending_query_t::_callback"]
        [::core::mem::offset_of!(_z_pending_query_t, _callback) - 56usize];
    ["Offset of field: _z_pending_query_t::_dropper"]
        [::core::mem::offset_of!(_z_pending_query_t, _dropper) - 64usize];
    ["Offset of field: _z_pending_query_t::_start_time"]
        [::core::mem::offset_of!(_z_pending_query_t, _start_time) - 72usize];
    ["Offset of field: _z_pending_query_t::_timeout"]
        [::core::mem::offset_of!(_z_pending_query_t, _timeout) - 88usize];
    ["Offset of field: _z_pending_query_t::_arg"]
        [::core::mem::offset_of!(_z_pending_query_t, _arg) - 96usize];
    ["Offset of field: _z_pending_query_t::_pending_replies"]
        [::core::mem::offset_of!(_z_pending_query_t, _pending_replies) - 104usize];
    ["Offset of field: _z_pending_query_t::_target"]
        [::core::mem::offset_of!(_z_pending_query_t, _target) - 112usize];
    ["Offset of field: _z_pending_query_t::_consolidation"]
        [::core::mem::offset_of!(_z_pending_query_t, _consolidation) - 116usize];
    ["Offset of field: _z_pending_query_t::_anykey"]
        [::core::mem::offset_of!(_z_pending_query_t, _anykey) - 120usize];
};
unsafe extern "C" {
    pub fn _z_pending_query_eq(
        one: *const _z_pending_query_t,
        two: *const _z_pending_query_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_pending_query_clear(res: *mut _z_pending_query_t);
}
pub type _z_pending_query_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_pending_query_t, right: *const _z_pending_query_t) -> bool,
>;
pub type _z_pending_query_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_pending_query_t,
        right: *const _z_pending_query_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_pending_query_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __z_hello_handler_wrapper_t {
    _unused: [u8; 0],
}
#[doc = " The callback signature of the functions handling hello messages."]
pub type _z_closure_hello_callback_t = ::core::option::Option<
    unsafe extern "C" fn(hello: *mut _z_hello_t, arg: *mut __z_hello_handler_wrapper_t),
>;
unsafe extern "C" {
    pub fn _z_session_generate_zid(bs: *mut _z_id_t, size: u8) -> z_result_t;
}
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_FINAL: _z_interest_msg_type_t = 0;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_SUBSCRIBER: _z_interest_msg_type_t = 1;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_QUERYABLE: _z_interest_msg_type_t = 2;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_DECL_TOKEN: _z_interest_msg_type_t = 3;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_SUBSCRIBER: _z_interest_msg_type_t = 4;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_QUERYABLE: _z_interest_msg_type_t = 5;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_UNDECL_TOKEN: _z_interest_msg_type_t = 6;
pub const _z_interest_msg_type_t__Z_INTEREST_MSG_TYPE_CONNECTION_DROPPED: _z_interest_msg_type_t =
    7;
pub type _z_interest_msg_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_interest_msg_t {
    pub type_: u8,
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_interest_msg_t"][::core::mem::size_of::<_z_interest_msg_t>() - 8usize];
    ["Alignment of _z_interest_msg_t"][::core::mem::align_of::<_z_interest_msg_t>() - 4usize];
    ["Offset of field: _z_interest_msg_t::type_"]
        [::core::mem::offset_of!(_z_interest_msg_t, type_) - 0usize];
    ["Offset of field: _z_interest_msg_t::id"]
        [::core::mem::offset_of!(_z_interest_msg_t, id) - 4usize];
};
#[doc = " The callback signature of the functions handling interest messages."]
pub type _z_interest_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        msg: *const _z_interest_msg_t,
        peer: *mut _z_transport_peer_common_t,
        arg: *mut ::core::ffi::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
    pub _callback: _z_interest_handler_t,
    pub _arg: *mut ::core::ffi::c_void,
    pub _flags: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_t"][::core::mem::size_of::<_z_session_interest_t>() - 80usize];
    ["Alignment of _z_session_interest_t"]
        [::core::mem::align_of::<_z_session_interest_t>() - 8usize];
    ["Offset of field: _z_session_interest_t::_key"]
        [::core::mem::offset_of!(_z_session_interest_t, _key) - 0usize];
    ["Offset of field: _z_session_interest_t::_id"]
        [::core::mem::offset_of!(_z_session_interest_t, _id) - 48usize];
    ["Offset of field: _z_session_interest_t::_callback"]
        [::core::mem::offset_of!(_z_session_interest_t, _callback) - 56usize];
    ["Offset of field: _z_session_interest_t::_arg"]
        [::core::mem::offset_of!(_z_session_interest_t, _arg) - 64usize];
    ["Offset of field: _z_session_interest_t::_flags"]
        [::core::mem::offset_of!(_z_session_interest_t, _flags) - 72usize];
};
unsafe extern "C" {
    pub fn _z_session_interest_eq(
        one: *const _z_session_interest_t,
        two: *const _z_session_interest_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_session_interest_clear(res: *mut _z_session_interest_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_rc_t {
    pub _val: *mut _z_session_interest_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_rc_t"]
        [::core::mem::size_of::<_z_session_interest_rc_t>() - 16usize];
    ["Alignment of _z_session_interest_rc_t"]
        [::core::mem::align_of::<_z_session_interest_rc_t>() - 8usize];
    ["Offset of field: _z_session_interest_rc_t::_val"]
        [::core::mem::offset_of!(_z_session_interest_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_interest_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_session_interest_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_interest_weak_t {
    pub _val: *mut _z_session_interest_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_interest_weak_t"]
        [::core::mem::size_of::<_z_session_interest_weak_t>() - 16usize];
    ["Alignment of _z_session_interest_weak_t"]
        [::core::mem::align_of::<_z_session_interest_weak_t>() - 8usize];
    ["Offset of field: _z_session_interest_weak_t::_val"]
        [::core::mem::offset_of!(_z_session_interest_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_interest_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_session_interest_weak_t, _cnt) - 8usize];
};
pub type _z_session_interest_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_t,
        right: *const _z_session_interest_t,
    ) -> bool,
>;
pub type _z_session_interest_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_t,
        right: *const _z_session_interest_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_session_interest_rc_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_rc_t,
        right: *const _z_session_interest_rc_t,
    ) -> bool,
>;
pub type _z_session_interest_rc_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_session_interest_rc_t,
        right: *const _z_session_interest_rc_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_session_interest_rc_slist_t = _z_slist_t;
pub const _z_declare_type_t__Z_DECLARE_TYPE_SUBSCRIBER: _z_declare_type_t = 0;
pub const _z_declare_type_t__Z_DECLARE_TYPE_QUERYABLE: _z_declare_type_t = 1;
pub const _z_declare_type_t__Z_DECLARE_TYPE_TOKEN: _z_declare_type_t = 2;
pub type _z_declare_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_declare_data_t {
    pub _key: _z_keyexpr_t,
    pub _id: u32,
    pub _type: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_declare_data_t"][::core::mem::size_of::<_z_declare_data_t>() - 56usize];
    ["Alignment of _z_declare_data_t"][::core::mem::align_of::<_z_declare_data_t>() - 8usize];
    ["Offset of field: _z_declare_data_t::_key"]
        [::core::mem::offset_of!(_z_declare_data_t, _key) - 0usize];
    ["Offset of field: _z_declare_data_t::_id"]
        [::core::mem::offset_of!(_z_declare_data_t, _id) - 48usize];
    ["Offset of field: _z_declare_data_t::_type"]
        [::core::mem::offset_of!(_z_declare_data_t, _type) - 52usize];
};
unsafe extern "C" {
    pub fn _z_declare_data_clear(data: *mut _z_declare_data_t);
}
unsafe extern "C" {
    pub fn _z_declare_data_size(data: *mut _z_declare_data_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_declare_data_copy(dst: *mut _z_declare_data_t, src: *const _z_declare_data_t);
}
pub type _z_declare_data_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_declare_data_t, right: *const _z_declare_data_t) -> bool,
>;
pub type _z_declare_data_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_declare_data_t,
        right: *const _z_declare_data_t,
    ) -> ::core::ffi::c_int,
>;
pub type _z_declare_data_slist_t = _z_slist_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_liveliness_pending_query_t {
    pub _key: _z_keyexpr_t,
    pub _callback: _z_closure_reply_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _arg: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_liveliness_pending_query_t"]
        [::core::mem::size_of::<_z_liveliness_pending_query_t>() - 72usize];
    ["Alignment of _z_liveliness_pending_query_t"]
        [::core::mem::align_of::<_z_liveliness_pending_query_t>() - 8usize];
    ["Offset of field: _z_liveliness_pending_query_t::_key"]
        [::core::mem::offset_of!(_z_liveliness_pending_query_t, _key) - 0usize];
    ["Offset of field: _z_liveliness_pending_query_t::_callback"]
        [::core::mem::offset_of!(_z_liveliness_pending_query_t, _callback) - 48usize];
    ["Offset of field: _z_liveliness_pending_query_t::_dropper"]
        [::core::mem::offset_of!(_z_liveliness_pending_query_t, _dropper) - 56usize];
    ["Offset of field: _z_liveliness_pending_query_t::_arg"]
        [::core::mem::offset_of!(_z_liveliness_pending_query_t, _arg) - 64usize];
};
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_clear(res: *mut _z_liveliness_pending_query_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_copy(
        dst: *mut _z_liveliness_pending_query_t,
        src: *const _z_liveliness_pending_query_t,
    );
}
unsafe extern "C" {
    pub fn _z_liveliness_pending_query_clone(
        src: *const _z_liveliness_pending_query_t,
    ) -> *mut _z_liveliness_pending_query_t;
}
pub type _z_liveliness_pending_query_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_liveliness_pending_query_t,
        right: *const _z_liveliness_pending_query_t,
    ) -> bool,
>;
pub type _z_liveliness_pending_query_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_liveliness_pending_query_t,
        right: *const _z_liveliness_pending_query_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_liveliness_pending_query_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_liveliness_pending_query_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_liveliness_pending_query_intmap_iterator_t = _z_int_void_map_iterator_t;
unsafe extern "C" {
    pub fn _z_liveliness_get_query_id(zn: *mut _z_session_t) -> u32;
}
unsafe extern "C" {
    pub fn _z_liveliness_register_token(
        zn: *mut _z_session_t,
        id: u32,
        keyexpr: *const _z_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_unregister_token(zn: *mut _z_session_t, id: u32);
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_declare(
        zn: *mut _z_session_t,
        id: u32,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_undeclare(
        zn: *mut _z_session_t,
        id: u32,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_undeclare_all(zn: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_subscription_trigger_history(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_register_pending_query(
        zn: *mut _z_session_t,
        id: u32,
        pen_qry: *mut _z_liveliness_pending_query_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_unregister_pending_query(zn: *mut _z_session_t, id: u32);
}
unsafe extern "C" {
    pub fn _z_liveliness_init(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_clear(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_liveliness_process_token_declare(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_process_token_undeclare(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_liveliness_process_declare_final(
        zn: *mut _z_session_t,
        decl: *const _z_n_msg_declare_t,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_status_t {
    pub matching: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_status_t"][::core::mem::size_of::<_z_matching_status_t>() - 1usize];
    ["Alignment of _z_matching_status_t"][::core::mem::align_of::<_z_matching_status_t>() - 1usize];
    ["Offset of field: _z_matching_status_t::matching"]
        [::core::mem::offset_of!(_z_matching_status_t, matching) - 0usize];
};
pub type _z_closure_matching_status_callback_t = ::core::option::Option<
    unsafe extern "C" fn(status: *const _z_matching_status_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_matching_status_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: _z_closure_matching_status_callback_t,
    pub drop: _z_drop_handler_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_matching_status_t"]
        [::core::mem::size_of::<_z_closure_matching_status_t>() - 24usize];
    ["Alignment of _z_closure_matching_status_t"]
        [::core::mem::align_of::<_z_closure_matching_status_t>() - 8usize];
    ["Offset of field: _z_closure_matching_status_t::context"]
        [::core::mem::offset_of!(_z_closure_matching_status_t, context) - 0usize];
    ["Offset of field: _z_closure_matching_status_t::call"]
        [::core::mem::offset_of!(_z_closure_matching_status_t, call) - 8usize];
    ["Offset of field: _z_closure_matching_status_t::drop"]
        [::core::mem::offset_of!(_z_closure_matching_status_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_ctx_t {
    pub decl_id: u32,
    pub callback: _z_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_ctx_t"]
        [::core::mem::size_of::<_z_matching_listener_ctx_t>() - 32usize];
    ["Alignment of _z_matching_listener_ctx_t"]
        [::core::mem::align_of::<_z_matching_listener_ctx_t>() - 8usize];
    ["Offset of field: _z_matching_listener_ctx_t::decl_id"]
        [::core::mem::offset_of!(_z_matching_listener_ctx_t, decl_id) - 0usize];
    ["Offset of field: _z_matching_listener_ctx_t::callback"]
        [::core::mem::offset_of!(_z_matching_listener_ctx_t, callback) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_state_t {
    pub interest_id: u32,
    pub entity_id: _z_zint_t,
    pub ctx: *mut _z_matching_listener_ctx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_state_t"]
        [::core::mem::size_of::<_z_matching_listener_state_t>() - 24usize];
    ["Alignment of _z_matching_listener_state_t"]
        [::core::mem::align_of::<_z_matching_listener_state_t>() - 8usize];
    ["Offset of field: _z_matching_listener_state_t::interest_id"]
        [::core::mem::offset_of!(_z_matching_listener_state_t, interest_id) - 0usize];
    ["Offset of field: _z_matching_listener_state_t::entity_id"]
        [::core::mem::offset_of!(_z_matching_listener_state_t, entity_id) - 8usize];
    ["Offset of field: _z_matching_listener_state_t::ctx"]
        [::core::mem::offset_of!(_z_matching_listener_state_t, ctx) - 16usize];
};
unsafe extern "C" {
    pub fn _z_matching_listener_ctx_new(
        callback: _z_closure_matching_status_t,
    ) -> *mut _z_matching_listener_ctx_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_ctx_clear(ctx: *mut _z_matching_listener_ctx_t);
}
unsafe extern "C" {
    pub fn _z_matching_listener_state_new(
        interest_id: u32,
        entity_id: _z_zint_t,
        ctx: *mut _z_matching_listener_ctx_t,
    ) -> *mut _z_matching_listener_state_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_state_clear(state: *mut _z_matching_listener_state_t);
}
pub type _z_matching_listener_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_matching_listener_state_t,
        right: *const _z_matching_listener_state_t,
    ) -> bool,
>;
pub type _z_matching_listener_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_matching_listener_state_t,
        right: *const _z_matching_listener_state_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_matching_listener_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_matching_listener_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_matching_listener_intmap_iterator_t = _z_int_void_map_iterator_t;
pub type _z_lru_val_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        first: *const ::core::ffi::c_void,
        second: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
pub type _z_lru_cache_node_t = ::core::ffi::c_void;
#[doc = " A least recently used cache implementation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_lru_cache_t {
    pub capacity: usize,
    pub len: usize,
    pub head: *mut _z_lru_cache_node_t,
    pub tail: *mut _z_lru_cache_node_t,
    pub slist: *mut *mut _z_lru_cache_node_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_lru_cache_t"][::core::mem::size_of::<_z_lru_cache_t>() - 40usize];
    ["Alignment of _z_lru_cache_t"][::core::mem::align_of::<_z_lru_cache_t>() - 8usize];
    ["Offset of field: _z_lru_cache_t::capacity"]
        [::core::mem::offset_of!(_z_lru_cache_t, capacity) - 0usize];
    ["Offset of field: _z_lru_cache_t::len"][::core::mem::offset_of!(_z_lru_cache_t, len) - 8usize];
    ["Offset of field: _z_lru_cache_t::head"]
        [::core::mem::offset_of!(_z_lru_cache_t, head) - 16usize];
    ["Offset of field: _z_lru_cache_t::tail"]
        [::core::mem::offset_of!(_z_lru_cache_t, tail) - 24usize];
    ["Offset of field: _z_lru_cache_t::slist"]
        [::core::mem::offset_of!(_z_lru_cache_t, slist) - 32usize];
};
unsafe extern "C" {
    pub fn _z_lru_cache_init(capacity: usize) -> _z_lru_cache_t;
}
unsafe extern "C" {
    pub fn _z_lru_cache_get(
        cache: *mut _z_lru_cache_t,
        value: *mut ::core::ffi::c_void,
        compare: _z_lru_val_cmp_f,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_lru_cache_insert(
        cache: *mut _z_lru_cache_t,
        value: *mut ::core::ffi::c_void,
        value_size: usize,
        compare: _z_lru_val_cmp_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_lru_cache_clear(cache: *mut _z_lru_cache_t, clear: z_element_clear_f);
}
unsafe extern "C" {
    pub fn _z_lru_cache_delete(cache: *mut _z_lru_cache_t, clear: z_element_clear_f);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_infos_t {
    pub callback: _z_closure_query_callback_t,
    pub arg: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_infos_t"][::core::mem::size_of::<_z_queryable_infos_t>() - 16usize];
    ["Alignment of _z_queryable_infos_t"][::core::mem::align_of::<_z_queryable_infos_t>() - 8usize];
    ["Offset of field: _z_queryable_infos_t::callback"]
        [::core::mem::offset_of!(_z_queryable_infos_t, callback) - 0usize];
    ["Offset of field: _z_queryable_infos_t::arg"]
        [::core::mem::offset_of!(_z_queryable_infos_t, arg) - 8usize];
};
pub type _z_queryable_infos_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_queryable_infos_t,
        right: *const _z_queryable_infos_t,
    ) -> bool,
>;
pub type _z_queryable_infos_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_queryable_infos_t,
        right: *const _z_queryable_infos_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_queryable_infos_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_cache_data_t {
    pub ke_in: _z_keyexpr_t,
    pub ke_out: _z_keyexpr_t,
    pub infos: _z_queryable_infos_svec_t,
    pub qle_nb: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_cache_data_t"]
        [::core::mem::size_of::<_z_queryable_cache_data_t>() - 136usize];
    ["Alignment of _z_queryable_cache_data_t"]
        [::core::mem::align_of::<_z_queryable_cache_data_t>() - 8usize];
    ["Offset of field: _z_queryable_cache_data_t::ke_in"]
        [::core::mem::offset_of!(_z_queryable_cache_data_t, ke_in) - 0usize];
    ["Offset of field: _z_queryable_cache_data_t::ke_out"]
        [::core::mem::offset_of!(_z_queryable_cache_data_t, ke_out) - 48usize];
    ["Offset of field: _z_queryable_cache_data_t::infos"]
        [::core::mem::offset_of!(_z_queryable_cache_data_t, infos) - 96usize];
    ["Offset of field: _z_queryable_cache_data_t::qle_nb"]
        [::core::mem::offset_of!(_z_queryable_cache_data_t, qle_nb) - 128usize];
};
unsafe extern "C" {
    pub fn _z_queryable_cache_invalidate(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_queryable_cache_data_compare(
        first: *const ::core::ffi::c_void,
        second: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_queryable_cache_data_clear(val: *mut _z_queryable_cache_data_t);
}
unsafe extern "C" {
    pub fn _z_get_session_queryable_by_id(
        zn: *mut _z_session_t,
        id: _z_zint_t,
    ) -> *mut _z_session_queryable_rc_t;
}
unsafe extern "C" {
    pub fn _z_register_session_queryable(
        zn: *mut _z_session_t,
        q: *mut _z_session_queryable_t,
    ) -> *mut _z_session_queryable_rc_t;
}
unsafe extern "C" {
    pub fn _z_trigger_queryables(
        zn: *mut _z_session_rc_t,
        query: *mut _z_msg_query_t,
        q_key: *mut _z_keyexpr_t,
        qid: u32,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_unregister_session_queryable(
        zn: *mut _z_session_t,
        q: *mut _z_session_queryable_rc_t,
    );
}
unsafe extern "C" {
    pub fn _z_flush_session_queryable(zn: *mut _z_session_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_infos_t {
    pub callback: _z_closure_sample_callback_t,
    pub arg: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_infos_t"]
        [::core::mem::size_of::<_z_subscription_infos_t>() - 16usize];
    ["Alignment of _z_subscription_infos_t"]
        [::core::mem::align_of::<_z_subscription_infos_t>() - 8usize];
    ["Offset of field: _z_subscription_infos_t::callback"]
        [::core::mem::offset_of!(_z_subscription_infos_t, callback) - 0usize];
    ["Offset of field: _z_subscription_infos_t::arg"]
        [::core::mem::offset_of!(_z_subscription_infos_t, arg) - 8usize];
};
pub type _z_subscription_infos_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_infos_t,
        right: *const _z_subscription_infos_t,
    ) -> bool,
>;
pub type _z_subscription_infos_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_subscription_infos_t,
        right: *const _z_subscription_infos_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type _z_subscription_infos_svec_t = _z_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscription_cache_data_t {
    pub ke_in: _z_keyexpr_t,
    pub ke_out: _z_keyexpr_t,
    pub infos: _z_subscription_infos_svec_t,
    pub sub_nb: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscription_cache_data_t"]
        [::core::mem::size_of::<_z_subscription_cache_data_t>() - 136usize];
    ["Alignment of _z_subscription_cache_data_t"]
        [::core::mem::align_of::<_z_subscription_cache_data_t>() - 8usize];
    ["Offset of field: _z_subscription_cache_data_t::ke_in"]
        [::core::mem::offset_of!(_z_subscription_cache_data_t, ke_in) - 0usize];
    ["Offset of field: _z_subscription_cache_data_t::ke_out"]
        [::core::mem::offset_of!(_z_subscription_cache_data_t, ke_out) - 48usize];
    ["Offset of field: _z_subscription_cache_data_t::infos"]
        [::core::mem::offset_of!(_z_subscription_cache_data_t, infos) - 96usize];
    ["Offset of field: _z_subscription_cache_data_t::sub_nb"]
        [::core::mem::offset_of!(_z_subscription_cache_data_t, sub_nb) - 128usize];
};
unsafe extern "C" {
    pub fn _z_subscription_cache_invalidate(zn: *mut _z_session_t);
}
unsafe extern "C" {
    pub fn _z_subscription_cache_data_compare(
        first: *const ::core::ffi::c_void,
        second: *const ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _z_subscription_cache_data_clear(val: *mut _z_subscription_cache_data_t);
}
unsafe extern "C" {
    pub fn _z_trigger_liveliness_subscriptions_declare(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_trigger_liveliness_subscriptions_undeclare(
        zn: *mut _z_session_t,
        keyexpr: *const _z_keyexpr_t,
        timestamp: *const _z_timestamp_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_get_subscription_by_id(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        id: _z_zint_t,
    ) -> *mut _z_subscription_rc_t;
}
unsafe extern "C" {
    pub fn _z_register_subscription(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        sub: *mut _z_subscription_t,
    ) -> *mut _z_subscription_rc_t;
}
unsafe extern "C" {
    pub fn _z_trigger_subscriptions_impl(
        zn: *mut _z_session_t,
        sub_kind: _z_subscriber_kind_t,
        keyexpr: *mut _z_keyexpr_t,
        payload: *mut _z_bytes_t,
        encoding: *mut _z_encoding_t,
        sample_kind: _z_zint_t,
        timestamp: *const _z_timestamp_t,
        qos: _z_n_qos_t,
        attachment: *mut _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *mut _z_source_info_t,
        peer: *mut _z_transport_peer_common_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_unregister_subscription(
        zn: *mut _z_session_t,
        kind: _z_subscriber_kind_t,
        sub: *mut _z_subscription_rc_t,
    );
}
unsafe extern "C" {
    pub fn _z_flush_subscriptions(zn: *mut _z_session_t);
}
#[doc = " Zenoh-net properties are represented as int-string map."]
pub type _z_config_t = _z_str_intmap_t;
unsafe extern "C" {
    #[doc = " Initialize a new empty map of properties."]
    pub fn _z_config_init(ps: *mut _z_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Insert a property with a given key to a properties map.\n If a property with the same key already exists in the properties map, it is replaced.\n\n Parameters:\n   ps: A pointer to the properties map.\n   key: The key of the property to add.\n   value: The value of the property to add."]
    pub fn _zp_config_insert(
        ps: *mut _z_config_t,
        key: u8,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _zp_config_insert_string(
        ps: *mut _z_config_t,
        key: u8,
        value: *const _z_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Get the property with the given key from a properties map.\n\n Parameters:\n     ps: A pointer to properties map.\n     key: The key of the property.\n\n Returns:\n     The value of the property with key ``key`` in properties map ``ps``."]
    pub fn _z_config_get(ps: *const _z_config_t, key: u8) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn _z_config_get_all(
        ps: *const _z_config_t,
        locators: *mut _z_string_svec_t,
        key: u8,
    ) -> z_result_t;
}
#[doc = " A zenoh-net session."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_session_t {
    pub _mutex_inner: _z_mutex_t,
    pub _mode: z_whatami_t,
    pub _tp: _z_transport_t,
    pub _local_zid: _z_id_t,
    pub _resource_id: u16,
    pub _entity_id: u32,
    pub _query_id: _z_zint_t,
    pub _interest_id: _z_zint_t,
    pub _local_resources: *mut _z_resource_slist_t,
    pub _config: _z_config_t,
    pub _declaration_cache: *mut _z_network_message_slist_t,
    pub _lease_task_attr: *mut z_task_attr_t,
    pub _read_task_attr: *mut z_task_attr_t,
    pub _subscriptions: *mut _z_subscription_rc_slist_t,
    pub _liveliness_subscriptions: *mut _z_subscription_rc_slist_t,
    pub _local_tokens: _z_keyexpr_intmap_t,
    pub _remote_tokens: _z_keyexpr_intmap_t,
    pub _liveliness_query_id: u32,
    pub _liveliness_pending_queries: _z_liveliness_pending_query_intmap_t,
    pub _local_queryable: *mut _z_session_queryable_rc_slist_t,
    pub _pending_queries: *mut _z_pending_query_slist_t,
    pub _matching_listeners: _z_matching_listener_intmap_t,
    pub _local_interests: *mut _z_session_interest_rc_slist_t,
    pub _remote_declares: *mut _z_declare_data_slist_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_t"][::core::mem::size_of::<_z_session_t>() - 1008usize];
    ["Alignment of _z_session_t"][::core::mem::align_of::<_z_session_t>() - 8usize];
    ["Offset of field: _z_session_t::_mutex_inner"]
        [::core::mem::offset_of!(_z_session_t, _mutex_inner) - 0usize];
    ["Offset of field: _z_session_t::_mode"]
        [::core::mem::offset_of!(_z_session_t, _mode) - 64usize];
    ["Offset of field: _z_session_t::_tp"][::core::mem::offset_of!(_z_session_t, _tp) - 72usize];
    ["Offset of field: _z_session_t::_local_zid"]
        [::core::mem::offset_of!(_z_session_t, _local_zid) - 720usize];
    ["Offset of field: _z_session_t::_resource_id"]
        [::core::mem::offset_of!(_z_session_t, _resource_id) - 736usize];
    ["Offset of field: _z_session_t::_entity_id"]
        [::core::mem::offset_of!(_z_session_t, _entity_id) - 740usize];
    ["Offset of field: _z_session_t::_query_id"]
        [::core::mem::offset_of!(_z_session_t, _query_id) - 744usize];
    ["Offset of field: _z_session_t::_interest_id"]
        [::core::mem::offset_of!(_z_session_t, _interest_id) - 752usize];
    ["Offset of field: _z_session_t::_local_resources"]
        [::core::mem::offset_of!(_z_session_t, _local_resources) - 760usize];
    ["Offset of field: _z_session_t::_config"]
        [::core::mem::offset_of!(_z_session_t, _config) - 768usize];
    ["Offset of field: _z_session_t::_declaration_cache"]
        [::core::mem::offset_of!(_z_session_t, _declaration_cache) - 800usize];
    ["Offset of field: _z_session_t::_lease_task_attr"]
        [::core::mem::offset_of!(_z_session_t, _lease_task_attr) - 808usize];
    ["Offset of field: _z_session_t::_read_task_attr"]
        [::core::mem::offset_of!(_z_session_t, _read_task_attr) - 816usize];
    ["Offset of field: _z_session_t::_subscriptions"]
        [::core::mem::offset_of!(_z_session_t, _subscriptions) - 824usize];
    ["Offset of field: _z_session_t::_liveliness_subscriptions"]
        [::core::mem::offset_of!(_z_session_t, _liveliness_subscriptions) - 832usize];
    ["Offset of field: _z_session_t::_local_tokens"]
        [::core::mem::offset_of!(_z_session_t, _local_tokens) - 840usize];
    ["Offset of field: _z_session_t::_remote_tokens"]
        [::core::mem::offset_of!(_z_session_t, _remote_tokens) - 872usize];
    ["Offset of field: _z_session_t::_liveliness_query_id"]
        [::core::mem::offset_of!(_z_session_t, _liveliness_query_id) - 904usize];
    ["Offset of field: _z_session_t::_liveliness_pending_queries"]
        [::core::mem::offset_of!(_z_session_t, _liveliness_pending_queries) - 912usize];
    ["Offset of field: _z_session_t::_local_queryable"]
        [::core::mem::offset_of!(_z_session_t, _local_queryable) - 944usize];
    ["Offset of field: _z_session_t::_pending_queries"]
        [::core::mem::offset_of!(_z_session_t, _pending_queries) - 952usize];
    ["Offset of field: _z_session_t::_matching_listeners"]
        [::core::mem::offset_of!(_z_session_t, _matching_listeners) - 960usize];
    ["Offset of field: _z_session_t::_local_interests"]
        [::core::mem::offset_of!(_z_session_t, _local_interests) - 992usize];
    ["Offset of field: _z_session_t::_remote_declares"]
        [::core::mem::offset_of!(_z_session_t, _remote_declares) - 1000usize];
};
unsafe extern "C" {
    pub fn _z_session_clear(zn: *mut _z_session_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_rc_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_rc_t"][::core::mem::size_of::<_z_session_rc_t>() - 16usize];
    ["Alignment of _z_session_rc_t"][::core::mem::align_of::<_z_session_rc_t>() - 8usize];
    ["Offset of field: _z_session_rc_t::_val"]
        [::core::mem::offset_of!(_z_session_rc_t, _val) - 0usize];
    ["Offset of field: _z_session_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_session_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_session_weak_t {
    pub _val: *mut _z_session_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_session_weak_t"][::core::mem::size_of::<_z_session_weak_t>() - 16usize];
    ["Alignment of _z_session_weak_t"][::core::mem::align_of::<_z_session_weak_t>() - 8usize];
    ["Offset of field: _z_session_weak_t::_val"]
        [::core::mem::offset_of!(_z_session_weak_t, _val) - 0usize];
    ["Offset of field: _z_session_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_session_weak_t, _cnt) - 8usize];
};
unsafe extern "C" {
    #[doc = " Open a zenoh-net session\n\n Parameters:\n     zn: A pointer of A :c:type:`_z_session_rc_t` used as a return value.\n     config: A set of properties. The caller keeps its ownership.\n     zid: A pointer to Zenoh ID.\n\n Returns:\n     ``0`` in case of success, or a ``negative value`` in case of failure."]
    pub fn _z_open(
        zn: *mut _z_session_rc_t,
        config: *mut _z_config_t,
        zid: *const _z_id_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Reopen a disconnected zenoh-net session\n\n Parameters:\n     zn: Existing zenoh-net session.\n\n Returns:\n     ``0`` in case of success, or a ``negative value`` in case of failure."]
    pub fn _z_reopen(zn: *mut _z_session_rc_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Store declaration network message to cache for resend it after session restore\n\n Parameters:\n     zs: A zenoh-net session.\n     z_msg: Network message with declaration"]
    pub fn _z_cache_declaration(zs: *mut _z_session_t, n_msg: *const _z_network_message_t);
}
unsafe extern "C" {
    #[doc = " Remove corresponding declaration from the cache\n\n Parameters:\n     zs: A zenoh-net session.\n     z_msg: Network message with undeclaration"]
    pub fn _z_prune_declaration(zs: *mut _z_session_t, n_msg: *const _z_network_message_t);
}
unsafe extern "C" {
    #[doc = " Close a zenoh-net session.\n\n Parameters:\n     session: A zenoh-net session. The callee releases session upon successful return."]
    pub fn _z_close(session: *mut _z_session_t);
}
unsafe extern "C" {
    #[doc = " Return true is session and all associated transports were closed."]
    pub fn _z_session_is_closed(session: *const _z_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Upgrades weak session session, than resets it to null if session is closed."]
    pub fn _z_session_weak_upgrade_if_open(session: *const _z_session_weak_t) -> _z_session_rc_t;
}
unsafe extern "C" {
    #[doc = " Get informations about an zenoh-net session.\n\n Parameters:\n     session: A zenoh-net session. The caller keeps its ownership.\n\n Returns:\n     A :c:type:`_z_config_t` map containing informations on the given zenoh-net session."]
    pub fn _z_info(session: *const _z_session_t) -> *mut _z_config_t;
}
unsafe extern "C" {
    #[doc = " Read from the network. This function should be called manually called when\n the read loop has not been started, e.g., when running in a single thread.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n     single_read: Read a single packet from the buffer instead of the whole buffer\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_read(z: *mut _z_session_t, single_read: bool) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send a KeepAlive message.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_send_keep_alive(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send a Join message.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_send_join(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Start a separate task to read from the network and process the messages\n as soon as they are received. Note that the task can be implemented in\n form of thread, process, etc. and its implementation is platform-dependent.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_start_read_task(z: *mut _z_session_t, attr: *mut z_task_attr_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stop the read task. This may result in stopping a thread or a process depending\n on the target platform.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_stop_read_task(z: *mut _z_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Start a separate task to handle the session lease. This task will send ``KeepAlive``\n messages when needed and will close the session when the lease is expired. Note that\n the task can be implemented in form of thread, process, etc. and its implementation\n is platform-dependent.\n\n In case of a multicast transport, this task will also send periodic ``Join``\n messages.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_start_lease_task(z: *mut _z_session_t, attr: *mut z_task_attr_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stop the lease task. This may result in stopping a thread or a process depending\n on the target platform.\n\n Parameters:\n     session: The zenoh-net session. The caller keeps its ownership.\n Returns:\n     ``0`` in case of success, ``-1`` in case of failure."]
    pub fn _zp_stop_lease_task(z: *mut _z_session_t) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_matching_listener_t {
    pub _id: u32,
    pub _interest_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_matching_listener_t"][::core::mem::size_of::<_z_matching_listener_t>() - 24usize];
    ["Alignment of _z_matching_listener_t"]
        [::core::mem::align_of::<_z_matching_listener_t>() - 8usize];
    ["Offset of field: _z_matching_listener_t::_id"]
        [::core::mem::offset_of!(_z_matching_listener_t, _id) - 0usize];
    ["Offset of field: _z_matching_listener_t::_interest_id"]
        [::core::mem::offset_of!(_z_matching_listener_t, _interest_id) - 4usize];
    ["Offset of field: _z_matching_listener_t::_zn"]
        [::core::mem::offset_of!(_z_matching_listener_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_matching_listener_declare(
        zn: *mut _z_session_rc_t,
        key: *const _z_keyexpr_t,
        entity_id: _z_zint_t,
        interest_type_flag: u8,
        callback: _z_closure_matching_status_t,
    ) -> _z_matching_listener_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_entity_undeclare(
        zn: *mut _z_session_t,
        entity_id: _z_zint_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_undeclare(listener: *mut _z_matching_listener_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_matching_listener_clear(listener: *mut _z_matching_listener_t);
}
unsafe extern "C" {
    pub fn _z_matching_listener_free(listener: *mut *mut _z_matching_listener_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_filter_target_t {
    pub peer: usize,
    pub decl_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_filter_target_t"][::core::mem::size_of::<_z_filter_target_t>() - 16usize];
    ["Alignment of _z_filter_target_t"][::core::mem::align_of::<_z_filter_target_t>() - 8usize];
    ["Offset of field: _z_filter_target_t::peer"]
        [::core::mem::offset_of!(_z_filter_target_t, peer) - 0usize];
    ["Offset of field: _z_filter_target_t::decl_id"]
        [::core::mem::offset_of!(_z_filter_target_t, decl_id) - 8usize];
};
pub type _z_filter_target_eq_f = z_element_eq_f;
pub type _z_filter_target_slist_t = _z_slist_t;
pub const _z_write_filter_state_t_WRITE_FILTER_ACTIVE: _z_write_filter_state_t = 0;
pub const _z_write_filter_state_t_WRITE_FILTER_OFF: _z_write_filter_state_t = 1;
pub type _z_write_filter_state_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_writer_filter_ctx_t {
    pub mutex: _z_mutex_t,
    pub targets: *mut _z_filter_target_slist_t,
    pub state: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_writer_filter_ctx_t"][::core::mem::size_of::<_z_writer_filter_ctx_t>() - 80usize];
    ["Alignment of _z_writer_filter_ctx_t"]
        [::core::mem::align_of::<_z_writer_filter_ctx_t>() - 8usize];
    ["Offset of field: _z_writer_filter_ctx_t::mutex"]
        [::core::mem::offset_of!(_z_writer_filter_ctx_t, mutex) - 0usize];
    ["Offset of field: _z_writer_filter_ctx_t::targets"]
        [::core::mem::offset_of!(_z_writer_filter_ctx_t, targets) - 64usize];
    ["Offset of field: _z_writer_filter_ctx_t::state"]
        [::core::mem::offset_of!(_z_writer_filter_ctx_t, state) - 72usize];
};
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_write_filter_t {
    pub _interest_id: u32,
    pub ctx: *mut _z_writer_filter_ctx_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_write_filter_t"][::core::mem::size_of::<_z_write_filter_t>() - 16usize];
    ["Alignment of _z_write_filter_t"][::core::mem::align_of::<_z_write_filter_t>() - 8usize];
    ["Offset of field: _z_write_filter_t::_interest_id"]
        [::core::mem::offset_of!(_z_write_filter_t, _interest_id) - 0usize];
    ["Offset of field: _z_write_filter_t::ctx"]
        [::core::mem::offset_of!(_z_write_filter_t, ctx) - 8usize];
};
unsafe extern "C" {
    pub fn _z_write_filter_create(
        zn: *mut _z_session_t,
        filter: *mut _z_write_filter_t,
        keyexpr: _z_keyexpr_t,
        interest_flag: u8,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_write_filter_destroy(
        zn: *mut _z_session_t,
        filter: *mut _z_write_filter_t,
    ) -> z_result_t;
}
#[doc = " Return type when declaring a publisher."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_publisher_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_publisher_t"][::core::mem::size_of::<_z_publisher_t>() - 144usize];
    ["Alignment of _z_publisher_t"][::core::mem::align_of::<_z_publisher_t>() - 8usize];
    ["Offset of field: _z_publisher_t::_key"]
        [::core::mem::offset_of!(_z_publisher_t, _key) - 0usize];
    ["Offset of field: _z_publisher_t::_id"]
        [::core::mem::offset_of!(_z_publisher_t, _id) - 48usize];
    ["Offset of field: _z_publisher_t::_zn"]
        [::core::mem::offset_of!(_z_publisher_t, _zn) - 56usize];
    ["Offset of field: _z_publisher_t::_encoding"]
        [::core::mem::offset_of!(_z_publisher_t, _encoding) - 72usize];
    ["Offset of field: _z_publisher_t::_congestion_control"]
        [::core::mem::offset_of!(_z_publisher_t, _congestion_control) - 112usize];
    ["Offset of field: _z_publisher_t::_priority"]
        [::core::mem::offset_of!(_z_publisher_t, _priority) - 116usize];
    ["Offset of field: _z_publisher_t::reliability"]
        [::core::mem::offset_of!(_z_publisher_t, reliability) - 120usize];
    ["Offset of field: _z_publisher_t::_is_express"]
        [::core::mem::offset_of!(_z_publisher_t, _is_express) - 124usize];
    ["Offset of field: _z_publisher_t::_filter"]
        [::core::mem::offset_of!(_z_publisher_t, _filter) - 128usize];
};
unsafe extern "C" {
    pub fn _z_publisher_clear(pub_: *mut _z_publisher_t);
}
unsafe extern "C" {
    pub fn _z_publisher_free(pub_: *mut *mut _z_publisher_t);
}
#[doc = " The query to be answered by a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_t {
    pub _key: _z_keyexpr_t,
    pub _value: _z_value_t,
    pub _request_id: u32,
    pub _zn: _z_session_weak_t,
    pub _attachment: _z_bytes_t,
    pub _parameters: _z_string_t,
    pub _anyke: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_t"][::core::mem::size_of::<_z_query_t>() - 216usize];
    ["Alignment of _z_query_t"][::core::mem::align_of::<_z_query_t>() - 8usize];
    ["Offset of field: _z_query_t::_key"][::core::mem::offset_of!(_z_query_t, _key) - 0usize];
    ["Offset of field: _z_query_t::_value"][::core::mem::offset_of!(_z_query_t, _value) - 48usize];
    ["Offset of field: _z_query_t::_request_id"]
        [::core::mem::offset_of!(_z_query_t, _request_id) - 120usize];
    ["Offset of field: _z_query_t::_zn"][::core::mem::offset_of!(_z_query_t, _zn) - 128usize];
    ["Offset of field: _z_query_t::_attachment"]
        [::core::mem::offset_of!(_z_query_t, _attachment) - 144usize];
    ["Offset of field: _z_query_t::_parameters"]
        [::core::mem::offset_of!(_z_query_t, _parameters) - 176usize];
    ["Offset of field: _z_query_t::_anyke"][::core::mem::offset_of!(_z_query_t, _anyke) - 208usize];
};
unsafe extern "C" {
    pub fn _z_query_send_reply_final(q: *mut _z_query_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_query_clear(q: *mut _z_query_t);
}
unsafe extern "C" {
    pub fn _z_query_free(query: *mut *mut _z_query_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_rc_t {
    pub _val: *mut _z_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_rc_t"][::core::mem::size_of::<_z_query_rc_t>() - 16usize];
    ["Alignment of _z_query_rc_t"][::core::mem::align_of::<_z_query_rc_t>() - 8usize];
    ["Offset of field: _z_query_rc_t::_val"][::core::mem::offset_of!(_z_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_query_rc_t::_cnt"][::core::mem::offset_of!(_z_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_query_weak_t {
    pub _val: *mut _z_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_query_weak_t"][::core::mem::size_of::<_z_query_weak_t>() - 16usize];
    ["Alignment of _z_query_weak_t"][::core::mem::align_of::<_z_query_weak_t>() - 8usize];
    ["Offset of field: _z_query_weak_t::_val"]
        [::core::mem::offset_of!(_z_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_query_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_query_weak_t, _cnt) - 8usize];
};
#[doc = " Return type when declaring a querier."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_querier_t {
    pub _key: _z_keyexpr_t,
    pub _id: _z_zint_t,
    pub _zn: _z_session_weak_t,
    pub _encoding: _z_encoding_t,
    pub _consolidation_mode: z_consolidation_mode_t,
    pub _target: z_query_target_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub reliability: z_reliability_t,
    pub _is_express: bool,
    pub _timeout_ms: u64,
    pub _filter: _z_write_filter_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_querier_t"][::core::mem::size_of::<_z_querier_t>() - 160usize];
    ["Alignment of _z_querier_t"][::core::mem::align_of::<_z_querier_t>() - 8usize];
    ["Offset of field: _z_querier_t::_key"][::core::mem::offset_of!(_z_querier_t, _key) - 0usize];
    ["Offset of field: _z_querier_t::_id"][::core::mem::offset_of!(_z_querier_t, _id) - 48usize];
    ["Offset of field: _z_querier_t::_zn"][::core::mem::offset_of!(_z_querier_t, _zn) - 56usize];
    ["Offset of field: _z_querier_t::_encoding"]
        [::core::mem::offset_of!(_z_querier_t, _encoding) - 72usize];
    ["Offset of field: _z_querier_t::_consolidation_mode"]
        [::core::mem::offset_of!(_z_querier_t, _consolidation_mode) - 112usize];
    ["Offset of field: _z_querier_t::_target"]
        [::core::mem::offset_of!(_z_querier_t, _target) - 116usize];
    ["Offset of field: _z_querier_t::_congestion_control"]
        [::core::mem::offset_of!(_z_querier_t, _congestion_control) - 120usize];
    ["Offset of field: _z_querier_t::_priority"]
        [::core::mem::offset_of!(_z_querier_t, _priority) - 124usize];
    ["Offset of field: _z_querier_t::reliability"]
        [::core::mem::offset_of!(_z_querier_t, reliability) - 128usize];
    ["Offset of field: _z_querier_t::_is_express"]
        [::core::mem::offset_of!(_z_querier_t, _is_express) - 132usize];
    ["Offset of field: _z_querier_t::_timeout_ms"]
        [::core::mem::offset_of!(_z_querier_t, _timeout_ms) - 136usize];
    ["Offset of field: _z_querier_t::_filter"]
        [::core::mem::offset_of!(_z_querier_t, _filter) - 144usize];
};
unsafe extern "C" {
    pub fn _z_querier_clear(querier: *mut _z_querier_t);
}
unsafe extern "C" {
    pub fn _z_querier_free(querier: *mut *mut _z_querier_t);
}
#[doc = " Return type when declaring a queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_queryable_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_queryable_t"][::core::mem::size_of::<_z_queryable_t>() - 24usize];
    ["Alignment of _z_queryable_t"][::core::mem::align_of::<_z_queryable_t>() - 8usize];
    ["Offset of field: _z_queryable_t::_entity_id"]
        [::core::mem::offset_of!(_z_queryable_t, _entity_id) - 0usize];
    ["Offset of field: _z_queryable_t::_zn"][::core::mem::offset_of!(_z_queryable_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_queryable_clear(qbl: *mut _z_queryable_t);
}
unsafe extern "C" {
    pub fn _z_queryable_free(qbl: *mut *mut _z_queryable_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_t {
    pub _val: *mut *mut ::core::ffi::c_void,
    pub _capacity: usize,
    pub _len: usize,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_t"][::core::mem::size_of::<_z_ring_t>() - 40usize];
    ["Alignment of _z_ring_t"][::core::mem::align_of::<_z_ring_t>() - 8usize];
    ["Offset of field: _z_ring_t::_val"][::core::mem::offset_of!(_z_ring_t, _val) - 0usize];
    ["Offset of field: _z_ring_t::_capacity"]
        [::core::mem::offset_of!(_z_ring_t, _capacity) - 8usize];
    ["Offset of field: _z_ring_t::_len"][::core::mem::offset_of!(_z_ring_t, _len) - 16usize];
    ["Offset of field: _z_ring_t::_r_idx"][::core::mem::offset_of!(_z_ring_t, _r_idx) - 24usize];
    ["Offset of field: _z_ring_t::_w_idx"][::core::mem::offset_of!(_z_ring_t, _w_idx) - 32usize];
};
#[doc = " Forward iterator of a ring buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_iterator_t {
    pub _val: *mut ::core::ffi::c_void,
    pub _ring: *const _z_ring_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_iterator_t"][::core::mem::size_of::<_z_ring_iterator_t>() - 32usize];
    ["Alignment of _z_ring_iterator_t"][::core::mem::align_of::<_z_ring_iterator_t>() - 8usize];
    ["Offset of field: _z_ring_iterator_t::_val"]
        [::core::mem::offset_of!(_z_ring_iterator_t, _val) - 0usize];
    ["Offset of field: _z_ring_iterator_t::_ring"]
        [::core::mem::offset_of!(_z_ring_iterator_t, _ring) - 8usize];
    ["Offset of field: _z_ring_iterator_t::_r_idx"]
        [::core::mem::offset_of!(_z_ring_iterator_t, _r_idx) - 16usize];
    ["Offset of field: _z_ring_iterator_t::_w_idx"]
        [::core::mem::offset_of!(_z_ring_iterator_t, _w_idx) - 24usize];
};
#[doc = " Reverse iterator of a ring buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_reverse_iterator_t {
    pub _val: *mut ::core::ffi::c_void,
    pub _ring: *const _z_ring_t,
    pub _r_idx: usize,
    pub _w_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_reverse_iterator_t"]
        [::core::mem::size_of::<_z_ring_reverse_iterator_t>() - 32usize];
    ["Alignment of _z_ring_reverse_iterator_t"]
        [::core::mem::align_of::<_z_ring_reverse_iterator_t>() - 8usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_val"]
        [::core::mem::offset_of!(_z_ring_reverse_iterator_t, _val) - 0usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_ring"]
        [::core::mem::offset_of!(_z_ring_reverse_iterator_t, _ring) - 8usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_r_idx"]
        [::core::mem::offset_of!(_z_ring_reverse_iterator_t, _r_idx) - 16usize];
    ["Offset of field: _z_ring_reverse_iterator_t::_w_idx"]
        [::core::mem::offset_of!(_z_ring_reverse_iterator_t, _w_idx) - 24usize];
};
unsafe extern "C" {
    pub fn _z_ring_init(ring: *mut _z_ring_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_make(capacity: usize) -> _z_ring_t;
}
unsafe extern "C" {
    pub fn _z_ring_capacity(r: *const _z_ring_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_ring_len(r: *const _z_ring_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_ring_is_empty(r: *const _z_ring_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_is_full(r: *const _z_ring_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_push(r: *mut _z_ring_t, e: *mut ::core::ffi::c_void)
    -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_push_force(
        r: *mut _z_ring_t,
        e: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_push_force_drop(
        r: *mut _z_ring_t,
        e: *mut ::core::ffi::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_ring_pull(r: *mut _z_ring_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_clone(xs: *const _z_ring_t, d_f: z_element_clone_f) -> *mut _z_ring_t;
}
unsafe extern "C" {
    pub fn _z_ring_clear(v: *mut _z_ring_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_free(xs: *mut *mut _z_ring_t, f_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_iterator_make(ring: *const _z_ring_t) -> _z_ring_iterator_t;
}
unsafe extern "C" {
    pub fn _z_ring_iterator_next(iter: *mut _z_ring_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_iterator_value(iter: *const _z_ring_iterator_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_make(ring: *const _z_ring_t) -> _z_ring_reverse_iterator_t;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_next(iter: *mut _z_ring_reverse_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_ring_reverse_iterator_value(
        iter: *const _z_ring_reverse_iterator_t,
    ) -> *mut ::core::ffi::c_void;
}
#[doc = " A zenoh-net data sample.\n\n A sample is the value associated to a given resource at a given point in time.\n\n Members:\n   _z_keyexpr_t key: The resource key of this data sample.\n   _z_slice_t value: The value of this data sample.\n   _z_encoding_t encoding: The encoding for the value of this data sample.\n   _z_source_info_t source_info: The source info for this data sample (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sample_t {
    pub keyexpr: _z_keyexpr_t,
    pub payload: _z_bytes_t,
    pub timestamp: _z_timestamp_t,
    pub encoding: _z_encoding_t,
    pub kind: z_sample_kind_t,
    pub qos: _z_qos_t,
    pub attachment: _z_bytes_t,
    pub reliability: z_reliability_t,
    pub source_info: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sample_t"][::core::mem::size_of::<_z_sample_t>() - 224usize];
    ["Alignment of _z_sample_t"][::core::mem::align_of::<_z_sample_t>() - 8usize];
    ["Offset of field: _z_sample_t::keyexpr"]
        [::core::mem::offset_of!(_z_sample_t, keyexpr) - 0usize];
    ["Offset of field: _z_sample_t::payload"]
        [::core::mem::offset_of!(_z_sample_t, payload) - 48usize];
    ["Offset of field: _z_sample_t::timestamp"]
        [::core::mem::offset_of!(_z_sample_t, timestamp) - 80usize];
    ["Offset of field: _z_sample_t::encoding"]
        [::core::mem::offset_of!(_z_sample_t, encoding) - 112usize];
    ["Offset of field: _z_sample_t::kind"][::core::mem::offset_of!(_z_sample_t, kind) - 152usize];
    ["Offset of field: _z_sample_t::qos"][::core::mem::offset_of!(_z_sample_t, qos) - 156usize];
    ["Offset of field: _z_sample_t::attachment"]
        [::core::mem::offset_of!(_z_sample_t, attachment) - 160usize];
    ["Offset of field: _z_sample_t::reliability"]
        [::core::mem::offset_of!(_z_sample_t, reliability) - 192usize];
    ["Offset of field: _z_sample_t::source_info"]
        [::core::mem::offset_of!(_z_sample_t, source_info) - 196usize];
};
unsafe extern "C" {
    pub fn _z_sample_clear(sample: *mut _z_sample_t);
}
unsafe extern "C" {
    pub fn _z_sample_steal_data(
        dst: *mut _z_sample_t,
        key: *mut _z_keyexpr_t,
        payload: *mut _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *mut _z_encoding_t,
        kind: z_sample_kind_t,
        qos: _z_qos_t,
        attachment: *mut _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *mut _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_sample_copy_data(
        dst: *mut _z_sample_t,
        key: *const _z_keyexpr_t,
        payload: *const _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *const _z_encoding_t,
        kind: z_sample_kind_t,
        qos: _z_qos_t,
        attachment: *const _z_bytes_t,
        reliability: z_reliability_t,
        source_info: *const _z_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sample_move(dst: *mut _z_sample_t, src: *mut _z_sample_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Free a :c:type:`_z_sample_t`, including its internal fields.\n\n Parameters:\n     sample: The :c:type:`_z_sample_t` to free."]
    pub fn _z_sample_free(sample: *mut *mut _z_sample_t);
}
unsafe extern "C" {
    pub fn _z_sample_copy(dst: *mut _z_sample_t, src: *const _z_sample_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sample_duplicate(src: *const _z_sample_t) -> _z_sample_t;
}
pub type _z_sample_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_sample_t, right: *const _z_sample_t) -> bool,
>;
pub type _z_sample_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_sample_t, right: *const _z_sample_t) -> ::core::ffi::c_int,
>;
pub type _z_sample_ring_t = _z_ring_t;
#[doc = " Forward iterator of a ring buffer."]
pub type _z_sample_ring_iterator_t = _z_ring_iterator_t;
#[doc = " Reverse iterator of a ring buffer."]
pub type _z_sample_ring_reverse_iterator_t = _z_ring_reverse_iterator_t;
pub const _z_reply_tag_t__Z_REPLY_TAG_DATA: _z_reply_tag_t = 0;
pub const _z_reply_tag_t__Z_REPLY_TAG_FINAL: _z_reply_tag_t = 1;
pub const _z_reply_tag_t__Z_REPLY_TAG_ERROR: _z_reply_tag_t = 2;
pub const _z_reply_tag_t__Z_REPLY_TAG_NONE: _z_reply_tag_t = 3;
#[doc = " Reply tag values.\n\n Enumerators:\n     _Z_REPLY_TAG_DATA: Tag identifying that the reply contains some data.\n     _Z_REPLY_TAG_FINAL: Tag identifying that the reply does not contain any data and that there will be no more\n         replies for this query.\n     _Z_REPLY_TAG_ERROR: Tag identifying that the reply contains error.\n     _Z_REPLY_TAG_NONE: Tag identifying empty reply."]
pub type _z_reply_tag_t = ::core::ffi::c_uint;
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_sample_t data: a :c:type:`_z_sample_t` containing the key and value of the reply.\n   _z_slice_t replier_id: The id of the entity that sent this reply.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_data_t {
    pub _result: _z_reply_data_t__bindgen_ty_1,
    pub replier_id: _z_entity_global_id_t,
    pub _tag: _z_reply_tag_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _z_reply_data_t__bindgen_ty_1 {
    pub error: _z_value_t,
    pub sample: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t__bindgen_ty_1"]
        [::core::mem::size_of::<_z_reply_data_t__bindgen_ty_1>() - 224usize];
    ["Alignment of _z_reply_data_t__bindgen_ty_1"]
        [::core::mem::align_of::<_z_reply_data_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::error"]
        [::core::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, error) - 0usize];
    ["Offset of field: _z_reply_data_t__bindgen_ty_1::sample"]
        [::core::mem::offset_of!(_z_reply_data_t__bindgen_ty_1, sample) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_data_t"][::core::mem::size_of::<_z_reply_data_t>() - 248usize];
    ["Alignment of _z_reply_data_t"][::core::mem::align_of::<_z_reply_data_t>() - 8usize];
    ["Offset of field: _z_reply_data_t::_result"]
        [::core::mem::offset_of!(_z_reply_data_t, _result) - 0usize];
    ["Offset of field: _z_reply_data_t::replier_id"]
        [::core::mem::offset_of!(_z_reply_data_t, replier_id) - 224usize];
    ["Offset of field: _z_reply_data_t::_tag"]
        [::core::mem::offset_of!(_z_reply_data_t, _tag) - 244usize];
};
unsafe extern "C" {
    pub fn _z_reply_data_clear(rd: *mut _z_reply_data_t);
}
unsafe extern "C" {
    pub fn _z_reply_data_copy(dst: *mut _z_reply_data_t, src: *const _z_reply_data_t)
    -> z_result_t;
}
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_reply_t_Tag tag: Indicates if the reply contains data or if it's a FINAL reply.\n   _z_reply_data_t data: The reply data if :c:member:`_z_reply_t.tag` equals\n :c:member:`_z_reply_t_Tag._Z_REPLY_TAG_DATA`.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_reply_t {
    pub data: _z_reply_data_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_reply_t"][::core::mem::size_of::<_z_reply_t>() - 248usize];
    ["Alignment of _z_reply_t"][::core::mem::align_of::<_z_reply_t>() - 8usize];
    ["Offset of field: _z_reply_t::data"][::core::mem::offset_of!(_z_reply_t, data) - 0usize];
};
unsafe extern "C" {
    pub fn _z_reply_steal_data(
        dst: *mut _z_reply_t,
        keyexpr: *mut _z_keyexpr_t,
        replier_id: _z_entity_global_id_t,
        payload: *mut _z_bytes_t,
        timestamp: *const _z_timestamp_t,
        encoding: *mut _z_encoding_t,
        kind: z_sample_kind_t,
        attachment: *mut _z_bytes_t,
        source_info: *mut _z_source_info_t,
    );
}
unsafe extern "C" {
    pub fn _z_reply_err_steal_data(
        dst: *mut _z_reply_t,
        payload: *mut _z_bytes_t,
        encoding: *mut _z_encoding_t,
        replier_id: _z_entity_global_id_t,
    );
}
unsafe extern "C" {
    pub fn _z_reply_move(dst: *mut _z_reply_t, src: *mut _z_reply_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_reply_clear(src: *mut _z_reply_t);
}
unsafe extern "C" {
    pub fn _z_reply_free(hello: *mut *mut _z_reply_t);
}
unsafe extern "C" {
    pub fn _z_reply_copy(dst: *mut _z_reply_t, src: *const _z_reply_t) -> z_result_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _z_pending_reply_t {
    pub _reply: _z_reply_t,
    pub _tstamp: _z_timestamp_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_pending_reply_t"][::core::mem::size_of::<_z_pending_reply_t>() - 280usize];
    ["Alignment of _z_pending_reply_t"][::core::mem::align_of::<_z_pending_reply_t>() - 8usize];
    ["Offset of field: _z_pending_reply_t::_reply"]
        [::core::mem::offset_of!(_z_pending_reply_t, _reply) - 0usize];
    ["Offset of field: _z_pending_reply_t::_tstamp"]
        [::core::mem::offset_of!(_z_pending_reply_t, _tstamp) - 248usize];
};
unsafe extern "C" {
    pub fn _z_pending_reply_eq(
        one: *const _z_pending_reply_t,
        two: *const _z_pending_reply_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn _z_pending_reply_clear(res: *mut _z_pending_reply_t);
}
pub type _z_pending_reply_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _z_pending_reply_t, right: *const _z_pending_reply_t) -> bool,
>;
pub type _z_pending_reply_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _z_pending_reply_t,
        right: *const _z_pending_reply_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " Return type when declaring a subscriber."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_subscriber_t {
    pub _entity_id: u32,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_subscriber_t"][::core::mem::size_of::<_z_subscriber_t>() - 24usize];
    ["Alignment of _z_subscriber_t"][::core::mem::align_of::<_z_subscriber_t>() - 8usize];
    ["Offset of field: _z_subscriber_t::_entity_id"]
        [::core::mem::offset_of!(_z_subscriber_t, _entity_id) - 0usize];
    ["Offset of field: _z_subscriber_t::_zn"]
        [::core::mem::offset_of!(_z_subscriber_t, _zn) - 8usize];
};
unsafe extern "C" {
    pub fn _z_subscriber_clear(sub: *mut _z_subscriber_t);
}
unsafe extern "C" {
    pub fn _z_subscriber_free(sub: *mut *mut _z_subscriber_t);
}
#[doc = " Represents a Zenoh ID.\n\n In general, valid Zenoh IDs are LSB-first 128bit unsigned and non-zero integers.\n\n Members:\n   uint8_t id[16]: The array containing the 16 octets of a Zenoh ID."]
pub type z_id_t = _z_id_t;
#[doc = "  Represents an ID globally identifying an entity in a Zenoh system."]
pub type z_entity_global_id_t = _z_entity_global_id_t;
#[doc = " A zenoh timestamp."]
pub type z_timestamp_t = _z_timestamp_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_slice_t {
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_slice_t"][::core::mem::size_of::<z_owned_slice_t>() - 32usize];
    ["Alignment of z_owned_slice_t"][::core::mem::align_of::<z_owned_slice_t>() - 8usize];
    ["Offset of field: z_owned_slice_t::_val"]
        [::core::mem::offset_of!(z_owned_slice_t, _val) - 0usize];
};
#[doc = " An array of bytes.\n\n Members:\n   size_t len: The length of the bytes array.\n   uint8_t *start: A pointer to the bytes array.\n   _z_delete_context_t delete_context - context used to delete the data."]
pub type z_loaned_slice_t = _z_slice_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_slice_t {
    pub _this: z_owned_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_slice_t"][::core::mem::size_of::<z_moved_slice_t>() - 32usize];
    ["Alignment of z_moved_slice_t"][::core::mem::align_of::<z_moved_slice_t>() - 8usize];
    ["Offset of field: z_moved_slice_t::_this"]
        [::core::mem::offset_of!(z_moved_slice_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_slice_t {
    pub _val: _z_slice_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_slice_t"][::core::mem::size_of::<z_view_slice_t>() - 32usize];
    ["Alignment of z_view_slice_t"][::core::mem::align_of::<z_view_slice_t>() - 8usize];
    ["Offset of field: z_view_slice_t::_val"]
        [::core::mem::offset_of!(z_view_slice_t, _val) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_t {
    pub _val: _z_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_t"][::core::mem::size_of::<z_owned_bytes_t>() - 32usize];
    ["Alignment of z_owned_bytes_t"][::core::mem::align_of::<z_owned_bytes_t>() - 8usize];
    ["Offset of field: z_owned_bytes_t::_val"]
        [::core::mem::offset_of!(z_owned_bytes_t, _val) - 0usize];
};
#[doc = " A container for slices.\n\n Members:\n   _z_slice_vec_t _slices: contents of the container."]
pub type z_loaned_bytes_t = _z_bytes_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_t {
    pub _this: z_owned_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_t"][::core::mem::size_of::<z_moved_bytes_t>() - 32usize];
    ["Alignment of z_moved_bytes_t"][::core::mem::align_of::<z_moved_bytes_t>() - 8usize];
    ["Offset of field: z_moved_bytes_t::_this"]
        [::core::mem::offset_of!(z_moved_bytes_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_bytes_writer_t {
    pub _val: _z_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_bytes_writer_t"][::core::mem::size_of::<z_owned_bytes_writer_t>() - 40usize];
    ["Alignment of z_owned_bytes_writer_t"]
        [::core::mem::align_of::<z_owned_bytes_writer_t>() - 8usize];
    ["Offset of field: z_owned_bytes_writer_t::_val"]
        [::core::mem::offset_of!(z_owned_bytes_writer_t, _val) - 0usize];
};
pub type z_loaned_bytes_writer_t = _z_bytes_writer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_bytes_writer_t {
    pub _this: z_owned_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_bytes_writer_t"][::core::mem::size_of::<z_moved_bytes_writer_t>() - 40usize];
    ["Alignment of z_moved_bytes_writer_t"]
        [::core::mem::align_of::<z_moved_bytes_writer_t>() - 8usize];
    ["Offset of field: z_moved_bytes_writer_t::_this"]
        [::core::mem::offset_of!(z_moved_bytes_writer_t, _this) - 0usize];
};
#[doc = " A reader for data."]
pub type z_bytes_reader_t = _z_bytes_reader_t;
#[doc = " An iterator over slices of data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_bytes_slice_iterator_t {
    pub _bytes: *const _z_bytes_t,
    pub _slice_idx: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_bytes_slice_iterator_t"]
        [::core::mem::size_of::<z_bytes_slice_iterator_t>() - 16usize];
    ["Alignment of z_bytes_slice_iterator_t"]
        [::core::mem::align_of::<z_bytes_slice_iterator_t>() - 8usize];
    ["Offset of field: z_bytes_slice_iterator_t::_bytes"]
        [::core::mem::offset_of!(z_bytes_slice_iterator_t, _bytes) - 0usize];
    ["Offset of field: z_bytes_slice_iterator_t::_slice_idx"]
        [::core::mem::offset_of!(z_bytes_slice_iterator_t, _slice_idx) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_t {
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_t"][::core::mem::size_of::<z_owned_string_t>() - 32usize];
    ["Alignment of z_owned_string_t"][::core::mem::align_of::<z_owned_string_t>() - 8usize];
    ["Offset of field: z_owned_string_t::_val"]
        [::core::mem::offset_of!(z_owned_string_t, _val) - 0usize];
};
#[doc = " A string with no terminator.\n"]
pub type z_loaned_string_t = _z_string_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_t {
    pub _this: z_owned_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_t"][::core::mem::size_of::<z_moved_string_t>() - 32usize];
    ["Alignment of z_moved_string_t"][::core::mem::align_of::<z_moved_string_t>() - 8usize];
    ["Offset of field: z_moved_string_t::_this"]
        [::core::mem::offset_of!(z_moved_string_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_string_t {
    pub _val: _z_string_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_string_t"][::core::mem::size_of::<z_view_string_t>() - 32usize];
    ["Alignment of z_view_string_t"][::core::mem::align_of::<z_view_string_t>() - 8usize];
    ["Offset of field: z_view_string_t::_val"]
        [::core::mem::offset_of!(z_view_string_t, _val) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_keyexpr_t {
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_keyexpr_t"][::core::mem::size_of::<z_owned_keyexpr_t>() - 48usize];
    ["Alignment of z_owned_keyexpr_t"][::core::mem::align_of::<z_owned_keyexpr_t>() - 8usize];
    ["Offset of field: z_owned_keyexpr_t::_val"]
        [::core::mem::offset_of!(z_owned_keyexpr_t, _val) - 0usize];
};
pub type z_loaned_keyexpr_t = _z_keyexpr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_keyexpr_t {
    pub _this: z_owned_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_keyexpr_t"][::core::mem::size_of::<z_moved_keyexpr_t>() - 48usize];
    ["Alignment of z_moved_keyexpr_t"][::core::mem::align_of::<z_moved_keyexpr_t>() - 8usize];
    ["Offset of field: z_moved_keyexpr_t::_this"]
        [::core::mem::offset_of!(z_moved_keyexpr_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_view_keyexpr_t {
    pub _val: _z_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_view_keyexpr_t"][::core::mem::size_of::<z_view_keyexpr_t>() - 48usize];
    ["Alignment of z_view_keyexpr_t"][::core::mem::align_of::<z_view_keyexpr_t>() - 8usize];
    ["Offset of field: z_view_keyexpr_t::_val"]
        [::core::mem::offset_of!(z_view_keyexpr_t, _val) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_config_t {
    pub _val: _z_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_config_t"][::core::mem::size_of::<z_owned_config_t>() - 32usize];
    ["Alignment of z_owned_config_t"][::core::mem::align_of::<z_owned_config_t>() - 8usize];
    ["Offset of field: z_owned_config_t::_val"]
        [::core::mem::offset_of!(z_owned_config_t, _val) - 0usize];
};
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type z_loaned_config_t = _z_config_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_config_t {
    pub _this: z_owned_config_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_config_t"][::core::mem::size_of::<z_moved_config_t>() - 32usize];
    ["Alignment of z_moved_config_t"][::core::mem::align_of::<z_moved_config_t>() - 8usize];
    ["Offset of field: z_moved_config_t::_this"]
        [::core::mem::offset_of!(z_moved_config_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_session_t {
    pub _rc: _z_session_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_session_t"][::core::mem::size_of::<z_owned_session_t>() - 16usize];
    ["Alignment of z_owned_session_t"][::core::mem::align_of::<z_owned_session_t>() - 8usize];
    ["Offset of field: z_owned_session_t::_rc"]
        [::core::mem::offset_of!(z_owned_session_t, _rc) - 0usize];
};
pub type z_loaned_session_t = _z_session_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_session_t {
    pub _this: z_owned_session_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_session_t"][::core::mem::size_of::<z_moved_session_t>() - 16usize];
    ["Alignment of z_moved_session_t"][::core::mem::align_of::<z_moved_session_t>() - 8usize];
    ["Offset of field: z_moved_session_t::_this"]
        [::core::mem::offset_of!(z_moved_session_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_subscriber_t {
    pub _val: _z_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_subscriber_t"][::core::mem::size_of::<z_owned_subscriber_t>() - 24usize];
    ["Alignment of z_owned_subscriber_t"][::core::mem::align_of::<z_owned_subscriber_t>() - 8usize];
    ["Offset of field: z_owned_subscriber_t::_val"]
        [::core::mem::offset_of!(z_owned_subscriber_t, _val) - 0usize];
};
#[doc = " Return type when declaring a subscriber."]
pub type z_loaned_subscriber_t = _z_subscriber_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_subscriber_t {
    pub _this: z_owned_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_subscriber_t"][::core::mem::size_of::<z_moved_subscriber_t>() - 24usize];
    ["Alignment of z_moved_subscriber_t"][::core::mem::align_of::<z_moved_subscriber_t>() - 8usize];
    ["Offset of field: z_moved_subscriber_t::_this"]
        [::core::mem::offset_of!(z_moved_subscriber_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_publisher_t {
    pub _val: _z_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_publisher_t"][::core::mem::size_of::<z_owned_publisher_t>() - 144usize];
    ["Alignment of z_owned_publisher_t"][::core::mem::align_of::<z_owned_publisher_t>() - 8usize];
    ["Offset of field: z_owned_publisher_t::_val"]
        [::core::mem::offset_of!(z_owned_publisher_t, _val) - 0usize];
};
#[doc = " Return type when declaring a publisher."]
pub type z_loaned_publisher_t = _z_publisher_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_publisher_t {
    pub _this: z_owned_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_publisher_t"][::core::mem::size_of::<z_moved_publisher_t>() - 144usize];
    ["Alignment of z_moved_publisher_t"][::core::mem::align_of::<z_moved_publisher_t>() - 8usize];
    ["Offset of field: z_moved_publisher_t::_this"]
        [::core::mem::offset_of!(z_moved_publisher_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_querier_t {
    pub _val: _z_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_querier_t"][::core::mem::size_of::<z_owned_querier_t>() - 160usize];
    ["Alignment of z_owned_querier_t"][::core::mem::align_of::<z_owned_querier_t>() - 8usize];
    ["Offset of field: z_owned_querier_t::_val"]
        [::core::mem::offset_of!(z_owned_querier_t, _val) - 0usize];
};
#[doc = " Return type when declaring a querier."]
pub type z_loaned_querier_t = _z_querier_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_querier_t {
    pub _this: z_owned_querier_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_querier_t"][::core::mem::size_of::<z_moved_querier_t>() - 160usize];
    ["Alignment of z_moved_querier_t"][::core::mem::align_of::<z_moved_querier_t>() - 8usize];
    ["Offset of field: z_moved_querier_t::_this"]
        [::core::mem::offset_of!(z_moved_querier_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_matching_listener_t {
    pub _val: _z_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_matching_listener_t"]
        [::core::mem::size_of::<z_owned_matching_listener_t>() - 24usize];
    ["Alignment of z_owned_matching_listener_t"]
        [::core::mem::align_of::<z_owned_matching_listener_t>() - 8usize];
    ["Offset of field: z_owned_matching_listener_t::_val"]
        [::core::mem::offset_of!(z_owned_matching_listener_t, _val) - 0usize];
};
pub type z_loaned_matching_listener_t = _z_matching_listener_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_matching_listener_t {
    pub _this: z_owned_matching_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_matching_listener_t"]
        [::core::mem::size_of::<z_moved_matching_listener_t>() - 24usize];
    ["Alignment of z_moved_matching_listener_t"]
        [::core::mem::align_of::<z_moved_matching_listener_t>() - 8usize];
    ["Offset of field: z_moved_matching_listener_t::_this"]
        [::core::mem::offset_of!(z_moved_matching_listener_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_queryable_t {
    pub _val: _z_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_queryable_t"][::core::mem::size_of::<z_owned_queryable_t>() - 24usize];
    ["Alignment of z_owned_queryable_t"][::core::mem::align_of::<z_owned_queryable_t>() - 8usize];
    ["Offset of field: z_owned_queryable_t::_val"]
        [::core::mem::offset_of!(z_owned_queryable_t, _val) - 0usize];
};
#[doc = " Return type when declaring a queryable."]
pub type z_loaned_queryable_t = _z_queryable_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_queryable_t {
    pub _this: z_owned_queryable_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_queryable_t"][::core::mem::size_of::<z_moved_queryable_t>() - 24usize];
    ["Alignment of z_moved_queryable_t"][::core::mem::align_of::<z_moved_queryable_t>() - 8usize];
    ["Offset of field: z_moved_queryable_t::_this"]
        [::core::mem::offset_of!(z_moved_queryable_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_query_t {
    pub _rc: _z_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_query_t"][::core::mem::size_of::<z_owned_query_t>() - 16usize];
    ["Alignment of z_owned_query_t"][::core::mem::align_of::<z_owned_query_t>() - 8usize];
    ["Offset of field: z_owned_query_t::_rc"]
        [::core::mem::offset_of!(z_owned_query_t, _rc) - 0usize];
};
pub type z_loaned_query_t = _z_query_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_query_t {
    pub _this: z_owned_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_query_t"][::core::mem::size_of::<z_moved_query_t>() - 16usize];
    ["Alignment of z_moved_query_t"][::core::mem::align_of::<z_moved_query_t>() - 8usize];
    ["Offset of field: z_moved_query_t::_this"]
        [::core::mem::offset_of!(z_moved_query_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_encoding_t {
    pub _val: _z_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_encoding_t"][::core::mem::size_of::<z_owned_encoding_t>() - 40usize];
    ["Alignment of z_owned_encoding_t"][::core::mem::align_of::<z_owned_encoding_t>() - 8usize];
    ["Offset of field: z_owned_encoding_t::_val"]
        [::core::mem::offset_of!(z_owned_encoding_t, _val) - 0usize];
};
#[doc = " A zenoh encoding."]
pub type z_loaned_encoding_t = _z_encoding_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_encoding_t {
    pub _this: z_owned_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_encoding_t"][::core::mem::size_of::<z_moved_encoding_t>() - 40usize];
    ["Alignment of z_moved_encoding_t"][::core::mem::align_of::<z_moved_encoding_t>() - 8usize];
    ["Offset of field: z_moved_encoding_t::_this"]
        [::core::mem::offset_of!(z_moved_encoding_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_reply_err_t {
    pub _val: _z_value_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_err_t"][::core::mem::size_of::<z_owned_reply_err_t>() - 72usize];
    ["Alignment of z_owned_reply_err_t"][::core::mem::align_of::<z_owned_reply_err_t>() - 8usize];
    ["Offset of field: z_owned_reply_err_t::_val"]
        [::core::mem::offset_of!(z_owned_reply_err_t, _val) - 0usize];
};
#[doc = " Represents a Zenoh value.\n\n Members:\n   _z_bytes_t payload: The payload of this zenoh value.\n   _z_encoding_t encoding: The encoding of the `payload`."]
pub type z_loaned_reply_err_t = _z_value_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_reply_err_t {
    pub _this: z_owned_reply_err_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_err_t"][::core::mem::size_of::<z_moved_reply_err_t>() - 72usize];
    ["Alignment of z_moved_reply_err_t"][::core::mem::align_of::<z_moved_reply_err_t>() - 8usize];
    ["Offset of field: z_moved_reply_err_t::_this"]
        [::core::mem::offset_of!(z_moved_reply_err_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_source_info_t {
    pub _val: _z_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_source_info_t"][::core::mem::size_of::<z_owned_source_info_t>() - 24usize];
    ["Alignment of z_owned_source_info_t"]
        [::core::mem::align_of::<z_owned_source_info_t>() - 4usize];
    ["Offset of field: z_owned_source_info_t::_val"]
        [::core::mem::offset_of!(z_owned_source_info_t, _val) - 0usize];
};
pub type z_loaned_source_info_t = _z_source_info_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_source_info_t {
    pub _this: z_owned_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_source_info_t"][::core::mem::size_of::<z_moved_source_info_t>() - 24usize];
    ["Alignment of z_moved_source_info_t"]
        [::core::mem::align_of::<z_moved_source_info_t>() - 4usize];
    ["Offset of field: z_moved_source_info_t::_this"]
        [::core::mem::offset_of!(z_moved_source_info_t, _this) - 0usize];
};
#[doc = " A struct that indicates if there exist Subscribers matching the Publisher's key expression or Queryables matching\n Querier's key expression and target.\n Members:\n   bool matching: true if there exist matching Zenoh entities, false otherwise."]
pub type z_matching_status_t = _z_matching_status_t;
#[doc = " Represents the configuration used to configure a subscriber upon declaration :c:func:`z_declare_subscriber`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_subscriber_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_subscriber_options_t"][::core::mem::size_of::<z_subscriber_options_t>() - 1usize];
    ["Alignment of z_subscriber_options_t"]
        [::core::mem::align_of::<z_subscriber_options_t>() - 1usize];
    ["Offset of field: z_subscriber_options_t::__dummy"]
        [::core::mem::offset_of!(z_subscriber_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon opening :c:func:`z_open`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_open_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_open_options_t"][::core::mem::size_of::<z_open_options_t>() - 1usize];
    ["Alignment of z_open_options_t"][::core::mem::align_of::<z_open_options_t>() - 1usize];
    ["Offset of field: z_open_options_t::__dummy"]
        [::core::mem::offset_of!(z_open_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a zenoh upon closing :c:func:`z_close`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_close_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_close_options_t"][::core::mem::size_of::<z_close_options_t>() - 1usize];
    ["Alignment of z_close_options_t"][::core::mem::align_of::<z_close_options_t>() - 1usize];
    ["Offset of field: z_close_options_t::__dummy"]
        [::core::mem::offset_of!(z_close_options_t, __dummy) - 0usize];
};
#[doc = " Represents the reply consolidation mode to apply on replies to a :c:func:`z_get`.\n\n Members:\n   z_consolidation_mode_t mode: the consolidation mode, see :c:type:`z_consolidation_mode_t`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_consolidation_t {
    pub mode: z_consolidation_mode_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_consolidation_t"][::core::mem::size_of::<z_query_consolidation_t>() - 4usize];
    ["Alignment of z_query_consolidation_t"]
        [::core::mem::align_of::<z_query_consolidation_t>() - 4usize];
    ["Offset of field: z_query_consolidation_t::mode"]
        [::core::mem::offset_of!(z_query_consolidation_t, mode) - 0usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for messages put by this publisher.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing messages from this\n     publisher.\n   z_priority_t priority: The priority of messages issued by this publisher.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub reliability: z_reliability_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_options_t"][::core::mem::size_of::<z_publisher_options_t>() - 24usize];
    ["Alignment of z_publisher_options_t"]
        [::core::mem::align_of::<z_publisher_options_t>() - 8usize];
    ["Offset of field: z_publisher_options_t::encoding"]
        [::core::mem::offset_of!(z_publisher_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_options_t::congestion_control"]
        [::core::mem::offset_of!(z_publisher_options_t, congestion_control) - 8usize];
    ["Offset of field: z_publisher_options_t::priority"]
        [::core::mem::offset_of!(z_publisher_options_t, priority) - 12usize];
    ["Offset of field: z_publisher_options_t::is_express"]
        [::core::mem::offset_of!(z_publisher_options_t, is_express) - 16usize];
    ["Offset of field: z_publisher_options_t::reliability"]
        [::core::mem::offset_of!(z_publisher_options_t, reliability) - 20usize];
};
#[doc = " Options passed to the :c:func:`z_declare_querier()` function.\n\n Members:\n   z_moved_encoding_t *encoding: Default encoding for values sent by this querier.\n   z_query_target_t target: The Queryables that should be target of the querier queries.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies to the querier\n    queries.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the querier queries.\n   bool is_express: If set to ``true``, the querier queries will not be batched. This usually has a positive impact on\n \t   latency but negative impact on throughput.\n   z_priority_t priority: The priority of the querier queries.\n   uint64_t timeout_ms: The timeout for the querier queries in milliseconds. 0 means default query timeout from zenoh\n     configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub target: z_query_target_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub is_express: bool,
    pub priority: z_priority_t,
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_options_t"][::core::mem::size_of::<z_querier_options_t>() - 40usize];
    ["Alignment of z_querier_options_t"][::core::mem::align_of::<z_querier_options_t>() - 8usize];
    ["Offset of field: z_querier_options_t::encoding"]
        [::core::mem::offset_of!(z_querier_options_t, encoding) - 0usize];
    ["Offset of field: z_querier_options_t::target"]
        [::core::mem::offset_of!(z_querier_options_t, target) - 8usize];
    ["Offset of field: z_querier_options_t::consolidation"]
        [::core::mem::offset_of!(z_querier_options_t, consolidation) - 12usize];
    ["Offset of field: z_querier_options_t::congestion_control"]
        [::core::mem::offset_of!(z_querier_options_t, congestion_control) - 16usize];
    ["Offset of field: z_querier_options_t::is_express"]
        [::core::mem::offset_of!(z_querier_options_t, is_express) - 20usize];
    ["Offset of field: z_querier_options_t::priority"]
        [::core::mem::offset_of!(z_querier_options_t, priority) - 24usize];
    ["Offset of field: z_querier_options_t::timeout_ms"]
        [::core::mem::offset_of!(z_querier_options_t, timeout_ms) - 32usize];
};
#[doc = " Options passed to the :c:func:`z_querier_get()` function.\n\n Members:\n   z_moved_bytes_t *payload: An optional payload to attach to the query.\n   z_moved_encoding_t *encoding: An optional encoding of the query payload and or attachment.\n   z_moved_bytes_t *attachment: An optional attachment to attach to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_querier_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_querier_get_options_t"]
        [::core::mem::size_of::<z_querier_get_options_t>() - 24usize];
    ["Alignment of z_querier_get_options_t"]
        [::core::mem::align_of::<z_querier_get_options_t>() - 8usize];
    ["Offset of field: z_querier_get_options_t::payload"]
        [::core::mem::offset_of!(z_querier_get_options_t, payload) - 0usize];
    ["Offset of field: z_querier_get_options_t::encoding"]
        [::core::mem::offset_of!(z_querier_get_options_t, encoding) - 8usize];
    ["Offset of field: z_querier_get_options_t::attachment"]
        [::core::mem::offset_of!(z_querier_get_options_t, attachment) - 16usize];
};
#[doc = " Represents the configuration used to configure a queryable upon declaration :c:func:`z_declare_queryable`.\n\n Members:\n   bool complete: The completeness of the queryable."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_queryable_options_t {
    pub complete: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_queryable_options_t"][::core::mem::size_of::<z_queryable_options_t>() - 1usize];
    ["Alignment of z_queryable_options_t"]
        [::core::mem::align_of::<z_queryable_options_t>() - 1usize];
    ["Offset of field: z_queryable_options_t::complete"]
        [::core::mem::offset_of!(z_queryable_options_t, complete) - 0usize];
};
#[doc = " Represents the configuration used to configure a query reply sent via :c:func:`z_query_reply`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_options_t"]
        [::core::mem::size_of::<z_query_reply_options_t>() - 48usize];
    ["Alignment of z_query_reply_options_t"]
        [::core::mem::align_of::<z_query_reply_options_t>() - 8usize];
    ["Offset of field: z_query_reply_options_t::encoding"]
        [::core::mem::offset_of!(z_query_reply_options_t, encoding) - 0usize];
    ["Offset of field: z_query_reply_options_t::congestion_control"]
        [::core::mem::offset_of!(z_query_reply_options_t, congestion_control) - 8usize];
    ["Offset of field: z_query_reply_options_t::priority"]
        [::core::mem::offset_of!(z_query_reply_options_t, priority) - 12usize];
    ["Offset of field: z_query_reply_options_t::timestamp"]
        [::core::mem::offset_of!(z_query_reply_options_t, timestamp) - 16usize];
    ["Offset of field: z_query_reply_options_t::is_express"]
        [::core::mem::offset_of!(z_query_reply_options_t, is_express) - 24usize];
    ["Offset of field: z_query_reply_options_t::attachment"]
        [::core::mem::offset_of!(z_query_reply_options_t, attachment) - 32usize];
    ["Offset of field: z_query_reply_options_t::source_info"]
        [::core::mem::offset_of!(z_query_reply_options_t, source_info) - 40usize];
};
#[doc = " Represents the configuration used to configure a query reply delete sent via :c:func:`z_query_reply_del`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the response.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_del_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_del_options_t"]
        [::core::mem::size_of::<z_query_reply_del_options_t>() - 40usize];
    ["Alignment of z_query_reply_del_options_t"]
        [::core::mem::align_of::<z_query_reply_del_options_t>() - 8usize];
    ["Offset of field: z_query_reply_del_options_t::congestion_control"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, congestion_control) - 0usize];
    ["Offset of field: z_query_reply_del_options_t::priority"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, priority) - 4usize];
    ["Offset of field: z_query_reply_del_options_t::timestamp"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, timestamp) - 8usize];
    ["Offset of field: z_query_reply_del_options_t::is_express"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, is_express) - 16usize];
    ["Offset of field: z_query_reply_del_options_t::attachment"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, attachment) - 24usize];
    ["Offset of field: z_query_reply_del_options_t::source_info"]
        [::core::mem::offset_of!(z_query_reply_del_options_t, source_info) - 32usize];
};
#[doc = " Represents the configuration used to configure a query reply error sent via :c:func:`z_query_reply_err`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_query_reply_err_options_t {
    pub encoding: *mut z_moved_encoding_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_query_reply_err_options_t"]
        [::core::mem::size_of::<z_query_reply_err_options_t>() - 8usize];
    ["Alignment of z_query_reply_err_options_t"]
        [::core::mem::align_of::<z_query_reply_err_options_t>() - 8usize];
    ["Offset of field: z_query_reply_err_options_t::encoding"]
        [::core::mem::offset_of!(z_query_reply_err_options_t, encoding) - 0usize];
};
#[doc = " Represents the configuration used to configure a put operation sent via :c:func:`z_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when routed.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub timestamp: *mut z_timestamp_t,
    pub is_express: bool,
    pub attachment: *mut z_moved_bytes_t,
    pub reliability: z_reliability_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_put_options_t"][::core::mem::size_of::<z_put_options_t>() - 56usize];
    ["Alignment of z_put_options_t"][::core::mem::align_of::<z_put_options_t>() - 8usize];
    ["Offset of field: z_put_options_t::encoding"]
        [::core::mem::offset_of!(z_put_options_t, encoding) - 0usize];
    ["Offset of field: z_put_options_t::congestion_control"]
        [::core::mem::offset_of!(z_put_options_t, congestion_control) - 8usize];
    ["Offset of field: z_put_options_t::priority"]
        [::core::mem::offset_of!(z_put_options_t, priority) - 12usize];
    ["Offset of field: z_put_options_t::timestamp"]
        [::core::mem::offset_of!(z_put_options_t, timestamp) - 16usize];
    ["Offset of field: z_put_options_t::is_express"]
        [::core::mem::offset_of!(z_put_options_t, is_express) - 24usize];
    ["Offset of field: z_put_options_t::attachment"]
        [::core::mem::offset_of!(z_put_options_t, attachment) - 32usize];
    ["Offset of field: z_put_options_t::reliability"]
        [::core::mem::offset_of!(z_put_options_t, reliability) - 40usize];
    ["Offset of field: z_put_options_t::source_info"]
        [::core::mem::offset_of!(z_put_options_t, source_info) - 48usize];
};
#[doc = " Represents the configuration used to configure a delete operation sent via :c:func:`z_delete`.\n\n Members:\n   z_congestion_control_t congestion_control: The congestion control to apply when routing this message.\n   z_priority_t priority: The priority of this message when router.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_reliability_t reliability: The reliability that should be used to transmit the data (unstable).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_delete_options_t {
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub timestamp: *mut z_timestamp_t,
    pub reliability: z_reliability_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_delete_options_t"][::core::mem::size_of::<z_delete_options_t>() - 40usize];
    ["Alignment of z_delete_options_t"][::core::mem::align_of::<z_delete_options_t>() - 8usize];
    ["Offset of field: z_delete_options_t::congestion_control"]
        [::core::mem::offset_of!(z_delete_options_t, congestion_control) - 0usize];
    ["Offset of field: z_delete_options_t::priority"]
        [::core::mem::offset_of!(z_delete_options_t, priority) - 4usize];
    ["Offset of field: z_delete_options_t::is_express"]
        [::core::mem::offset_of!(z_delete_options_t, is_express) - 8usize];
    ["Offset of field: z_delete_options_t::timestamp"]
        [::core::mem::offset_of!(z_delete_options_t, timestamp) - 16usize];
    ["Offset of field: z_delete_options_t::reliability"]
        [::core::mem::offset_of!(z_delete_options_t, reliability) - 24usize];
    ["Offset of field: z_delete_options_t::source_info"]
        [::core::mem::offset_of!(z_delete_options_t, source_info) - 32usize];
};
#[doc = " Represents the configuration used to configure a put operation by a previously declared publisher,\n sent via :c:func:`z_publisher_put`.\n\n Members:\n   z_moved_encoding_t* encoding: The encoding of the payload.\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_bytes_t* attachment: An optional attachment to the publication.\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_put_options_t {
    pub encoding: *mut z_moved_encoding_t,
    pub timestamp: *mut z_timestamp_t,
    pub attachment: *mut z_moved_bytes_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_put_options_t"]
        [::core::mem::size_of::<z_publisher_put_options_t>() - 32usize];
    ["Alignment of z_publisher_put_options_t"]
        [::core::mem::align_of::<z_publisher_put_options_t>() - 8usize];
    ["Offset of field: z_publisher_put_options_t::encoding"]
        [::core::mem::offset_of!(z_publisher_put_options_t, encoding) - 0usize];
    ["Offset of field: z_publisher_put_options_t::timestamp"]
        [::core::mem::offset_of!(z_publisher_put_options_t, timestamp) - 8usize];
    ["Offset of field: z_publisher_put_options_t::attachment"]
        [::core::mem::offset_of!(z_publisher_put_options_t, attachment) - 16usize];
    ["Offset of field: z_publisher_put_options_t::source_info"]
        [::core::mem::offset_of!(z_publisher_put_options_t, source_info) - 24usize];
};
#[doc = " Represents the configuration used to configure a delete operation by a previously declared publisher,\n sent via :c:func:`z_publisher_delete`.\n\n Members:\n   z_timestamp_t *timestamp: The API level timestamp (e.g. of the data when it was created).\n   z_moved_source_info_t* source_info: The source info for the message (unstable)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_publisher_delete_options_t {
    pub timestamp: *mut z_timestamp_t,
    pub source_info: *mut z_moved_source_info_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_publisher_delete_options_t"]
        [::core::mem::size_of::<z_publisher_delete_options_t>() - 16usize];
    ["Alignment of z_publisher_delete_options_t"]
        [::core::mem::align_of::<z_publisher_delete_options_t>() - 8usize];
    ["Offset of field: z_publisher_delete_options_t::timestamp"]
        [::core::mem::offset_of!(z_publisher_delete_options_t, timestamp) - 0usize];
    ["Offset of field: z_publisher_delete_options_t::source_info"]
        [::core::mem::offset_of!(z_publisher_delete_options_t, source_info) - 8usize];
};
#[doc = " Represents the configuration used to configure a get operation sent via :c:func:`z_get`.\n\n Members:\n   z_moved_bytes_t* payload: The payload to include in the query.\n   z_moved_encoding_t* encoding: Payload encoding.\n   z_query_consolidation_t consolidation: The replies consolidation strategy to apply on replies.\n   z_congestion_control_t congestion_control: The congestion control to apply when routing the query.\n   z_priority_t priority: The priority of the query.\n   bool is_express: If ``true``, Zenoh will not wait to batch this operation with others to reduce the bandwidth.\n   z_query_target_t target: The queryables that should be targeted by this get.\n   z_moved_bytes_t* attachment: An optional attachment to the query."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_get_options_t {
    pub payload: *mut z_moved_bytes_t,
    pub encoding: *mut z_moved_encoding_t,
    pub consolidation: z_query_consolidation_t,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub target: z_query_target_t,
    pub timeout_ms: u64,
    pub attachment: *mut z_moved_bytes_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_get_options_t"][::core::mem::size_of::<z_get_options_t>() - 56usize];
    ["Alignment of z_get_options_t"][::core::mem::align_of::<z_get_options_t>() - 8usize];
    ["Offset of field: z_get_options_t::payload"]
        [::core::mem::offset_of!(z_get_options_t, payload) - 0usize];
    ["Offset of field: z_get_options_t::encoding"]
        [::core::mem::offset_of!(z_get_options_t, encoding) - 8usize];
    ["Offset of field: z_get_options_t::consolidation"]
        [::core::mem::offset_of!(z_get_options_t, consolidation) - 16usize];
    ["Offset of field: z_get_options_t::congestion_control"]
        [::core::mem::offset_of!(z_get_options_t, congestion_control) - 20usize];
    ["Offset of field: z_get_options_t::priority"]
        [::core::mem::offset_of!(z_get_options_t, priority) - 24usize];
    ["Offset of field: z_get_options_t::is_express"]
        [::core::mem::offset_of!(z_get_options_t, is_express) - 28usize];
    ["Offset of field: z_get_options_t::target"]
        [::core::mem::offset_of!(z_get_options_t, target) - 32usize];
    ["Offset of field: z_get_options_t::timeout_ms"]
        [::core::mem::offset_of!(z_get_options_t, timeout_ms) - 40usize];
    ["Offset of field: z_get_options_t::attachment"]
        [::core::mem::offset_of!(z_get_options_t, attachment) - 48usize];
};
#[doc = " Represents the configuration used to configure a read task started via :c:func:`zp_start_read_task`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_task_read_options_t {
    pub task_attributes: *mut z_task_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_task_read_options_t"][::core::mem::size_of::<zp_task_read_options_t>() - 8usize];
    ["Alignment of zp_task_read_options_t"]
        [::core::mem::align_of::<zp_task_read_options_t>() - 8usize];
    ["Offset of field: zp_task_read_options_t::task_attributes"]
        [::core::mem::offset_of!(zp_task_read_options_t, task_attributes) - 0usize];
};
#[doc = " Represents the configuration used to configure a lease task started via :c:func:`zp_start_lease_task`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_task_lease_options_t {
    pub task_attributes: *mut z_task_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_task_lease_options_t"][::core::mem::size_of::<zp_task_lease_options_t>() - 8usize];
    ["Alignment of zp_task_lease_options_t"]
        [::core::mem::align_of::<zp_task_lease_options_t>() - 8usize];
    ["Offset of field: zp_task_lease_options_t::task_attributes"]
        [::core::mem::offset_of!(zp_task_lease_options_t, task_attributes) - 0usize];
};
#[doc = " Represents the configuration used to configure a read operation started via :c:func:`zp_read`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_read_options_t {
    pub single_read: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_read_options_t"][::core::mem::size_of::<zp_read_options_t>() - 1usize];
    ["Alignment of zp_read_options_t"][::core::mem::align_of::<zp_read_options_t>() - 1usize];
    ["Offset of field: zp_read_options_t::single_read"]
        [::core::mem::offset_of!(zp_read_options_t, single_read) - 0usize];
};
#[doc = " Represents the configuration used to configure a send keep alive operation started via :c:func:`zp_send_keep_alive`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_send_keep_alive_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_send_keep_alive_options_t"]
        [::core::mem::size_of::<zp_send_keep_alive_options_t>() - 1usize];
    ["Alignment of zp_send_keep_alive_options_t"]
        [::core::mem::align_of::<zp_send_keep_alive_options_t>() - 1usize];
    ["Offset of field: zp_send_keep_alive_options_t::__dummy"]
        [::core::mem::offset_of!(zp_send_keep_alive_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a send join operation started via :c:func:`zp_send_join`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zp_send_join_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of zp_send_join_options_t"][::core::mem::size_of::<zp_send_join_options_t>() - 1usize];
    ["Alignment of zp_send_join_options_t"]
        [::core::mem::align_of::<zp_send_join_options_t>() - 1usize];
    ["Offset of field: zp_send_join_options_t::__dummy"]
        [::core::mem::offset_of!(zp_send_join_options_t, __dummy) - 0usize];
};
#[doc = " Represents the configuration used to configure a publisher upon declaration with :c:func:`z_declare_publisher`.\n\n Members:\n   uint64_t timeout_ms: The maximum duration in ms the scouting can take.\n   z_what_t what: Type of entities to scout for."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_scout_options_t {
    pub timeout_ms: u32,
    pub what: z_what_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_scout_options_t"][::core::mem::size_of::<z_scout_options_t>() - 8usize];
    ["Alignment of z_scout_options_t"][::core::mem::align_of::<z_scout_options_t>() - 4usize];
    ["Offset of field: z_scout_options_t::timeout_ms"]
        [::core::mem::offset_of!(z_scout_options_t, timeout_ms) - 0usize];
    ["Offset of field: z_scout_options_t::what"]
        [::core::mem::offset_of!(z_scout_options_t, what) - 4usize];
};
#[doc = " Represents missed samples.\n\n Members:\n   source: The source of missed samples.\n   nb: The number of missed samples.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_miss_t {
    pub source: z_entity_global_id_t,
    pub nb: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_miss_t"][::core::mem::size_of::<ze_miss_t>() - 24usize];
    ["Alignment of ze_miss_t"][::core::mem::align_of::<ze_miss_t>() - 4usize];
    ["Offset of field: ze_miss_t::source"][::core::mem::offset_of!(ze_miss_t, source) - 0usize];
    ["Offset of field: ze_miss_t::nb"][::core::mem::offset_of!(ze_miss_t, nb) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_sample_t {
    pub _val: _z_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_sample_t"][::core::mem::size_of::<z_owned_sample_t>() - 224usize];
    ["Alignment of z_owned_sample_t"][::core::mem::align_of::<z_owned_sample_t>() - 8usize];
    ["Offset of field: z_owned_sample_t::_val"]
        [::core::mem::offset_of!(z_owned_sample_t, _val) - 0usize];
};
#[doc = " A zenoh-net data sample.\n\n A sample is the value associated to a given resource at a given point in time.\n\n Members:\n   _z_keyexpr_t key: The resource key of this data sample.\n   _z_slice_t value: The value of this data sample.\n   _z_encoding_t encoding: The encoding for the value of this data sample.\n   _z_source_info_t source_info: The source info for this data sample (unstable)."]
pub type z_loaned_sample_t = _z_sample_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_sample_t {
    pub _this: z_owned_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_sample_t"][::core::mem::size_of::<z_moved_sample_t>() - 224usize];
    ["Alignment of z_moved_sample_t"][::core::mem::align_of::<z_moved_sample_t>() - 8usize];
    ["Offset of field: z_moved_sample_t::_this"]
        [::core::mem::offset_of!(z_moved_sample_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_hello_t {
    pub _val: _z_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_hello_t"][::core::mem::size_of::<z_owned_hello_t>() - 56usize];
    ["Alignment of z_owned_hello_t"][::core::mem::align_of::<z_owned_hello_t>() - 8usize];
    ["Offset of field: z_owned_hello_t::_val"]
        [::core::mem::offset_of!(z_owned_hello_t, _val) - 0usize];
};
#[doc = " A hello message returned by a zenoh entity to a scout message sent with :c:func:`_z_scout`.\n\n Members:\n   _z_slice_t zid: The Zenoh ID of the scouted entity (empty if absent).\n   _z_string_vec_t locators: The locators of the scouted entity.\n   z_whatami_t whatami: The kind of zenoh entity."]
pub type z_loaned_hello_t = _z_hello_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_hello_t {
    pub _this: z_owned_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_hello_t"][::core::mem::size_of::<z_moved_hello_t>() - 56usize];
    ["Alignment of z_moved_hello_t"][::core::mem::align_of::<z_moved_hello_t>() - 8usize];
    ["Offset of field: z_moved_hello_t::_this"]
        [::core::mem::offset_of!(z_moved_hello_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_owned_reply_t {
    pub _val: _z_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_reply_t"][::core::mem::size_of::<z_owned_reply_t>() - 248usize];
    ["Alignment of z_owned_reply_t"][::core::mem::align_of::<z_owned_reply_t>() - 8usize];
    ["Offset of field: z_owned_reply_t::_val"]
        [::core::mem::offset_of!(z_owned_reply_t, _val) - 0usize];
};
#[doc = " An reply to a :c:func:`z_query`.\n\n Members:\n   _z_reply_t_Tag tag: Indicates if the reply contains data or if it's a FINAL reply.\n   _z_reply_data_t data: The reply data if :c:member:`_z_reply_t.tag` equals\n :c:member:`_z_reply_t_Tag._Z_REPLY_TAG_DATA`.\n"]
pub type z_loaned_reply_t = _z_reply_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_moved_reply_t {
    pub _this: z_owned_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_reply_t"][::core::mem::size_of::<z_moved_reply_t>() - 248usize];
    ["Alignment of z_moved_reply_t"][::core::mem::align_of::<z_moved_reply_t>() - 8usize];
    ["Offset of field: z_moved_reply_t::_this"]
        [::core::mem::offset_of!(z_moved_reply_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_string_array_t {
    pub _val: _z_string_svec_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_string_array_t"][::core::mem::size_of::<z_owned_string_array_t>() - 32usize];
    ["Alignment of z_owned_string_array_t"]
        [::core::mem::align_of::<z_owned_string_array_t>() - 8usize];
    ["Offset of field: z_owned_string_array_t::_val"]
        [::core::mem::offset_of!(z_owned_string_array_t, _val) - 0usize];
};
#[doc = " A dynamically allocated vector. Elements are stored by value."]
pub type z_loaned_string_array_t = _z_string_svec_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_string_array_t {
    pub _this: z_owned_string_array_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_string_array_t"][::core::mem::size_of::<z_moved_string_array_t>() - 32usize];
    ["Alignment of z_moved_string_array_t"]
        [::core::mem::align_of::<z_moved_string_array_t>() - 8usize];
    ["Offset of field: z_moved_string_array_t::_this"]
        [::core::mem::offset_of!(z_moved_string_array_t, _this) - 0usize];
};
#[doc = " Represents an array of non null-terminated string."]
pub type z_closure_drop_callback_t = _z_drop_handler_t;
pub type z_closure_sample_callback_t = _z_closure_sample_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_sample_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: z_closure_sample_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_sample_t"][::core::mem::size_of::<_z_closure_sample_t>() - 24usize];
    ["Alignment of _z_closure_sample_t"][::core::mem::align_of::<_z_closure_sample_t>() - 8usize];
    ["Offset of field: _z_closure_sample_t::context"]
        [::core::mem::offset_of!(_z_closure_sample_t, context) - 0usize];
    ["Offset of field: _z_closure_sample_t::call"]
        [::core::mem::offset_of!(_z_closure_sample_t, call) - 8usize];
    ["Offset of field: _z_closure_sample_t::drop"]
        [::core::mem::offset_of!(_z_closure_sample_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_sample_t {
    pub _val: _z_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_sample_t"]
        [::core::mem::size_of::<z_owned_closure_sample_t>() - 24usize];
    ["Alignment of z_owned_closure_sample_t"]
        [::core::mem::align_of::<z_owned_closure_sample_t>() - 8usize];
    ["Offset of field: z_owned_closure_sample_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_sample_t, _val) - 0usize];
};
pub type z_loaned_closure_sample_t = _z_closure_sample_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_sample_t {
    pub _this: z_owned_closure_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_sample_t"]
        [::core::mem::size_of::<z_moved_closure_sample_t>() - 24usize];
    ["Alignment of z_moved_closure_sample_t"]
        [::core::mem::align_of::<z_moved_closure_sample_t>() - 8usize];
    ["Offset of field: z_moved_closure_sample_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_sample_t, _this) - 0usize];
};
#[doc = " Represents the sample closure."]
pub type z_closure_query_callback_t = _z_closure_query_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_query_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: z_closure_query_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_query_t"][::core::mem::size_of::<_z_closure_query_t>() - 24usize];
    ["Alignment of _z_closure_query_t"][::core::mem::align_of::<_z_closure_query_t>() - 8usize];
    ["Offset of field: _z_closure_query_t::context"]
        [::core::mem::offset_of!(_z_closure_query_t, context) - 0usize];
    ["Offset of field: _z_closure_query_t::call"]
        [::core::mem::offset_of!(_z_closure_query_t, call) - 8usize];
    ["Offset of field: _z_closure_query_t::drop"]
        [::core::mem::offset_of!(_z_closure_query_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_query_t {
    pub _val: _z_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_query_t"]
        [::core::mem::size_of::<z_owned_closure_query_t>() - 24usize];
    ["Alignment of z_owned_closure_query_t"]
        [::core::mem::align_of::<z_owned_closure_query_t>() - 8usize];
    ["Offset of field: z_owned_closure_query_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_query_t, _val) - 0usize];
};
pub type z_loaned_closure_query_t = _z_closure_query_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_query_t {
    pub _this: z_owned_closure_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_query_t"]
        [::core::mem::size_of::<z_moved_closure_query_t>() - 24usize];
    ["Alignment of z_moved_closure_query_t"]
        [::core::mem::align_of::<z_moved_closure_query_t>() - 8usize];
    ["Offset of field: z_moved_closure_query_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_query_t, _this) - 0usize];
};
#[doc = " Represents the query callback closure."]
pub type z_closure_reply_callback_t = _z_closure_reply_callback_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_reply_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: z_closure_reply_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_reply_t"][::core::mem::size_of::<_z_closure_reply_t>() - 24usize];
    ["Alignment of _z_closure_reply_t"][::core::mem::align_of::<_z_closure_reply_t>() - 8usize];
    ["Offset of field: _z_closure_reply_t::context"]
        [::core::mem::offset_of!(_z_closure_reply_t, context) - 0usize];
    ["Offset of field: _z_closure_reply_t::call"]
        [::core::mem::offset_of!(_z_closure_reply_t, call) - 8usize];
    ["Offset of field: _z_closure_reply_t::drop"]
        [::core::mem::offset_of!(_z_closure_reply_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_reply_t {
    pub _val: _z_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_reply_t"]
        [::core::mem::size_of::<z_owned_closure_reply_t>() - 24usize];
    ["Alignment of z_owned_closure_reply_t"]
        [::core::mem::align_of::<z_owned_closure_reply_t>() - 8usize];
    ["Offset of field: z_owned_closure_reply_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_reply_t, _val) - 0usize];
};
pub type z_loaned_closure_reply_t = _z_closure_reply_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_reply_t {
    pub _this: z_owned_closure_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_reply_t"]
        [::core::mem::size_of::<z_moved_closure_reply_t>() - 24usize];
    ["Alignment of z_moved_closure_reply_t"]
        [::core::mem::align_of::<z_moved_closure_reply_t>() - 8usize];
    ["Offset of field: z_moved_closure_reply_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_reply_t, _this) - 0usize];
};
#[doc = " Represents the query reply callback closure."]
pub type z_closure_hello_callback_t = ::core::option::Option<
    unsafe extern "C" fn(hello: *mut z_loaned_hello_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_hello_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: z_closure_hello_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_hello_t"][::core::mem::size_of::<_z_closure_hello_t>() - 24usize];
    ["Alignment of _z_closure_hello_t"][::core::mem::align_of::<_z_closure_hello_t>() - 8usize];
    ["Offset of field: _z_closure_hello_t::context"]
        [::core::mem::offset_of!(_z_closure_hello_t, context) - 0usize];
    ["Offset of field: _z_closure_hello_t::call"]
        [::core::mem::offset_of!(_z_closure_hello_t, call) - 8usize];
    ["Offset of field: _z_closure_hello_t::drop"]
        [::core::mem::offset_of!(_z_closure_hello_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_hello_t {
    pub _val: _z_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_hello_t"]
        [::core::mem::size_of::<z_owned_closure_hello_t>() - 24usize];
    ["Alignment of z_owned_closure_hello_t"]
        [::core::mem::align_of::<z_owned_closure_hello_t>() - 8usize];
    ["Offset of field: z_owned_closure_hello_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_hello_t, _val) - 0usize];
};
pub type z_loaned_closure_hello_t = _z_closure_hello_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_hello_t {
    pub _this: z_owned_closure_hello_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_hello_t"]
        [::core::mem::size_of::<z_moved_closure_hello_t>() - 24usize];
    ["Alignment of z_moved_closure_hello_t"]
        [::core::mem::align_of::<z_moved_closure_hello_t>() - 8usize];
    ["Offset of field: z_moved_closure_hello_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_hello_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_zid_callback_t =
    ::core::option::Option<unsafe extern "C" fn(id: *const z_id_t, arg: *mut ::core::ffi::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_closure_zid_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: z_closure_zid_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_closure_zid_t"][::core::mem::size_of::<_z_closure_zid_t>() - 24usize];
    ["Alignment of _z_closure_zid_t"][::core::mem::align_of::<_z_closure_zid_t>() - 8usize];
    ["Offset of field: _z_closure_zid_t::context"]
        [::core::mem::offset_of!(_z_closure_zid_t, context) - 0usize];
    ["Offset of field: _z_closure_zid_t::call"]
        [::core::mem::offset_of!(_z_closure_zid_t, call) - 8usize];
    ["Offset of field: _z_closure_zid_t::drop"]
        [::core::mem::offset_of!(_z_closure_zid_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_zid_t {
    pub _val: _z_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_zid_t"][::core::mem::size_of::<z_owned_closure_zid_t>() - 24usize];
    ["Alignment of z_owned_closure_zid_t"]
        [::core::mem::align_of::<z_owned_closure_zid_t>() - 8usize];
    ["Offset of field: z_owned_closure_zid_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_zid_t, _val) - 0usize];
};
pub type z_loaned_closure_zid_t = _z_closure_zid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_zid_t {
    pub _this: z_owned_closure_zid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_zid_t"][::core::mem::size_of::<z_moved_closure_zid_t>() - 24usize];
    ["Alignment of z_moved_closure_zid_t"]
        [::core::mem::align_of::<z_moved_closure_zid_t>() - 8usize];
    ["Offset of field: z_moved_closure_zid_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_zid_t, _this) - 0usize];
};
#[doc = " Represents the Zenoh ID callback closure."]
pub type z_closure_matching_status_callback_t = _z_closure_matching_status_callback_t;
pub type z_closure_matching_status_t = _z_closure_matching_status_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_closure_matching_status_t {
    pub _val: _z_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_closure_matching_status_t"]
        [::core::mem::size_of::<z_owned_closure_matching_status_t>() - 24usize];
    ["Alignment of z_owned_closure_matching_status_t"]
        [::core::mem::align_of::<z_owned_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_owned_closure_matching_status_t::_val"]
        [::core::mem::offset_of!(z_owned_closure_matching_status_t, _val) - 0usize];
};
pub type z_loaned_closure_matching_status_t = _z_closure_matching_status_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_closure_matching_status_t {
    pub _this: z_owned_closure_matching_status_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_closure_matching_status_t"]
        [::core::mem::size_of::<z_moved_closure_matching_status_t>() - 24usize];
    ["Alignment of z_moved_closure_matching_status_t"]
        [::core::mem::align_of::<z_moved_closure_matching_status_t>() - 8usize];
    ["Offset of field: z_moved_closure_matching_status_t::_this"]
        [::core::mem::offset_of!(z_moved_closure_matching_status_t, _this) - 0usize];
};
#[doc = " Represents the matching status callback closure."]
pub type ze_closure_miss_callback_t = ::core::option::Option<
    unsafe extern "C" fn(miss: *const ze_miss_t, arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_closure_miss_t {
    pub context: *mut ::core::ffi::c_void,
    pub call: ze_closure_miss_callback_t,
    pub drop: z_closure_drop_callback_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_closure_miss_t"][::core::mem::size_of::<_ze_closure_miss_t>() - 24usize];
    ["Alignment of _ze_closure_miss_t"][::core::mem::align_of::<_ze_closure_miss_t>() - 8usize];
    ["Offset of field: _ze_closure_miss_t::context"]
        [::core::mem::offset_of!(_ze_closure_miss_t, context) - 0usize];
    ["Offset of field: _ze_closure_miss_t::call"]
        [::core::mem::offset_of!(_ze_closure_miss_t, call) - 8usize];
    ["Offset of field: _ze_closure_miss_t::drop"]
        [::core::mem::offset_of!(_ze_closure_miss_t, drop) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_closure_miss_t {
    pub _val: _ze_closure_miss_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_closure_miss_t"]
        [::core::mem::size_of::<ze_owned_closure_miss_t>() - 24usize];
    ["Alignment of ze_owned_closure_miss_t"]
        [::core::mem::align_of::<ze_owned_closure_miss_t>() - 8usize];
    ["Offset of field: ze_owned_closure_miss_t::_val"]
        [::core::mem::offset_of!(ze_owned_closure_miss_t, _val) - 0usize];
};
pub type ze_loaned_closure_miss_t = _ze_closure_miss_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_closure_miss_t {
    pub _this: ze_owned_closure_miss_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_closure_miss_t"]
        [::core::mem::size_of::<ze_moved_closure_miss_t>() - 24usize];
    ["Alignment of ze_moved_closure_miss_t"]
        [::core::mem::align_of::<ze_moved_closure_miss_t>() - 8usize];
    ["Offset of field: ze_moved_closure_miss_t::_this"]
        [::core::mem::offset_of!(ze_moved_closure_miss_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_liveliness_token_t {
    pub _id: u32,
    pub _key: _z_keyexpr_t,
    pub _zn: _z_session_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_liveliness_token_t"][::core::mem::size_of::<_z_liveliness_token_t>() - 72usize];
    ["Alignment of _z_liveliness_token_t"]
        [::core::mem::align_of::<_z_liveliness_token_t>() - 8usize];
    ["Offset of field: _z_liveliness_token_t::_id"]
        [::core::mem::offset_of!(_z_liveliness_token_t, _id) - 0usize];
    ["Offset of field: _z_liveliness_token_t::_key"]
        [::core::mem::offset_of!(_z_liveliness_token_t, _key) - 8usize];
    ["Offset of field: _z_liveliness_token_t::_zn"]
        [::core::mem::offset_of!(_z_liveliness_token_t, _zn) - 56usize];
};
unsafe extern "C" {
    pub fn _z_liveliness_token_null() -> _z_liveliness_token_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_liveliness_token_t {
    pub _val: _z_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_liveliness_token_t"]
        [::core::mem::size_of::<z_owned_liveliness_token_t>() - 72usize];
    ["Alignment of z_owned_liveliness_token_t"]
        [::core::mem::align_of::<z_owned_liveliness_token_t>() - 8usize];
    ["Offset of field: z_owned_liveliness_token_t::_val"]
        [::core::mem::offset_of!(z_owned_liveliness_token_t, _val) - 0usize];
};
pub type z_loaned_liveliness_token_t = _z_liveliness_token_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_liveliness_token_t {
    pub _this: z_owned_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_liveliness_token_t"]
        [::core::mem::size_of::<z_moved_liveliness_token_t>() - 72usize];
    ["Alignment of z_moved_liveliness_token_t"]
        [::core::mem::align_of::<z_moved_liveliness_token_t>() - 8usize];
    ["Offset of field: z_moved_liveliness_token_t::_this"]
        [::core::mem::offset_of!(z_moved_liveliness_token_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn z_internal_liveliness_token_null(obj: *mut z_owned_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_internal_liveliness_token_check(obj: *const z_owned_liveliness_token_t) -> bool;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan(
        obj: *const z_owned_liveliness_token_t,
    ) -> *const z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_loan_mut(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_loaned_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_move(
        obj: *mut z_owned_liveliness_token_t,
    ) -> *mut z_moved_liveliness_token_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_take(
        obj: *mut z_owned_liveliness_token_t,
        src: *mut z_moved_liveliness_token_t,
    );
}
unsafe extern "C" {
    pub fn z_liveliness_token_drop(obj: *mut z_moved_liveliness_token_t);
}
unsafe extern "C" {
    pub fn z_liveliness_token_take_from_loaned(
        dst: *mut z_owned_liveliness_token_t,
        src: *mut z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_liveliness_token_clone(
        obj: *mut z_owned_liveliness_token_t,
        src: *const z_loaned_liveliness_token_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_token()`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_token_options_t {
    pub __dummy: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_token_options_t"]
        [::core::mem::size_of::<z_liveliness_token_options_t>() - 1usize];
    ["Alignment of z_liveliness_token_options_t"]
        [::core::mem::align_of::<z_liveliness_token_options_t>() - 1usize];
    ["Offset of field: z_liveliness_token_options_t::__dummy"]
        [::core::mem::offset_of!(z_liveliness_token_options_t, __dummy) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value for :c:type:`z_liveliness_token_options_t`."]
    pub fn z_liveliness_token_options_default(
        options: *mut z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs and declares a liveliness token on the network.\n\n Liveliness token subscribers on an intersecting key expression will receive a PUT sample when connectivity\n is achieved, and a DELETE sample if it's lost.\n\n Parameters:\n   zs: A Zenos session to declare the liveliness token.\n   token: An uninitialized memory location where liveliness token will be constructed.\n   keyexpr: A keyexpr to declare a liveliess token for.\n   options: Liveliness token declaration options.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_token(
        zs: *const z_loaned_session_t,
        token: *mut z_owned_liveliness_token_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_liveliness_token_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclare a liveliness token, notifying subscribers of its destruction.\n\n Parameters:\n   token: Moved :c:type:`z_owned_liveliness_token_t` to undeclare.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_undeclare_token(token: *mut z_moved_liveliness_token_t) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_declare_subscriber()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_subscriber_options_t {
    pub history: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_subscriber_options_t"]
        [::core::mem::size_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Alignment of z_liveliness_subscriber_options_t"]
        [::core::mem::align_of::<z_liveliness_subscriber_options_t>() - 1usize];
    ["Offset of field: z_liveliness_subscriber_options_t::history"]
        [::core::mem::offset_of!(z_liveliness_subscriber_options_t, history) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constucts default value for :c:type:`z_liveliness_subscriber_options_t`."]
    pub fn z_liveliness_subscriber_options_default(
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a subscriber on liveliness tokens that intersect `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   sub: An uninitialized memory location where subscriber will be constructed.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber on liveliness tokens that intersect `keyexpr`.\n Subscriber callback will be called to process the messages, until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to subscribe to.\n   callback: The callback function that will be called each time a liveliness token status is changed.\n   options: The options to be passed to the liveliness subscriber declaration.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *mut z_liveliness_subscriber_options_t,
    ) -> z_result_t;
}
#[doc = " The options for :c:func:`z_liveliness_get()`"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_liveliness_get_options_t {
    pub timeout_ms: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_liveliness_get_options_t"]
        [::core::mem::size_of::<z_liveliness_get_options_t>() - 8usize];
    ["Alignment of z_liveliness_get_options_t"]
        [::core::mem::align_of::<z_liveliness_get_options_t>() - 8usize];
    ["Offset of field: z_liveliness_get_options_t::timeout_ms"]
        [::core::mem::offset_of!(z_liveliness_get_options_t, timeout_ms) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs default value :c:type:`z_liveliness_get_options_t`."]
    pub fn z_liveliness_get_options_default(options: *mut z_liveliness_get_options_t)
    -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Queries liveliness tokens currently on the network with a key expression intersecting with `keyexpr`.\n\n Parameters:\n   zs: The Zenoh session.\n   keyexpr: The key expression to query liveliness tokens for.\n   callback: The callback function that will be called for each received reply.\n   options: Additional options for the liveliness get operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_liveliness_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_liveliness_get_options_t,
    ) -> z_result_t;
}
#[doc = " Represents the set of options that can be applied to an advaned publishers cache.\n The cache allows advanced subscribers to recover history and/or lost samples.\n\n Members:\n   bool is_enabled: Must be set to ``true``, to enable the cache.\n   size_t max_samples: Number of samples to keep for each resource.\n   z_congestion_control_t congestion_control: The congestion control to apply to replies.\n   z_priority_t priority: The priority of replies.\n   bool is_express: If set to ``true``, this cache replies will not be batched. This usually\n     has a positive impact on latency but negative impact on throughput."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_advanced_publisher_cache_options_t {
    pub is_enabled: bool,
    pub max_samples: usize,
    pub congestion_control: z_congestion_control_t,
    pub priority: z_priority_t,
    pub is_express: bool,
    pub _liveliness: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_advanced_publisher_cache_options_t"]
        [::core::mem::size_of::<ze_advanced_publisher_cache_options_t>() - 32usize];
    ["Alignment of ze_advanced_publisher_cache_options_t"]
        [::core::mem::align_of::<ze_advanced_publisher_cache_options_t>() - 8usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::is_enabled"]
        [::core::mem::offset_of!(ze_advanced_publisher_cache_options_t, is_enabled) - 0usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::max_samples"]
        [::core::mem::offset_of!(ze_advanced_publisher_cache_options_t, max_samples) - 8usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::congestion_control"][::core::mem::offset_of!(
        ze_advanced_publisher_cache_options_t,
        congestion_control
    ) - 16usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::priority"]
        [::core::mem::offset_of!(ze_advanced_publisher_cache_options_t, priority) - 20usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::is_express"]
        [::core::mem::offset_of!(ze_advanced_publisher_cache_options_t, is_express) - 24usize];
    ["Offset of field: ze_advanced_publisher_cache_options_t::_liveliness"]
        [::core::mem::offset_of!(ze_advanced_publisher_cache_options_t, _liveliness) - 25usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_cache_t {
    pub _cache: _z_sample_ring_t,
    pub _outbox: *mut _z_sample_t,
    pub _outbox_cap: usize,
    pub _mutex: _z_mutex_t,
    pub _outbox_mutex: _z_mutex_t,
    pub _queryable: z_owned_queryable_t,
    pub _liveliness: z_owned_liveliness_token_t,
    pub _congestion_control: z_congestion_control_t,
    pub _priority: z_priority_t,
    pub _is_express: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_cache_t"][::core::mem::size_of::<_ze_advanced_cache_t>() - 296usize];
    ["Alignment of _ze_advanced_cache_t"][::core::mem::align_of::<_ze_advanced_cache_t>() - 8usize];
    ["Offset of field: _ze_advanced_cache_t::_cache"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _cache) - 0usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _outbox) - 40usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox_cap"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _outbox_cap) - 48usize];
    ["Offset of field: _ze_advanced_cache_t::_mutex"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _mutex) - 56usize];
    ["Offset of field: _ze_advanced_cache_t::_outbox_mutex"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _outbox_mutex) - 120usize];
    ["Offset of field: _ze_advanced_cache_t::_queryable"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _queryable) - 184usize];
    ["Offset of field: _ze_advanced_cache_t::_liveliness"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _liveliness) - 208usize];
    ["Offset of field: _ze_advanced_cache_t::_congestion_control"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _congestion_control) - 280usize];
    ["Offset of field: _ze_advanced_cache_t::_priority"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _priority) - 284usize];
    ["Offset of field: _ze_advanced_cache_t::_is_express"]
        [::core::mem::offset_of!(_ze_advanced_cache_t, _is_express) - 288usize];
};
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::core::ffi::c_uint;
unsafe extern "C" {
    pub fn atomic_thread_fence(arg1: memory_order);
}
unsafe extern "C" {
    pub fn atomic_signal_fence(arg1: memory_order);
}
pub type atomic_bool = bool;
pub type atomic_char = ::core::ffi::c_char;
pub type atomic_schar = ::core::ffi::c_schar;
pub type atomic_uchar = ::core::ffi::c_uchar;
pub type atomic_short = ::core::ffi::c_short;
pub type atomic_ushort = ::core::ffi::c_ushort;
pub type atomic_int = ::core::ffi::c_int;
pub type atomic_uint = ::core::ffi::c_uint;
pub type atomic_long = ::core::ffi::c_long;
pub type atomic_ulong = ::core::ffi::c_ulong;
pub type atomic_llong = ::core::ffi::c_longlong;
pub type atomic_ullong = ::core::ffi::c_ulonglong;
pub type atomic_char16_t = uint_least16_t;
pub type atomic_char32_t = uint_least32_t;
pub type atomic_wchar_t = wchar_t;
pub type atomic_int_least8_t = int_least8_t;
pub type atomic_uint_least8_t = uint_least8_t;
pub type atomic_int_least16_t = int_least16_t;
pub type atomic_uint_least16_t = uint_least16_t;
pub type atomic_int_least32_t = int_least32_t;
pub type atomic_uint_least32_t = uint_least32_t;
pub type atomic_int_least64_t = int_least64_t;
pub type atomic_uint_least64_t = uint_least64_t;
pub type atomic_int_fast8_t = int_fast8_t;
pub type atomic_uint_fast8_t = uint_fast8_t;
pub type atomic_int_fast16_t = int_fast16_t;
pub type atomic_uint_fast16_t = uint_fast16_t;
pub type atomic_int_fast32_t = int_fast32_t;
pub type atomic_uint_fast32_t = uint_fast32_t;
pub type atomic_int_fast64_t = int_fast64_t;
pub type atomic_uint_fast64_t = uint_fast64_t;
pub type atomic_intptr_t = isize;
pub type atomic_uintptr_t = usize;
pub type atomic_size_t = usize;
pub type atomic_ptrdiff_t = isize;
pub type atomic_intmax_t = intmax_t;
pub type atomic_uintmax_t = uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_flag {
    pub _Value: atomic_bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of atomic_flag"][::core::mem::size_of::<atomic_flag>() - 1usize];
    ["Alignment of atomic_flag"][::core::mem::align_of::<atomic_flag>() - 1usize];
    ["Offset of field: atomic_flag::_Value"][::core::mem::offset_of!(atomic_flag, _Value) - 0usize];
};
unsafe extern "C" {
    pub fn atomic_flag_test_and_set(arg1: *mut atomic_flag) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_test_and_set_explicit(arg1: *mut atomic_flag, arg2: memory_order) -> bool;
}
unsafe extern "C" {
    pub fn atomic_flag_clear(arg1: *mut atomic_flag);
}
unsafe extern "C" {
    pub fn atomic_flag_clear_explicit(arg1: *mut atomic_flag, arg2: memory_order);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_seqnumber_t {
    pub _seq: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_seqnumber_t"][::core::mem::size_of::<_z_seqnumber_t>() - 4usize];
    ["Alignment of _z_seqnumber_t"][::core::mem::align_of::<_z_seqnumber_t>() - 4usize];
    ["Offset of field: _z_seqnumber_t::_seq"]
        [::core::mem::offset_of!(_z_seqnumber_t, _seq) - 0usize];
};
unsafe extern "C" {
    pub fn _z_seqnumber_init(seq: *mut _z_seqnumber_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_seqnumber_fetch(seq: *mut _z_seqnumber_t, value: *mut u32) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_seqnumber_fetch_and_increment(
        seq: *mut _z_seqnumber_t,
        value: *mut u32,
    ) -> z_result_t;
}
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_NONE:
    _ze_advanced_publisher_sequencing_t = 0;
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_TIMESTAMP:
    _ze_advanced_publisher_sequencing_t = 1;
pub const _ze_advanced_publisher_sequencing_t__ZE_ADVANCED_PUBLISHER_SEQUENCING_SEQUENCE_NUMBER:
    _ze_advanced_publisher_sequencing_t = 2;
pub type _ze_advanced_publisher_sequencing_t = ::core::ffi::c_uint;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_NONE:
    ze_advanced_publisher_heartbeat_mode_t = 0;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_PERIODIC:
    ze_advanced_publisher_heartbeat_mode_t = 1;
pub const ze_advanced_publisher_heartbeat_mode_t_ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_SPORADIC:
    ze_advanced_publisher_heartbeat_mode_t = 2;
#[doc = " Whatami values, defined as a bitmask.\n\n Enumerators:\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_NONE: Disable heartbeat-based last sample miss detection.\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_PERIODIC: Allow last sample miss detection through periodic\n     heartbeat. Periodically send the last published Sample's sequence number to allow last sample recovery.\n   ZE_ADVANCED_PUBLISHER_HEARTBEAT_MODE_SPORADIC: Allow last sample miss detection through sporadic\n     heartbeat. Each period, the last published Sample's sequence number is sent with\n     `Z_CONGESTION_CONTROL_DROP` but only if it changed since last period.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
pub type ze_advanced_publisher_heartbeat_mode_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_t {
    pub _seqnumber: _z_seqnumber_t,
    pub _heartbeat_mode: ze_advanced_publisher_heartbeat_mode_t,
    pub _zn: _z_session_weak_t,
    pub _publisher: z_owned_publisher_t,
    pub _state_publisher_task_id: u32,
    pub _last_published_sn: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_t"]
        [::core::mem::size_of::<_ze_advanced_publisher_state_t>() - 176usize];
    ["Alignment of _ze_advanced_publisher_state_t"]
        [::core::mem::align_of::<_ze_advanced_publisher_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_seqnumber"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_t, _seqnumber) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_heartbeat_mode"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_t, _heartbeat_mode) - 4usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_zn"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_t, _zn) - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_publisher"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_t, _publisher) - 24usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_state_publisher_task_id"][::core::mem::offset_of!(
        _ze_advanced_publisher_state_t,
        _state_publisher_task_id
    ) - 168usize];
    ["Offset of field: _ze_advanced_publisher_state_t::_last_published_sn"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_t, _last_published_sn) - 172usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_publisher_state_clear(state: *mut _ze_advanced_publisher_state_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_rc_t {
    pub _val: *mut _ze_advanced_publisher_state_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_rc_t"]
        [::core::mem::size_of::<_ze_advanced_publisher_state_rc_t>() - 16usize];
    ["Alignment of _ze_advanced_publisher_state_rc_t"]
        [::core::mem::align_of::<_ze_advanced_publisher_state_rc_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_rc_t::_val"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_rc_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_rc_t::_cnt"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_state_weak_t {
    pub _val: *mut _ze_advanced_publisher_state_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_state_weak_t"]
        [::core::mem::size_of::<_ze_advanced_publisher_state_weak_t>() - 16usize];
    ["Alignment of _ze_advanced_publisher_state_weak_t"]
        [::core::mem::align_of::<_ze_advanced_publisher_state_weak_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_state_weak_t::_val"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_weak_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_publisher_state_weak_t::_cnt"]
        [::core::mem::offset_of!(_ze_advanced_publisher_state_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_publisher_t {
    pub _publisher: z_owned_publisher_t,
    pub _cache: *mut _ze_advanced_cache_t,
    pub _has_liveliness: bool,
    pub _liveliness: z_owned_liveliness_token_t,
    pub _sequencing: _ze_advanced_publisher_sequencing_t,
    pub _state: _ze_advanced_publisher_state_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_publisher_t"]
        [::core::mem::size_of::<_ze_advanced_publisher_t>() - 256usize];
    ["Alignment of _ze_advanced_publisher_t"]
        [::core::mem::align_of::<_ze_advanced_publisher_t>() - 8usize];
    ["Offset of field: _ze_advanced_publisher_t::_publisher"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _publisher) - 0usize];
    ["Offset of field: _ze_advanced_publisher_t::_cache"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _cache) - 144usize];
    ["Offset of field: _ze_advanced_publisher_t::_has_liveliness"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _has_liveliness) - 152usize];
    ["Offset of field: _ze_advanced_publisher_t::_liveliness"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _liveliness) - 160usize];
    ["Offset of field: _ze_advanced_publisher_t::_sequencing"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _sequencing) - 232usize];
    ["Offset of field: _ze_advanced_publisher_t::_state"]
        [::core::mem::offset_of!(_ze_advanced_publisher_t, _state) - 240usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_advanced_publisher_t {
    pub _val: _ze_advanced_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_advanced_publisher_t"]
        [::core::mem::size_of::<ze_owned_advanced_publisher_t>() - 256usize];
    ["Alignment of ze_owned_advanced_publisher_t"]
        [::core::mem::align_of::<ze_owned_advanced_publisher_t>() - 8usize];
    ["Offset of field: ze_owned_advanced_publisher_t::_val"]
        [::core::mem::offset_of!(ze_owned_advanced_publisher_t, _val) - 0usize];
};
pub type ze_loaned_advanced_publisher_t = _ze_advanced_publisher_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_advanced_publisher_t {
    pub _this: ze_owned_advanced_publisher_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_advanced_publisher_t"]
        [::core::mem::size_of::<ze_moved_advanced_publisher_t>() - 256usize];
    ["Alignment of ze_moved_advanced_publisher_t"]
        [::core::mem::align_of::<ze_moved_advanced_publisher_t>() - 8usize];
    ["Offset of field: ze_moved_advanced_publisher_t::_this"]
        [::core::mem::offset_of!(ze_moved_advanced_publisher_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_advanced_publisher_null(obj: *mut ze_owned_advanced_publisher_t);
}
unsafe extern "C" {
    pub fn ze_internal_advanced_publisher_check(obj: *const ze_owned_advanced_publisher_t) -> bool;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_loan(
        obj: *const ze_owned_advanced_publisher_t,
    ) -> *const ze_loaned_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_loan_mut(
        obj: *mut ze_owned_advanced_publisher_t,
    ) -> *mut ze_loaned_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_move(
        obj: *mut ze_owned_advanced_publisher_t,
    ) -> *mut ze_moved_advanced_publisher_t;
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_take(
        obj: *mut ze_owned_advanced_publisher_t,
        src: *mut ze_moved_advanced_publisher_t,
    );
}
unsafe extern "C" {
    pub fn ze_advanced_publisher_drop(obj: *mut ze_moved_advanced_publisher_t);
}
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_entry_t {
    pub _key: *mut ::core::ffi::c_void,
    pub _val: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_entry_t"][::core::mem::size_of::<_z_sortedmap_entry_t>() - 16usize];
    ["Alignment of _z_sortedmap_entry_t"][::core::mem::align_of::<_z_sortedmap_entry_t>() - 8usize];
    ["Offset of field: _z_sortedmap_entry_t::_key"]
        [::core::mem::offset_of!(_z_sortedmap_entry_t, _key) - 0usize];
    ["Offset of field: _z_sortedmap_entry_t::_val"]
        [::core::mem::offset_of!(_z_sortedmap_entry_t, _val) - 8usize];
};
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_t {
    pub _vals: *mut _z_list_t,
    pub _f_cmp: z_element_cmp_f,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_t"][::core::mem::size_of::<_z_sortedmap_t>() - 16usize];
    ["Alignment of _z_sortedmap_t"][::core::mem::align_of::<_z_sortedmap_t>() - 8usize];
    ["Offset of field: _z_sortedmap_t::_vals"]
        [::core::mem::offset_of!(_z_sortedmap_t, _vals) - 0usize];
    ["Offset of field: _z_sortedmap_t::_f_cmp"]
        [::core::mem::offset_of!(_z_sortedmap_t, _f_cmp) - 8usize];
};
#[doc = " Iterator for a generic key-value hashmap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_sortedmap_iterator_t {
    pub _entry: *mut _z_sortedmap_entry_t,
    pub _map: *const _z_sortedmap_t,
    pub _list_ptr: *mut _z_list_t,
    pub _initialized: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_sortedmap_iterator_t"]
        [::core::mem::size_of::<_z_sortedmap_iterator_t>() - 32usize];
    ["Alignment of _z_sortedmap_iterator_t"]
        [::core::mem::align_of::<_z_sortedmap_iterator_t>() - 8usize];
    ["Offset of field: _z_sortedmap_iterator_t::_entry"]
        [::core::mem::offset_of!(_z_sortedmap_iterator_t, _entry) - 0usize];
    ["Offset of field: _z_sortedmap_iterator_t::_map"]
        [::core::mem::offset_of!(_z_sortedmap_iterator_t, _map) - 8usize];
    ["Offset of field: _z_sortedmap_iterator_t::_list_ptr"]
        [::core::mem::offset_of!(_z_sortedmap_iterator_t, _list_ptr) - 16usize];
    ["Offset of field: _z_sortedmap_iterator_t::_initialized"]
        [::core::mem::offset_of!(_z_sortedmap_iterator_t, _initialized) - 24usize];
};
unsafe extern "C" {
    pub fn _z_sortedmap_init(map: *mut _z_sortedmap_t, f_cmp: z_element_cmp_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_make(f_cmp: z_element_cmp_f) -> _z_sortedmap_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_insert(
        map: *mut _z_sortedmap_t,
        key: *mut ::core::ffi::c_void,
        val: *mut ::core::ffi::c_void,
        f: z_element_free_f,
        replace: bool,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_get(
        map: *const _z_sortedmap_t,
        key: *const ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_pop_first(map: *mut _z_sortedmap_t) -> *mut _z_sortedmap_entry_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_remove(
        map: *mut _z_sortedmap_t,
        key: *const ::core::ffi::c_void,
        f: z_element_free_f,
    );
}
unsafe extern "C" {
    pub fn _z_sortedmap_len(map: *const _z_sortedmap_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_sortedmap_is_empty(map: *const _z_sortedmap_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_sortedmap_copy(
        dst: *mut _z_sortedmap_t,
        src: *const _z_sortedmap_t,
        f_c: z_element_clone_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_clone(
        src: *const _z_sortedmap_t,
        f_c: z_element_clone_f,
        f_f: z_element_free_f,
    ) -> _z_sortedmap_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_clear(map: *mut _z_sortedmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_free(map: *mut *mut _z_sortedmap_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_make(map: *const _z_sortedmap_t) -> _z_sortedmap_iterator_t;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_next(iter: *mut _z_sortedmap_iterator_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_key(
        iter: *const _z_sortedmap_iterator_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_sortedmap_iterator_value(
        iter: *const _z_sortedmap_iterator_t,
    ) -> *mut ::core::ffi::c_void;
}
pub type _z_uint32_eq_f =
    ::core::option::Option<unsafe extern "C" fn(left: *const u32, right: *const u32) -> bool>;
pub type _z_uint32_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const u32, right: *const u32) -> ::core::ffi::c_int,
>;
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_uint32__z_sample_sortedmap_entry_t = _z_sortedmap_entry_t;
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
pub type _z_uint32__z_sample_sortedmap_t = _z_sortedmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_uint32__z_sample_sortedmap_iterator_t = _z_sortedmap_iterator_t;
#[doc = " A map entry.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_timestamp__z_sample_sortedmap_entry_t = _z_sortedmap_entry_t;
#[doc = " A sorted map.\n\n Members:\n   _z_list_t *_vals: a linked list containing the values\n   z_element_cmp_f _f_cmp: the function used to compare keys"]
pub type _z_timestamp__z_sample_sortedmap_t = _z_sortedmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_timestamp__z_sample_sortedmap_iterator_t = _z_sortedmap_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_sequenced_state_t {
    pub _zn: _z_session_weak_t,
    pub _has_last_delivered: bool,
    pub _last_delivered: u32,
    pub _pending_queries: u64,
    pub _pending_samples: _z_uint32__z_sample_sortedmap_t,
    pub _periodic_query_id: u32,
    pub _query_keyexpr: z_owned_keyexpr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_sequenced_state_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_sequenced_state_t>() - 104usize];
    ["Alignment of _ze_advanced_subscriber_sequenced_state_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_sequenced_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_zn"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_sequenced_state_t, _zn) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_has_last_delivered"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _has_last_delivered
    )
        - 16usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_last_delivered"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _last_delivered
    ) - 20usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_pending_queries"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _pending_queries
    ) - 24usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_pending_samples"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _pending_samples
    ) - 32usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_periodic_query_id"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _periodic_query_id
    ) - 48usize];
    ["Offset of field: _ze_advanced_subscriber_sequenced_state_t::_query_keyexpr"][::core::mem::offset_of!(
        _ze_advanced_subscriber_sequenced_state_t,
        _query_keyexpr
    ) - 56usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_sequenced_state_clear(
        s: *mut _ze_advanced_subscriber_sequenced_state_t,
    );
}
pub type _ze_advanced_subscriber_sequenced_state_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_sequenced_state_t,
        right: *const _ze_advanced_subscriber_sequenced_state_t,
    ) -> bool,
>;
pub type _ze_advanced_subscriber_sequenced_state_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_sequenced_state_t,
        right: *const _ze_advanced_subscriber_sequenced_state_t,
    ) -> ::core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_timestamped_state_t {
    pub _has_last_delivered: bool,
    pub _last_delivered: _z_timestamp_t,
    pub _pending_queries: u64,
    pub _pending_samples: _z_timestamp__z_sample_sortedmap_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_timestamped_state_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_timestamped_state_t>() - 64usize];
    ["Alignment of _ze_advanced_subscriber_timestamped_state_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_timestamped_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_has_last_delivered"][::core::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _has_last_delivered
    )
        - 0usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_last_delivered"][::core::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _last_delivered
    ) - 8usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_pending_queries"][::core::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _pending_queries
    ) - 40usize];
    ["Offset of field: _ze_advanced_subscriber_timestamped_state_t::_pending_samples"][::core::mem::offset_of!(
        _ze_advanced_subscriber_timestamped_state_t,
        _pending_samples
    ) - 48usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_timestamped_state_clear(
        s: *mut _ze_advanced_subscriber_timestamped_state_t,
    );
}
pub type _ze_advanced_subscriber_timestamped_state_eq_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_timestamped_state_t,
        right: *const _ze_advanced_subscriber_timestamped_state_t,
    ) -> bool,
>;
pub type _ze_advanced_subscriber_timestamped_state_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_advanced_subscriber_timestamped_state_t,
        right: *const _ze_advanced_subscriber_timestamped_state_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_entry_t =
    _z_hashmap_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_t = _z_hashmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_iterator_t =
    _z_hashmap_iterator_t;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_entry_t = _z_hashmap_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_t = _z_hashmap_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _z_id__ze_advanced_subscriber_timestamped_state_hashmap_iterator_t = _z_hashmap_iterator_t;
pub type _ze_closure_miss_eq_f = ::core::option::Option<
    unsafe extern "C" fn(left: *const _ze_closure_miss_t, right: *const _ze_closure_miss_t) -> bool,
>;
pub type _ze_closure_miss_cmp_f = ::core::option::Option<
    unsafe extern "C" fn(
        left: *const _ze_closure_miss_t,
        right: *const _ze_closure_miss_t,
    ) -> ::core::ffi::c_int,
>;
#[doc = " A hashmap entry with generic keys.\n\n Members:\n   void *_key: the key of the entry\n   void *_val: the value of the entry"]
pub type _ze_closure_miss_intmap_entry_t = _z_int_void_map_entry_t;
#[doc = " A hashmap with generic keys.\n\n Members:\n    size_t _capacity: the number of buckets available in the hashmap\n   _z_list_t **_vals: the linked list containing the values\n   z_element_hash_f _f_hash: the hash function used to hash keys\n   z_element_eq_f _f_equals: the function used to compare keys for equality"]
pub type _ze_closure_miss_intmap_t = _z_int_void_map_t;
#[doc = " Iterator for a generic key-value hashmap."]
pub type _ze_closure_miss_intmap_iterator_t = _z_int_void_map_iterator_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_t {
    pub _mutex: z_owned_mutex_t,
    pub _next_id: usize,
    pub _global_pending_queries: u64,
    pub _sequenced_states: _z_entity_global_id__ze_advanced_subscriber_sequenced_state_hashmap_t,
    pub _timestamped_states: _z_id__ze_advanced_subscriber_timestamped_state_hashmap_t,
    pub _zn: _z_session_weak_t,
    pub _keyexpr: z_owned_keyexpr_t,
    pub _retransmission: bool,
    pub _has_period: bool,
    pub _period_ms: u64,
    pub _history_depth: usize,
    pub _history_age: u64,
    pub _query_target: z_query_target_t,
    pub _query_timeout: u64,
    pub _callback: _z_closure_sample_callback_t,
    pub _dropper: _z_drop_handler_t,
    pub _ctx: *mut ::core::ffi::c_void,
    pub _miss_handlers: _ze_closure_miss_intmap_t,
    pub _has_token: bool,
    pub _token: z_owned_liveliness_token_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_state_t>() - 392usize];
    ["Alignment of _ze_advanced_subscriber_state_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_state_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_mutex"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _mutex) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_next_id"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _next_id) - 64usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_global_pending_queries"][::core::mem::offset_of!(
        _ze_advanced_subscriber_state_t,
        _global_pending_queries
    ) - 72usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_sequenced_states"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _sequenced_states) - 80usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_timestamped_states"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _timestamped_states) - 112usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_zn"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _zn) - 144usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_keyexpr"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _keyexpr) - 160usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_retransmission"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _retransmission) - 208usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_has_period"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _has_period) - 209usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_period_ms"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _period_ms) - 216usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_history_depth"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _history_depth) - 224usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_history_age"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _history_age) - 232usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_query_target"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _query_target) - 240usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_query_timeout"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _query_timeout) - 248usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_callback"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _callback) - 256usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_dropper"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _dropper) - 264usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_ctx"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _ctx) - 272usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_miss_handlers"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _miss_handlers) - 280usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_has_token"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _has_token) - 312usize];
    ["Offset of field: _ze_advanced_subscriber_state_t::_token"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_t, _token) - 320usize];
};
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_state_null() -> _ze_advanced_subscriber_state_t;
}
unsafe extern "C" {
    pub fn _ze_advanced_subscriber_state_clear(state: *mut _ze_advanced_subscriber_state_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_rc_t {
    pub _val: *mut _ze_advanced_subscriber_state_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_rc_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_state_rc_t>() - 16usize];
    ["Alignment of _ze_advanced_subscriber_state_rc_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_state_rc_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_rc_t::_val"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_rc_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_rc_t::_cnt"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_state_weak_t {
    pub _val: *mut _ze_advanced_subscriber_state_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_state_weak_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_state_weak_t>() - 16usize];
    ["Alignment of _ze_advanced_subscriber_state_weak_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_state_weak_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_state_weak_t::_val"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_weak_t, _val) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_state_weak_t::_cnt"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_state_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_advanced_subscriber_t {
    pub _subscriber: z_owned_subscriber_t,
    pub _has_liveliness_subscriber: bool,
    pub _liveliness_subscriber: z_owned_subscriber_t,
    pub _has_heartbeat_subscriber: bool,
    pub _heartbeat_subscriber: z_owned_subscriber_t,
    pub _state: _ze_advanced_subscriber_state_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_advanced_subscriber_t"]
        [::core::mem::size_of::<_ze_advanced_subscriber_t>() - 104usize];
    ["Alignment of _ze_advanced_subscriber_t"]
        [::core::mem::align_of::<_ze_advanced_subscriber_t>() - 8usize];
    ["Offset of field: _ze_advanced_subscriber_t::_subscriber"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _subscriber) - 0usize];
    ["Offset of field: _ze_advanced_subscriber_t::_has_liveliness_subscriber"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _has_liveliness_subscriber) - 24usize];
    ["Offset of field: _ze_advanced_subscriber_t::_liveliness_subscriber"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _liveliness_subscriber) - 32usize];
    ["Offset of field: _ze_advanced_subscriber_t::_has_heartbeat_subscriber"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _has_heartbeat_subscriber) - 56usize];
    ["Offset of field: _ze_advanced_subscriber_t::_heartbeat_subscriber"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _heartbeat_subscriber) - 64usize];
    ["Offset of field: _ze_advanced_subscriber_t::_state"]
        [::core::mem::offset_of!(_ze_advanced_subscriber_t, _state) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_advanced_subscriber_t {
    pub _val: _ze_advanced_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_advanced_subscriber_t"]
        [::core::mem::size_of::<ze_owned_advanced_subscriber_t>() - 104usize];
    ["Alignment of ze_owned_advanced_subscriber_t"]
        [::core::mem::align_of::<ze_owned_advanced_subscriber_t>() - 8usize];
    ["Offset of field: ze_owned_advanced_subscriber_t::_val"]
        [::core::mem::offset_of!(ze_owned_advanced_subscriber_t, _val) - 0usize];
};
pub type ze_loaned_advanced_subscriber_t = _ze_advanced_subscriber_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_advanced_subscriber_t {
    pub _this: ze_owned_advanced_subscriber_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_advanced_subscriber_t"]
        [::core::mem::size_of::<ze_moved_advanced_subscriber_t>() - 104usize];
    ["Alignment of ze_moved_advanced_subscriber_t"]
        [::core::mem::align_of::<ze_moved_advanced_subscriber_t>() - 8usize];
    ["Offset of field: ze_moved_advanced_subscriber_t::_this"]
        [::core::mem::offset_of!(ze_moved_advanced_subscriber_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_advanced_subscriber_null(obj: *mut ze_owned_advanced_subscriber_t);
}
unsafe extern "C" {
    pub fn ze_internal_advanced_subscriber_check(
        obj: *const ze_owned_advanced_subscriber_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_loan(
        obj: *const ze_owned_advanced_subscriber_t,
    ) -> *const ze_loaned_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_loan_mut(
        obj: *mut ze_owned_advanced_subscriber_t,
    ) -> *mut ze_loaned_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_move(
        obj: *mut ze_owned_advanced_subscriber_t,
    ) -> *mut ze_moved_advanced_subscriber_t;
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_take(
        obj: *mut ze_owned_advanced_subscriber_t,
        src: *mut ze_moved_advanced_subscriber_t,
    );
}
unsafe extern "C" {
    pub fn ze_advanced_subscriber_drop(obj: *mut ze_moved_advanced_subscriber_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sample_miss_listener_t {
    pub _id: usize,
    pub _statesref: _ze_advanced_subscriber_state_weak_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_sample_miss_listener_t"]
        [::core::mem::size_of::<_ze_sample_miss_listener_t>() - 24usize];
    ["Alignment of _ze_sample_miss_listener_t"]
        [::core::mem::align_of::<_ze_sample_miss_listener_t>() - 8usize];
    ["Offset of field: _ze_sample_miss_listener_t::_id"]
        [::core::mem::offset_of!(_ze_sample_miss_listener_t, _id) - 0usize];
    ["Offset of field: _ze_sample_miss_listener_t::_statesref"]
        [::core::mem::offset_of!(_ze_sample_miss_listener_t, _statesref) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_sample_miss_listener_t {
    pub _val: _ze_sample_miss_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_sample_miss_listener_t"]
        [::core::mem::size_of::<ze_owned_sample_miss_listener_t>() - 24usize];
    ["Alignment of ze_owned_sample_miss_listener_t"]
        [::core::mem::align_of::<ze_owned_sample_miss_listener_t>() - 8usize];
    ["Offset of field: ze_owned_sample_miss_listener_t::_val"]
        [::core::mem::offset_of!(ze_owned_sample_miss_listener_t, _val) - 0usize];
};
pub type ze_loaned_sample_miss_listener_t = _ze_sample_miss_listener_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_sample_miss_listener_t {
    pub _this: ze_owned_sample_miss_listener_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_sample_miss_listener_t"]
        [::core::mem::size_of::<ze_moved_sample_miss_listener_t>() - 24usize];
    ["Alignment of ze_moved_sample_miss_listener_t"]
        [::core::mem::align_of::<ze_moved_sample_miss_listener_t>() - 8usize];
    ["Offset of field: ze_moved_sample_miss_listener_t::_this"]
        [::core::mem::offset_of!(ze_moved_sample_miss_listener_t, _this) - 0usize];
};
unsafe extern "C" {
    pub fn ze_internal_sample_miss_listener_null(obj: *mut ze_owned_sample_miss_listener_t);
}
unsafe extern "C" {
    pub fn ze_internal_sample_miss_listener_check(
        obj: *const ze_owned_sample_miss_listener_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_loan(
        obj: *const ze_owned_sample_miss_listener_t,
    ) -> *const ze_loaned_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_loan_mut(
        obj: *mut ze_owned_sample_miss_listener_t,
    ) -> *mut ze_loaned_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_move(
        obj: *mut ze_owned_sample_miss_listener_t,
    ) -> *mut ze_moved_sample_miss_listener_t;
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_take(
        obj: *mut ze_owned_sample_miss_listener_t,
        src: *mut ze_moved_sample_miss_listener_t,
    );
}
unsafe extern "C" {
    pub fn ze_sample_miss_listener_drop(obj: *mut ze_moved_sample_miss_listener_t);
}
unsafe extern "C" {
    #[doc = " Just some bytes.\n\n Constant alias for string: `\"zenoh/bytes\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_buf`, c:func:`z_bytes_from_slice` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_slice`."]
    pub fn z_encoding_zenoh_bytes() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_BYTES: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A UTF-8 string.\n Constant alias for string: `\"zenoh/string\"`.\n\n This encoding supposes that the payload was created with c:func:`z_bytes_from_str`, c:func:`z_bytes_from_string` or\n similar functions and its data can be accessed via c:func:`z_bytes_to_string`."]
    pub fn z_encoding_zenoh_string() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_STRING: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Zenoh serialized data.\n Constant alias for string: `\"zenoh/serialized\"`.\n\n This encoding supposes that the payload was created with serialization functions.\n The `schema` field may contain the details of serialziation format."]
    pub fn z_encoding_zenoh_serialized() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_ZENOH_SERIALIZED: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific stream of bytes.\n Constant alias for string: `\"application/octet-stream\"`."]
    pub fn z_encoding_application_octet_stream() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_OCTET_STREAM: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A textual file.\n Constant alias for string: `\"text/plain\"`."]
    pub fn z_encoding_text_plain() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_PLAIN: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be consumed by an application.\n Constant alias for string: `\"application/json\"`."]
    pub fn z_encoding_application_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON data intended to be human readable.\n Constant alias for string: `\"text/json\"`."]
    pub fn z_encoding_text_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Common Data Representation (CDR)-encoded data.\n Constant alias for string: `\"application/cdr\"`."]
    pub fn z_encoding_application_cdr() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_CDR: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Concise Binary Object Representation (CBOR)-encoded data.\n Constant alias for string: `\"application/cbor\"`."]
    pub fn z_encoding_application_cbor() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_CBOR: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be consumed by an application.\n Constant alias for string: `\"application/yaml\"`."]
    pub fn z_encoding_application_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_YAML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " YAML data intended to be human readable.\n Constant alias for string: `\"text/yaml\"`."]
    pub fn z_encoding_text_yaml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_YAML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " JSON5 encoded data that are human readable.\n Constant alias for string: `\"text/json5\"`."]
    pub fn z_encoding_text_json5() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JSON5: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Python object serialized using `pickle <https://docs.python.org/3/library/pickle.html>`_.\n Constant alias for string: `\"application/python-serialized-object\"`."]
    pub fn z_encoding_application_python_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_PYTHON_SERIALIZED_OBJECT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific protobuf-encoded data.\n Constant alias for string: `\"application/protobuf\"`."]
    pub fn z_encoding_application_protobuf() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_PROTOBUF: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Java serialized object.\n Constant alias for string: `\"application/java-serialized-object\"`."]
    pub fn z_encoding_application_java_serialized_object() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JAVA_SERIALIZED_OBJECT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An `openmetrics <https://github.com/OpenObservability/OpenMetrics>`_ data, commonly used by\n `Prometheus <https://prometheus.io/>`_.\n Constant alias for string: `\"application/openmetrics-text\"`."]
    pub fn z_encoding_application_openmetrics_text() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_OPENMETRICS_TEXT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Portable Network Graphics (PNG) image.\n Constant alias for string: `\"image/png\"`."]
    pub fn z_encoding_image_png() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_PNG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Joint Photographic Experts Group (JPEG) image.\n Constant alias for string: `\"image/jpeg\"`."]
    pub fn z_encoding_image_jpeg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_JPEG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Graphics Interchange Format (GIF) image.\n Constant alias for string: `\"image/gif\"`."]
    pub fn z_encoding_image_gif() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_GIF: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A BitMap (BMP) image.\n Constant alias for string: `\"image/bmp\"`."]
    pub fn z_encoding_image_bmp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_BMP: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Web Portable (WebP) image.\n Constant alias for string: `\"image/webp\"`."]
    pub fn z_encoding_image_webp() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_IMAGE_WEBP: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file intended to be consumed by an application.\n Constant alias for string: `\"application/xml\"`."]
    pub fn z_encoding_application_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An encoded list of tuples, each consisting of a name and a value.\n Constant alias for string: `\"application/x-www-form-urlencoded\"`."]
    pub fn z_encoding_application_x_www_form_urlencoded() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_X_WWW_FORM_URLENCODED: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An HTML file.\n Constant alias for string: `\"text/html\"`."]
    pub fn z_encoding_text_html() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_HTML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An XML file that is human-readable.\n Constant alias for string: `\"text/xml\"`."]
    pub fn z_encoding_text_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSS file.\n Constant alias for string: `\"text/css\"`."]
    pub fn z_encoding_text_css() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_CSS: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JavaScript file.\n Constant alias for string: `\"text/javascript\"`."]
    pub fn z_encoding_text_javascript() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_JAVASCRIPT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Markdown file.\n Constant alias for string: `\"text/markdown\"`."]
    pub fn z_encoding_text_markdown() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_MARKDOWN: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A CSV file.\n Constant alias for string: `\"text/csv\"`."]
    pub fn z_encoding_text_csv() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_TEXT_CSV: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific SQL query.\n Constant alias for string: `\"application/sql\"`."]
    pub fn z_encoding_application_sql() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_SQL: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Constrained Application Protocol (CoAP) data intended for CoAP-to-HTTP and HTTP-to-CoAP proxies.\n Constant alias for string: `\"application/coap-payload\"`."]
    pub fn z_encoding_application_coap_payload() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_COAP_PAYLOAD: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Defines a JSON document structure for expressing a sequence of operations to apply to a JSON document.\n Constant alias for string: `\"application/json-patch+json\"`."]
    pub fn z_encoding_application_json_patch_json() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON_PATCH_JSON: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON text sequence consists of any number of JSON texts, all encoded in UTF-8.\n Constant alias for string: `\"application/json-seq\"`."]
    pub fn z_encoding_application_json_seq() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSON_SEQ: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSONPath defines a string syntax for selecting and extracting JSON values from within a given JSON value.\n Constant alias for string: `\"application/jsonpath\"`."]
    pub fn z_encoding_application_jsonpath() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JSONPATH: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A JSON Web Token (JWT).\n Constant alias for string: `\"application/jwt\"`."]
    pub fn z_encoding_application_jwt() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_JWT: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An application-specific MPEG-4 encoded data, either audio or video.\n Constant alias for string: `\"application/mp4\"`."]
    pub fn z_encoding_application_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A SOAP 1.2 message serialized as XML 1.0.\n Constant alias for string: `\"application/soap+xml\"`."]
    pub fn z_encoding_application_soap_xml() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_SOAP_XML: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A YANG-encoded data commonly used by the Network Configuration Protocol (NETCONF).\n Constant alias for string: `\"application/yang\"`."]
    pub fn z_encoding_application_yang() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_APPLICATION_YANG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A MPEG-4 Advanced Audio Coding (AAC) media.\n Constant alias for string: `\"audio/aac\"`."]
    pub fn z_encoding_audio_aac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_AAC: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Free Lossless Audio Codec (FLAC) media.\n Constant alias for string: `\"audio/flac\"`."]
    pub fn z_encoding_audio_flac() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_FLAC: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An audio codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"audio/mp4\"`."]
    pub fn z_encoding_audio_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated audio stream.\n Constant alias for string: `\"audio/ogg\"`."]
    pub fn z_encoding_audio_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_OGG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A Vorbis-encoded audio stream.\n Constant alias for string: `\"audio/vorbis\"`."]
    pub fn z_encoding_audio_vorbis() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_AUDIO_VORBIS: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h261-encoded video stream.\n Constant alias for string: `\"video/h261\"`."]
    pub fn z_encoding_video_h261() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H261: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h263-encoded video stream.\n Constant alias for string: `\"video/h263\"`."]
    pub fn z_encoding_video_h263() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H263: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h264-encoded video stream.\n Constant alias for string: `\"video/h264\"`."]
    pub fn z_encoding_video_h264() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H264: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h265-encoded video stream.\n Constant alias for string: `\"video/h265\"`."]
    pub fn z_encoding_video_h265() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H265: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A h266-encoded video stream.\n Constant alias for string: `\"video/h266\"`."]
    pub fn z_encoding_video_h266() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_H266: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A video codec defined in MPEG-1, MPEG-2, MPEG-4, or registered at the MP4 registration authority.\n Constant alias for string: `\"video/mp4\"`."]
    pub fn z_encoding_video_mp4() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_MP4: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An Ogg-encapsulated video stream.\n Constant alias for string: `\"video/ogg\"`."]
    pub fn z_encoding_video_ogg() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_OGG: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " An uncompressed, studio-quality video stream.\n Constant alias for string: `\"video/raw\"`."]
    pub fn z_encoding_video_raw() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_RAW: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP8-encoded video stream.\n Constant alias for string: `\"video/vp8\"`."]
    pub fn z_encoding_video_vp8() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_VP8: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " A VP9-encoded video stream.\n Constant alias for string: `\"video/vp9\"`."]
    pub fn z_encoding_video_vp9() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub static ZP_ENCODING_VIDEO_VP9: z_owned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Returns a loaned default `z_loaned_encoding_t`."]
    pub fn z_encoding_loan_default() -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_str(
        str_: *mut z_view_string_t,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_string_t` by wrapping a ``const char *`` substring.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n   value: Pointer to a null terminated string.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_string_from_substr(
        str_: *mut z_view_string_t,
        value: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a null-terminated string.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string."]
    pub fn z_view_keyexpr_from_str_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::core::ffi::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a null-terminated string with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` by aliasing a substring.\n It is a loaned key expression that aliases ``name``.\n This function will fail if the string is not in canon form.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_keyexpr_t` from a substring with auto canonization.\n It is a loaned key expression that aliases ``name``.\n The string is canonized in-place before being passed to keyexpr, possibly shortening it by modifying len.\n May SEGFAULT if `name` is NULL or lies in read-only memory (as values initialized with string literals do).\n `name` must outlive the constructed key expression.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Pointer to the size of the string.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_view_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_view_keyexpr_t,
        name: *mut ::core::ffi::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_keyexpr_t` from a substring.\n It is a loaned key expression that aliases ``name``.\n Input key expression is not checked for correctness.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_view_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr.\n   len: Size of the string."]
    pub fn z_view_keyexpr_from_substr_unchecked(
        keyexpr: *mut z_view_keyexpr_t,
        name: *const ::core::ffi::c_char,
        len: usize,
    );
}
unsafe extern "C" {
    #[doc = " Gets a string view from a :c:type:`z_keyexpr_t`.\n\n Parameters:\n   keyexpr: Pointer to a loaned instance of :c:type:`z_keyexpr_t`.\n   str: Pointer to an uninitialized :c:type:`z_view_string_t`.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_as_view_string(
        keyexpr: *const z_loaned_keyexpr_t,
        str_: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by concatenation of key expression in `left` with a string in `right`.\n\n To avoid odd behaviors, concatenating a key expression starting with `*` to one ending with `*` is forbidden by this\n operation, as this would extremely likely cause bugs.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to keyexpr to concatenate to.\n   right: Pointer to the start of the substring that will be concatenated.\n   len: Length of the substring to concatenate.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_concat(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs key expression by performing path-joining (automatically inserting '/'). The resulting key expression is\n automatically canonized.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` to the left part of the resulting key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` to the right part of the resulting key expression.\n\n Return:\n   ``0`` if creation successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_join(
        key: *mut z_owned_keyexpr_t,
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends the suffix portion of a key expression to another key expression (automatically inserting '/').\n\n Only the suffix portion of the key expression is preserved. All other components of the resulting key\n expression will be discarded.\n The resulting key expression is automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` to the key expression to append to.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` whose suffix will be appended.\n\n Return:\n   ``0`` if the append was successful; a ``negative value`` otherwise."]
    pub fn _z_keyexpr_append_suffix(
        prefix: *mut z_owned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends a string segment to a key expression (automatically inserting '/'). The resulting key expression is\n automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` to the key expression to append to.\n   right: Pointer to a character array representing the string to append.\n   len: Length of the string segment in ``right`` to append.\n\n Return:\n   ``0`` if append successful, ``negative value`` otherwise."]
    pub fn _z_keyexpr_append_substr(
        prefix: *mut z_owned_keyexpr_t,
        right: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends multiple null-terminated strings to a key expression (automatically inserting '/' between each component).\n The resulting key expression is automatically canonized.\n\n Parameters:\n   prefix: Pointer to :c:type:`z_owned_keyexpr_t` representing the key expression to append to.\n   strs: Array of ``count`` null-terminated strings to append, in order.\n   count: Number of strings in the array.\n\n Return:\n   ``0`` if all appends were successful, ``negative value`` if any append failed."]
    pub fn _z_keyexpr_append_str_array(
        prefix: *mut z_owned_keyexpr_t,
        strs: *mut *const ::core::ffi::c_char,
        count: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the relation between `left` and `right` from the `left`'s point of view.\n\n Note that this is slower than `z_keyexpr_intersects` and `keyexpr_includes`, so you should favor these methods for\n most applications.\n\n Parameters:\n   left: Pointer to :c:type:`z_loaned_keyexpr_t` representing left key expression.\n   right: Pointer to :c:type:`z_loaned_keyexpr_t` representing right key expression.\n\n Return:\n   Relation between `left` and `right` from the `left`'s point of view."]
    pub fn z_keyexpr_relation_to(
        left: *const z_loaned_keyexpr_t,
        right: *const z_loaned_keyexpr_t,
    ) -> z_keyexpr_intersection_level_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr is valid and in canonical form.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if the passed string is a valid (and canon) key expression, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_is_canon(start: *const ::core::ffi::c_char, len: usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by modifying ``len``.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a non-null terminated string.\n   len: Number of characters in ``start``.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize(start: *mut ::core::ffi::c_char, len: *mut usize) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Canonizes of a given keyexpr in string representation.\n The canonization is performed over the passed string, possibly shortening it by setting null at the end.\n\n Parameters:\n   start: Pointer to the keyexpr in its string representation as a null terminated string.\n\n Return:\n   ``0`` if canonization successful, or a ``negative value`` otherwise.\n   Error codes are defined in :c:enum:`zp_keyexpr_canon_status_t`."]
    pub fn z_keyexpr_canonize_null_terminated(start: *mut ::core::ffi::c_char) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr contains another keyexpr in its set.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if ``l`` includes ``r``, i.e. the set defined by ``l`` contains every key belonging to the set\n   defined by ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_includes(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if a given keyexpr intersects with another keyexpr.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if keyexprs intersect, i.e. there exists at least one key which is contained in both of the\n   sets defined by ``l`` and ``r``. Otherwise, returns ``false``."]
    pub fn z_keyexpr_intersects(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t)
    -> bool;
}
unsafe extern "C" {
    #[doc = " Checks if two keyexpr are equal.\n\n Parameters:\n   l: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n   r: Pointer to a :c:type:`z_loaned_keyexpr_t`.\n\n Return:\n   ``true`` if both ``l`` and ``r`` are equal. Otherwise, returns  ``false``."]
    pub fn z_keyexpr_equals(l: *const z_loaned_keyexpr_t, r: *const z_loaned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a new, zenoh-allocated, default configuration.\n It consists in a default set of properties for zenoh session configuration.\n\n Parameters:\n   config: Pointer to uninitialized :c:type:`z_owned_config_t`.\n\n Return:\n   ``0`` in case of success, or a ``negative value`` otherwise."]
    pub fn z_config_default(config: *mut z_owned_config_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the property with the given integer key from the configuration.\n\n Parameters:\n   config: Pointer to a :c:type:`z_loaned_config_t` to get the property from.\n   key: Integer key of the requested property.\n\n Return:\n   The requested property value."]
    pub fn zp_config_get(config: *const z_loaned_config_t, key: u8) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Inserts or replaces the property with the given integer key in the configuration.\n\n Parameters:\n   config: Pointer to a :c:type:`z_loaned_config_t` to modify.\n   key: Integer key of the property to be inserted.\n   value: Property value to be inserted.\n\n Return:\n   ``0`` if insertion is successful, ``negative value`` otherwise."]
    pub fn zp_config_insert(
        config: *mut z_loaned_config_t,
        key: u8,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the null terminated string to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_str(
        encoding: *mut z_owned_encoding_t,
        s: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_encoding_t` from a null terminated string.\n\n Parameters:\n   encoding: Pointer to an uninitialized :c:type:`z_owned_encoding_t`.\n   s: Pointer to the string to use.\n   len: Number of characters from the string s to use.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_from_substr(
        encoding: *mut z_owned_encoding_t,
        s: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a null-terminated string. Zenoh does not define what a schema is and its\n semantics is left to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the null terminated string to use as a schema.\n\n Return:\n   ``0`` in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_str(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sets a schema to this encoding from a substring. Zenoh does not define what a schema is and its semantics is left\n to the implementer. E.g. a common schema for `text/plain` encoding is `utf-8`.\n\n Parameters:\n   encoding: Pointer to initialized :c:type:`z_loaned_encoding_t`.\n   schema: Pointer to the substring start.\n   len: Number of characters to consider.\n\n Return:\n   ``0`` if in case of success,``negative value`` otherwise."]
    pub fn z_encoding_set_schema_from_substr(
        encoding: *mut z_loaned_encoding_t,
        schema: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a string from a :c:type:`z_loaned_encoding_t`.\n\n Parameters:\n   encoding: Pointer to the :c:type:`z_loaned_encoding_t` to use.\n   string: Pointer to an uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if creation is successful,``negative value`` otherwise."]
    pub fn z_encoding_to_string(
        encoding: *const z_loaned_encoding_t,
        string: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if two encodings are equal.\n\n Parameters:\n   left: Pointer to the first :c:type:`z_loaned_encoding_t` to compare.\n   right: Pointer to the second :c:type:`z_loaned_encoding_t` to compare.\n\n Return:\n   ``true`` if `left` equals `right`, ``false`` otherwise."]
    pub fn z_encoding_equals(
        left: *const z_loaned_encoding_t,
        right: *const z_loaned_encoding_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the bytes data from a reply error payload by aliasing it.\n\n Parameters:\n   reply_err: Pointer to a :c:type:`z_loaned_reply_err_t` to get data from.\n\n Return:\n   Pointer to the data as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_reply_err_payload(reply_err: *const z_loaned_reply_err_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a reply error encoding by aliasing it.\n\n Parameters:\n   reply_err: Pointer to the :c:type:`z_loaned_reply_err_t` to get the encoding from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_reply_err_encoding(
        reply_err: *const z_loaned_reply_err_t,
    ) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by copying a buffer into it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data that will be copied into slice.\n   len: Number of bytes to copy.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_copy_from_buf(
        slice: *mut z_owned_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_slice_t` by transferring ownership over a data to it.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`.\n   data: Pointer to the data to be owned by `slice`.\n   len: Number of bytes in `data`.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `slice` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_slice_from_buf(
        slice: *mut z_owned_slice_t,
        data: *mut u8,
        len: usize,
        deleter: ::core::option::Option<
            unsafe extern "C" fn(data: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_view_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_view_slice_t`.\n   data: Pointer to the data to be pointed by `slice`.\n   len: Number of bytes in `data`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_view_slice_from_buf(
        slice: *mut z_view_slice_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_slice_t`.\n\n Parameters:\n   slice: Pointer to an uninitialized :c:type:`z_owned_slice_t`."]
    pub fn z_slice_empty(slice: *mut z_owned_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets date pointer of a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get data from.\n\n Return:\n   The data pointer."]
    pub fn z_slice_data(slice: *const z_loaned_slice_t) -> *const u8;
}
unsafe extern "C" {
    #[doc = " Gets the total number of bytes in a bytes array.\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to get length from.\n\n Return:\n   The number of bytes."]
    pub fn z_slice_len(slice: *const z_loaned_slice_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if slice is empty\n\n Parameters:\n   slice: Pointer to a :c:type:`z_loaned_slice_t` to check.\n\n Return:\n   ``true`` if the container is empty, ``false`` otherwise."]
    pub fn z_slice_is_empty(slice: *const z_loaned_slice_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_slice_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   dst: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the decoded slice.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_slice(
        bytes: *const z_loaned_bytes_t,
        dst: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_string_t`\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the decoded string.\n\n Return:\n   ``0`` if decode is successful, or a ``negative value`` otherwise."]
    pub fn z_bytes_to_string(
        bytes: *const z_loaned_bytes_t,
        str_: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert. The slice will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *mut z_moved_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a slice into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded slice.\n   slice: Pointer to the slice to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert. Ownership is transferred to the `bytes`.\n   len: Number of bytes to consider.\n   deleter: A thread-safe delete function to free the `data`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `data` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *mut u8,
        len: usize,
        deleter: ::core::option::Option<
            unsafe extern "C" fn(data: *mut ::core::ffi::c_void, context: *mut ::core::ffi::c_void),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts data into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the data to convert.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts statically allocated constant data into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded data.\n   data: Pointer to the statically allocated constant data to encode.\n   len: Number of bytes to consider.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_buf(
        bytes: *mut z_owned_bytes_t,
        data: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert. The string will be consumed upon function return.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_string(bytes: *mut z_owned_bytes_t, s: *mut z_moved_string_t)
    -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   s: Pointer to the string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_string(
        bytes: *mut z_owned_bytes_t,
        s: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts. Ownership is transferred to the `bytes`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `bytes` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *mut ::core::ffi::c_char,
        deleter: ::core::option::Option<
            unsafe extern "C" fn(
                value: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a null-terminated string into a :c:type:`z_owned_bytes_t` by copying.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the string to converts.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_copy_from_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Converts a statically allocated constant null-terminated string into a :c:type:`z_owned_bytes_t` by aliasing.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the encoded string.\n   value: Pointer to the statically allocated constant string to convert.\n\n Return:\n   ``0`` if conversion is successful, ``negative value`` otherwise."]
    pub fn z_bytes_from_static_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs an empty payload.\n\n Parameters:\n   bytes: Pointer to an unitialized :c:type:`z_loaned_bytes_t` instance."]
    pub fn z_bytes_empty(bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Returns total number of bytes in the container.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   Number of the bytes in the container."]
    pub fn z_bytes_len(bytes: *const z_loaned_bytes_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Checks if container is empty\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to decode.\n\n Return:\n   ``true`` if conainer is empty,  ``false`` otherwise."]
    pub fn z_bytes_is_empty(bytes: *const z_loaned_bytes_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Attempts to get a contiguous view to the underlying bytes (unstable).\n\n This is only possible if data is not fragmented, otherwise the function will fail.\n In case of fragmented data, consider using `z_bytes_get_slice_iterator()`.\n\n Parameters:\n   bytes: An instance of Zenoh data.\n   view: An uninitialized memory location where a contiguous view on data will be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_get_contiguous_view(
        bytes: *const z_loaned_bytes_t,
        view: *mut z_view_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns an iterator on raw bytes slices contained in the `z_loaned_bytes_t`.\n\n Zenoh may store data in non-contiguous regions of memory, this iterator\n then allows to access raw data directly without any attempt of deserializing it.\n Please note that no guarantee is provided on the internal memory layout.\n The only provided guarantee is on the bytes order that is preserved.\n\n Parameters:\n   bytes: Data to iterate over.\n\n Return:\n   The constructed :c:type:`z_bytes_slice_iterator_t`."]
    pub fn z_bytes_get_slice_iterator(bytes: *const z_loaned_bytes_t) -> z_bytes_slice_iterator_t;
}
unsafe extern "C" {
    #[doc = " Constructs :c:type:`z_view_slice_t` providing view to the next slice.\n\n Parameters:\n   iter: An iterator over slices of serialized data.\n   out: An uninitialized :c:type:`z_view_slice_t` that will contain next slice.\n\n Return:\n   ``false`` when iterator reaches the end,  ``true`` otherwise."]
    pub fn z_bytes_slice_iterator_next(
        iter: *mut z_bytes_slice_iterator_t,
        out: *mut z_view_slice_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns a reader for the `bytes`.\n\n The `bytes` should outlive the reader and should not be modified, while reader is in use.\n\n Parameters:\n   bytes: Data to read.\n\n Return:\n   The constructed :c:type:`z_bytes_reader_t`."]
    pub fn z_bytes_get_reader(bytes: *const z_loaned_bytes_t) -> z_bytes_reader_t;
}
unsafe extern "C" {
    #[doc = " Reads data into specified destination.\n\n Parameters:\n   reader: Data reader to read from.\n   dst: Buffer where the read data is written.\n   len: Maximum number of bytes to read.\n\n Return:\n   Number of bytes read. If return value is smaller than `len`, it means that the end of the data was reached."]
    pub fn z_bytes_reader_read(reader: *mut z_bytes_reader_t, dst: *mut u8, len: usize) -> usize;
}
unsafe extern "C" {
    #[doc = " Sets the `reader` position indicator for the payload to the value pointed to by offset.\n The new position is exactly `offset` bytes measured from the beginning of the payload if origin is `SEEK_SET`,\n from the current reader position if origin is `SEEK_CUR`, and from the end of the payload if origin is `SEEK_END`.\n\n Parameters:\n   reader: Data reader to reposition.\n   offset: New position ffset in bytes.\n   origin: Origin for the new position.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_reader_seek(
        reader: *mut z_bytes_reader_t,
        offset: i64,
        origin: ::core::ffi::c_int,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the read position indicator.\n\n Parameters:\n   reader: Data reader to get position of.\n\n Return:\n   Read position indicator on success or -1L if failure occurs."]
    pub fn z_bytes_reader_tell(reader: *mut z_bytes_reader_t) -> i64;
}
unsafe extern "C" {
    #[doc = " Gets number of bytes that can still be read.\n\n Parameters:\n   reader: Data reader.\n\n Return:\n   Number of bytes that can still be read."]
    pub fn z_bytes_reader_remaining(reader: *const z_bytes_reader_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Constructs an empty writer for payload.\n\n Parameters:\n   writer: An uninitialized memory location where writer is to be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_bytes_writer_empty(writer: *mut z_owned_bytes_writer_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Finishes writing and returns underlying bytes.\n\n Parameters:\n   writer: A data writer.\n   bytes: An uninitialized memory location where bytes is to be constructed."]
    pub fn z_bytes_writer_finish(writer: *mut z_moved_bytes_writer_t, bytes: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    #[doc = " Writes `len` bytes from `src` into underlying :c:type:`z_loaned_bytes_t`.\n\n Parameters:\n   writer: A data writer.\n   src: Buffer to write from.\n   len: Number of bytes to write.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_write_all(
        writer: *mut z_loaned_bytes_writer_t,
        src: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Appends bytes.\n This allows to compose a serialized data out of multiple `z_owned_bytes_t` that may point to different memory\n regions. Said in other terms, it allows to create a linear view on different memory regions without copy.\n\n Parameters:\n   writer: A data writer.\n   bytes: A data to append.\n\n Return:\n   ``0`` if write is successful, ``negative value`` otherwise."]
    pub fn z_bytes_writer_append(
        writer: *mut z_loaned_bytes_writer_t,
        bytes: *mut z_moved_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Create timestamp.\n\n Parameters:\n   ts: An uninitialized :c:type:`z_timestamp_t`.\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   ``0`` if encode is successful, ``negative value`` otherwise (for example if RTC is not available on the system)."]
    pub fn z_timestamp_new(ts: *mut z_timestamp_t, zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns NTP64 time associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   NTP64 time value"]
    pub fn z_timestamp_ntp64_time(ts: *const z_timestamp_t) -> u64;
}
unsafe extern "C" {
    #[doc = " Returns id associated with this timestamp.\n\n Parameters:\n   ts: Pointer to the valid :c:type:`z_timestamp_t`.\n\n Return:\n   Associated id represented by c:type:`z_id_t`"]
    pub fn z_timestamp_id(ts: *const z_timestamp_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Creates an entity global id.\n\n Parameters:\n   gid: An uninitialized :c:type:`z_entity_global_id_t`.\n   zid: Pointer to a :c:type:`z_id_t` zenoh id.\n   eid: :c:type:`uint32_t` entity id."]
    pub fn z_entity_global_id_new(
        gid: *mut z_entity_global_id_t,
        zid: *const z_id_t,
        eid: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the entity id of the entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Entity id represented by c:type:`uint32_t`."]
    pub fn z_entity_global_id_eid(gid: *const z_entity_global_id_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the zenoh id of entity global id.\n\n Parameters:\n   gid: Pointer to the valid :c:type:`z_entity_global_id_t`.\n\n Return:\n   Zenoh id represented by c:type:`z_id_t`."]
    pub fn z_entity_global_id_zid(gid: *const z_entity_global_id_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new source info.\n\n Parameters:\n   info: An uninitialized :c:type:`z_owned_source_info_t`.\n   source_id: Pointer to a :c:type:`z_entity_global_id_t` global entity id.\n   source_sn: :c:type:`uint32_t` sequence number.\n\n Return:\n   ``0`` if construction is successful, ``negative value`` otherwise.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_new(
        info: *mut z_owned_source_info_t,
        source_id: *const z_entity_global_id_t,
        source_sn: u32,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   :c:type:`uint32_t` sequence number.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_sn(info: *const z_loaned_source_info_t) -> u32;
}
unsafe extern "C" {
    #[doc = " Returns the sequence number associated with this source info.\n\n Parameters:\n   info: Pointer to the :c:type:`z_loaned_source_info_t` to get the parameters from.\n\n Return:\n   Global entity ID as a :c:type:`z_entity_global_id_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_source_info_id(info: *const z_loaned_source_info_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Builds a default query target.\n\n Return:\n   The constructed :c:type:`z_query_target_t`."]
    pub fn z_query_target_default() -> z_query_target_t;
}
unsafe extern "C" {
    #[doc = " Builds an automatic query consolidation :c:type:`z_query_consolidation_t`.\n\n A query consolidation strategy will automatically be selected depending on the query selector.\n If selector contains time range properties, no consolidation is performed.\n Otherwise the :c:func:`z_query_consolidation_latest` strategy is used.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_auto() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a default :c:type:`z_query_consolidation_t`.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_default() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a latest query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy optimizes bandwidth on all links in the system but will provide a very poor latency.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_latest() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a monotonic query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy offers the best latency. Replies are directly transmitted to the application when received\n without needing to wait for all replies. This mode does not guarantee that there will be no duplicates.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_monotonic() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Builds a no query consolidation :c:type:`z_query_consolidation_t`.\n\n This strategy is useful when querying timeseries data bases or when using quorums.\n\n Return:\n   The constructed :c:type:`z_query_consolidation_t`."]
    pub fn z_query_consolidation_none() -> z_query_consolidation_t;
}
unsafe extern "C" {
    #[doc = " Gets a query parameters field.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the parameters from.\n   parameters: Pointer to an uninitialized :c:type:`z_view_string_t` to contain the parameters."]
    pub fn z_query_parameters(query: *const z_loaned_query_t, parameters: *mut z_view_string_t);
}
unsafe extern "C" {
    #[doc = " Gets a query payload by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the payload as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_payload(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query encoding by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the value from.\n\n Return:\n   Pointer to the encoding as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_query_encoding(query: *const z_loaned_query_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets a query attachment value by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_query_attachment(query: *const z_loaned_query_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets a query keyexpr by aliasing it.\n\n Parameters:\n   query: Pointer to the :c:type:`z_loaned_query_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a:c:type:`z_keyexpr_t`."]
    pub fn z_query_keyexpr(query: *const z_loaned_query_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new sample closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_sample_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_sample(
        closure: *mut z_owned_closure_sample_t,
        call: z_closure_sample_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a sample closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_sample_t` to call.\n   sample: Pointer to the :c:type:`z_loaned_sample_t` to pass to the closure."]
    pub fn z_closure_sample_call(
        closure: *const z_loaned_closure_sample_t,
        sample: *mut z_loaned_sample_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new query closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_query_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_query(
        closure: *mut z_owned_closure_query_t,
        call: z_closure_query_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a query closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_query_t` to call.\n   query: Pointer to the :c:type:`z_loaned_query_t` to pass to the closure."]
    pub fn z_closure_query_call(
        closure: *const z_loaned_closure_query_t,
        query: *mut z_loaned_query_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new reply closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_reply_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_reply(
        closure: *mut z_owned_closure_reply_t,
        call: z_closure_reply_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a reply closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_reply_t` to call.\n   reply: Pointer to the :c:type:`z_loaned_reply_t` to pass to the closure."]
    pub fn z_closure_reply_call(
        closure: *const z_loaned_closure_reply_t,
        reply: *mut z_loaned_reply_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new hello closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_hello_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_hello(
        closure: *mut z_owned_closure_hello_t,
        call: z_closure_hello_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a hello closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_hello_t` to call.\n   hello: Pointer to the :c:type:`z_loaned_hello_t` to pass to the closure."]
    pub fn z_closure_hello_call(
        closure: *const z_loaned_closure_hello_t,
        hello: *mut z_loaned_hello_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new zid closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_zid_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_zid(
        closure: *mut z_owned_closure_zid_t,
        call: z_closure_zid_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a zid closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_zid_t` to call.\n   zid: Pointer to the :c:type:`z_id_t` to pass to the closure."]
    pub fn z_closure_zid_call(closure: *const z_loaned_closure_zid_t, id: *const z_id_t);
}
unsafe extern "C" {
    #[doc = " Builds a new matching status closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`z_owned_closure_matching_status_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise"]
    pub fn z_closure_matching_status(
        closure: *mut z_owned_closure_matching_status_t,
        call: z_closure_matching_status_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a matching status closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`z_loaned_closure_matching_status_t` to call.\n   status: Pointer to the :c:type:`z_matching_status_t` to pass to the closure."]
    pub fn z_closure_matching_status_call(
        closure: *const z_loaned_closure_matching_status_t,
        status: *const z_matching_status_t,
    );
}
unsafe extern "C" {
    #[doc = " Builds a new sample miss closure.\n It consists of a structure that contains all the elements for stateful, memory-leak-free callbacks.\n\n Parameters:\n   closure: Pointer to an uninitialized :c:type:`ze_owned_closure_miss_t`.\n   call: Pointer to the callback function. ``context`` will be passed as its last argument.\n   drop: Pointer to the function that will free the callback state. ``context`` will be passed as its last argument.\n   context: Pointer to an arbitrary state.\n\n Return:\n   ``0`` in case of success, negative error code otherwise\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn ze_closure_miss(
        closure: *mut ze_owned_closure_miss_t,
        call: ze_closure_miss_callback_t,
        drop: z_closure_drop_callback_t,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Calls a sample miss closure.\n\n Parameters:\n   closure: Pointer to the :c:type:`ze_loaned_closure_miss_t` to call.\n   status: Pointer to the :c:type:`ze_miss_t` to pass to the closure.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn ze_closure_miss_call(closure: *const ze_loaned_closure_miss_t, miss: *const ze_miss_t);
}
unsafe extern "C" {
    pub fn z_internal_string_null(obj: *mut z_owned_string_t);
}
unsafe extern "C" {
    pub fn z_internal_string_check(obj: *const z_owned_string_t) -> bool;
}
unsafe extern "C" {
    pub fn z_string_loan(obj: *const z_owned_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    pub fn z_string_loan_mut(obj: *mut z_owned_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    pub fn z_string_move(obj: *mut z_owned_string_t) -> *mut z_moved_string_t;
}
unsafe extern "C" {
    pub fn z_string_take(obj: *mut z_owned_string_t, src: *mut z_moved_string_t);
}
unsafe extern "C" {
    pub fn z_string_drop(obj: *mut z_moved_string_t);
}
unsafe extern "C" {
    pub fn z_string_take_from_loaned(
        dst: *mut z_owned_string_t,
        src: *mut z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_string_clone(obj: *mut z_owned_string_t, src: *const z_loaned_string_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_keyexpr_null(obj: *mut z_owned_keyexpr_t);
}
unsafe extern "C" {
    pub fn z_internal_keyexpr_check(obj: *const z_owned_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn z_keyexpr_loan(obj: *const z_owned_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    pub fn z_keyexpr_loan_mut(obj: *mut z_owned_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    pub fn z_keyexpr_move(obj: *mut z_owned_keyexpr_t) -> *mut z_moved_keyexpr_t;
}
unsafe extern "C" {
    pub fn z_keyexpr_take(obj: *mut z_owned_keyexpr_t, src: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    pub fn z_keyexpr_drop(obj: *mut z_moved_keyexpr_t);
}
unsafe extern "C" {
    pub fn z_keyexpr_take_from_loaned(
        dst: *mut z_owned_keyexpr_t,
        src: *mut z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_keyexpr_clone(
        obj: *mut z_owned_keyexpr_t,
        src: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_config_null(obj: *mut z_owned_config_t);
}
unsafe extern "C" {
    pub fn z_internal_config_check(obj: *const z_owned_config_t) -> bool;
}
unsafe extern "C" {
    pub fn z_config_loan(obj: *const z_owned_config_t) -> *const z_loaned_config_t;
}
unsafe extern "C" {
    pub fn z_config_loan_mut(obj: *mut z_owned_config_t) -> *mut z_loaned_config_t;
}
unsafe extern "C" {
    pub fn z_config_move(obj: *mut z_owned_config_t) -> *mut z_moved_config_t;
}
unsafe extern "C" {
    pub fn z_config_take(obj: *mut z_owned_config_t, src: *mut z_moved_config_t);
}
unsafe extern "C" {
    pub fn z_config_drop(obj: *mut z_moved_config_t);
}
unsafe extern "C" {
    pub fn z_config_take_from_loaned(
        dst: *mut z_owned_config_t,
        src: *mut z_loaned_config_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_config_clone(obj: *mut z_owned_config_t, src: *const z_loaned_config_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_session_null(obj: *mut z_owned_session_t);
}
unsafe extern "C" {
    pub fn z_internal_session_check(obj: *const z_owned_session_t) -> bool;
}
unsafe extern "C" {
    pub fn z_session_loan(obj: *const z_owned_session_t) -> *const z_loaned_session_t;
}
unsafe extern "C" {
    pub fn z_session_loan_mut(obj: *mut z_owned_session_t) -> *mut z_loaned_session_t;
}
unsafe extern "C" {
    pub fn z_session_move(obj: *mut z_owned_session_t) -> *mut z_moved_session_t;
}
unsafe extern "C" {
    pub fn z_session_take(obj: *mut z_owned_session_t, src: *mut z_moved_session_t);
}
unsafe extern "C" {
    pub fn z_session_drop(obj: *mut z_moved_session_t);
}
unsafe extern "C" {
    pub fn z_internal_subscriber_null(obj: *mut z_owned_subscriber_t);
}
unsafe extern "C" {
    pub fn z_internal_subscriber_check(obj: *const z_owned_subscriber_t) -> bool;
}
unsafe extern "C" {
    pub fn z_subscriber_loan(obj: *const z_owned_subscriber_t) -> *const z_loaned_subscriber_t;
}
unsafe extern "C" {
    pub fn z_subscriber_loan_mut(obj: *mut z_owned_subscriber_t) -> *mut z_loaned_subscriber_t;
}
unsafe extern "C" {
    pub fn z_subscriber_move(obj: *mut z_owned_subscriber_t) -> *mut z_moved_subscriber_t;
}
unsafe extern "C" {
    pub fn z_subscriber_take(obj: *mut z_owned_subscriber_t, src: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    pub fn z_subscriber_drop(obj: *mut z_moved_subscriber_t);
}
unsafe extern "C" {
    pub fn z_internal_publisher_null(obj: *mut z_owned_publisher_t);
}
unsafe extern "C" {
    pub fn z_internal_publisher_check(obj: *const z_owned_publisher_t) -> bool;
}
unsafe extern "C" {
    pub fn z_publisher_loan(obj: *const z_owned_publisher_t) -> *const z_loaned_publisher_t;
}
unsafe extern "C" {
    pub fn z_publisher_loan_mut(obj: *mut z_owned_publisher_t) -> *mut z_loaned_publisher_t;
}
unsafe extern "C" {
    pub fn z_publisher_move(obj: *mut z_owned_publisher_t) -> *mut z_moved_publisher_t;
}
unsafe extern "C" {
    pub fn z_publisher_take(obj: *mut z_owned_publisher_t, src: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    pub fn z_publisher_drop(obj: *mut z_moved_publisher_t);
}
unsafe extern "C" {
    pub fn z_internal_querier_null(obj: *mut z_owned_querier_t);
}
unsafe extern "C" {
    pub fn z_internal_querier_check(obj: *const z_owned_querier_t) -> bool;
}
unsafe extern "C" {
    pub fn z_querier_loan(obj: *const z_owned_querier_t) -> *const z_loaned_querier_t;
}
unsafe extern "C" {
    pub fn z_querier_loan_mut(obj: *mut z_owned_querier_t) -> *mut z_loaned_querier_t;
}
unsafe extern "C" {
    pub fn z_querier_move(obj: *mut z_owned_querier_t) -> *mut z_moved_querier_t;
}
unsafe extern "C" {
    pub fn z_querier_take(obj: *mut z_owned_querier_t, src: *mut z_moved_querier_t);
}
unsafe extern "C" {
    pub fn z_querier_drop(obj: *mut z_moved_querier_t);
}
unsafe extern "C" {
    pub fn z_internal_matching_listener_null(obj: *mut z_owned_matching_listener_t);
}
unsafe extern "C" {
    pub fn z_internal_matching_listener_check(obj: *const z_owned_matching_listener_t) -> bool;
}
unsafe extern "C" {
    pub fn z_matching_listener_loan(
        obj: *const z_owned_matching_listener_t,
    ) -> *const z_loaned_matching_listener_t;
}
unsafe extern "C" {
    pub fn z_matching_listener_loan_mut(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_loaned_matching_listener_t;
}
unsafe extern "C" {
    pub fn z_matching_listener_move(
        obj: *mut z_owned_matching_listener_t,
    ) -> *mut z_moved_matching_listener_t;
}
unsafe extern "C" {
    pub fn z_matching_listener_take(
        obj: *mut z_owned_matching_listener_t,
        src: *mut z_moved_matching_listener_t,
    );
}
unsafe extern "C" {
    pub fn z_matching_listener_drop(obj: *mut z_moved_matching_listener_t);
}
unsafe extern "C" {
    pub fn z_internal_queryable_null(obj: *mut z_owned_queryable_t);
}
unsafe extern "C" {
    pub fn z_internal_queryable_check(obj: *const z_owned_queryable_t) -> bool;
}
unsafe extern "C" {
    pub fn z_queryable_loan(obj: *const z_owned_queryable_t) -> *const z_loaned_queryable_t;
}
unsafe extern "C" {
    pub fn z_queryable_loan_mut(obj: *mut z_owned_queryable_t) -> *mut z_loaned_queryable_t;
}
unsafe extern "C" {
    pub fn z_queryable_move(obj: *mut z_owned_queryable_t) -> *mut z_moved_queryable_t;
}
unsafe extern "C" {
    pub fn z_queryable_take(obj: *mut z_owned_queryable_t, src: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    pub fn z_queryable_drop(obj: *mut z_moved_queryable_t);
}
unsafe extern "C" {
    pub fn z_internal_hello_null(obj: *mut z_owned_hello_t);
}
unsafe extern "C" {
    pub fn z_internal_hello_check(obj: *const z_owned_hello_t) -> bool;
}
unsafe extern "C" {
    pub fn z_hello_loan(obj: *const z_owned_hello_t) -> *const z_loaned_hello_t;
}
unsafe extern "C" {
    pub fn z_hello_loan_mut(obj: *mut z_owned_hello_t) -> *mut z_loaned_hello_t;
}
unsafe extern "C" {
    pub fn z_hello_move(obj: *mut z_owned_hello_t) -> *mut z_moved_hello_t;
}
unsafe extern "C" {
    pub fn z_hello_take(obj: *mut z_owned_hello_t, src: *mut z_moved_hello_t);
}
unsafe extern "C" {
    pub fn z_hello_drop(obj: *mut z_moved_hello_t);
}
unsafe extern "C" {
    pub fn z_hello_take_from_loaned(
        dst: *mut z_owned_hello_t,
        src: *mut z_loaned_hello_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_hello_clone(obj: *mut z_owned_hello_t, src: *const z_loaned_hello_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_reply_null(obj: *mut z_owned_reply_t);
}
unsafe extern "C" {
    pub fn z_internal_reply_check(obj: *const z_owned_reply_t) -> bool;
}
unsafe extern "C" {
    pub fn z_reply_loan(obj: *const z_owned_reply_t) -> *const z_loaned_reply_t;
}
unsafe extern "C" {
    pub fn z_reply_loan_mut(obj: *mut z_owned_reply_t) -> *mut z_loaned_reply_t;
}
unsafe extern "C" {
    pub fn z_reply_move(obj: *mut z_owned_reply_t) -> *mut z_moved_reply_t;
}
unsafe extern "C" {
    pub fn z_reply_take(obj: *mut z_owned_reply_t, src: *mut z_moved_reply_t);
}
unsafe extern "C" {
    pub fn z_reply_drop(obj: *mut z_moved_reply_t);
}
unsafe extern "C" {
    pub fn z_reply_take_from_loaned(
        dst: *mut z_owned_reply_t,
        src: *mut z_loaned_reply_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_reply_clone(obj: *mut z_owned_reply_t, src: *const z_loaned_reply_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_string_array_null(obj: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    pub fn z_internal_string_array_check(obj: *const z_owned_string_array_t) -> bool;
}
unsafe extern "C" {
    pub fn z_string_array_loan(
        obj: *const z_owned_string_array_t,
    ) -> *const z_loaned_string_array_t;
}
unsafe extern "C" {
    pub fn z_string_array_loan_mut(
        obj: *mut z_owned_string_array_t,
    ) -> *mut z_loaned_string_array_t;
}
unsafe extern "C" {
    pub fn z_string_array_move(obj: *mut z_owned_string_array_t) -> *mut z_moved_string_array_t;
}
unsafe extern "C" {
    pub fn z_string_array_take(obj: *mut z_owned_string_array_t, src: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    pub fn z_string_array_drop(obj: *mut z_moved_string_array_t);
}
unsafe extern "C" {
    pub fn z_string_array_take_from_loaned(
        dst: *mut z_owned_string_array_t,
        src: *mut z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_string_array_clone(
        obj: *mut z_owned_string_array_t,
        src: *const z_loaned_string_array_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_sample_null(obj: *mut z_owned_sample_t);
}
unsafe extern "C" {
    pub fn z_internal_sample_check(obj: *const z_owned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Loans a :c:type:`z_owned_sample_t`.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_owned_sample_t` to loan.\n\n Return:\n   Pointer to the loaned sample as a :c:type:`z_loaned_sample_t`."]
    pub fn z_sample_loan(obj: *const z_owned_sample_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    pub fn z_sample_loan_mut(obj: *mut z_owned_sample_t) -> *mut z_loaned_sample_t;
}
unsafe extern "C" {
    pub fn z_sample_move(obj: *mut z_owned_sample_t) -> *mut z_moved_sample_t;
}
unsafe extern "C" {
    pub fn z_sample_take(obj: *mut z_owned_sample_t, src: *mut z_moved_sample_t);
}
unsafe extern "C" {
    pub fn z_sample_drop(obj: *mut z_moved_sample_t);
}
unsafe extern "C" {
    pub fn z_sample_take_from_loaned(
        dst: *mut z_owned_sample_t,
        src: *mut z_loaned_sample_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_sample_clone(obj: *mut z_owned_sample_t, src: *const z_loaned_sample_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_source_info_null(obj: *mut z_owned_source_info_t);
}
unsafe extern "C" {
    pub fn z_internal_source_info_check(obj: *const z_owned_source_info_t) -> bool;
}
unsafe extern "C" {
    pub fn z_source_info_loan(obj: *const z_owned_source_info_t) -> *const z_loaned_source_info_t;
}
unsafe extern "C" {
    pub fn z_source_info_loan_mut(obj: *mut z_owned_source_info_t) -> *mut z_loaned_source_info_t;
}
unsafe extern "C" {
    pub fn z_source_info_move(obj: *mut z_owned_source_info_t) -> *mut z_moved_source_info_t;
}
unsafe extern "C" {
    pub fn z_source_info_take(obj: *mut z_owned_source_info_t, src: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    pub fn z_source_info_drop(obj: *mut z_moved_source_info_t);
}
unsafe extern "C" {
    pub fn z_source_info_take_from_loaned(
        dst: *mut z_owned_source_info_t,
        src: *mut z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_source_info_clone(
        obj: *mut z_owned_source_info_t,
        src: *const z_loaned_source_info_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_query_null(obj: *mut z_owned_query_t);
}
unsafe extern "C" {
    pub fn z_internal_query_check(obj: *const z_owned_query_t) -> bool;
}
unsafe extern "C" {
    pub fn z_query_loan(obj: *const z_owned_query_t) -> *const z_loaned_query_t;
}
unsafe extern "C" {
    pub fn z_query_loan_mut(obj: *mut z_owned_query_t) -> *mut z_loaned_query_t;
}
unsafe extern "C" {
    pub fn z_query_move(obj: *mut z_owned_query_t) -> *mut z_moved_query_t;
}
unsafe extern "C" {
    pub fn z_query_take(obj: *mut z_owned_query_t, src: *mut z_moved_query_t);
}
unsafe extern "C" {
    pub fn z_query_drop(obj: *mut z_moved_query_t);
}
unsafe extern "C" {
    pub fn z_query_take_from_loaned(
        dst: *mut z_owned_query_t,
        src: *mut z_loaned_query_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_query_clone(obj: *mut z_owned_query_t, src: *const z_loaned_query_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_slice_null(obj: *mut z_owned_slice_t);
}
unsafe extern "C" {
    pub fn z_internal_slice_check(obj: *const z_owned_slice_t) -> bool;
}
unsafe extern "C" {
    pub fn z_slice_loan(obj: *const z_owned_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    pub fn z_slice_loan_mut(obj: *mut z_owned_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    pub fn z_slice_move(obj: *mut z_owned_slice_t) -> *mut z_moved_slice_t;
}
unsafe extern "C" {
    pub fn z_slice_take(obj: *mut z_owned_slice_t, src: *mut z_moved_slice_t);
}
unsafe extern "C" {
    pub fn z_slice_drop(obj: *mut z_moved_slice_t);
}
unsafe extern "C" {
    pub fn z_slice_take_from_loaned(
        dst: *mut z_owned_slice_t,
        src: *mut z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_slice_clone(obj: *mut z_owned_slice_t, src: *const z_loaned_slice_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_bytes_null(obj: *mut z_owned_bytes_t);
}
unsafe extern "C" {
    pub fn z_internal_bytes_check(obj: *const z_owned_bytes_t) -> bool;
}
unsafe extern "C" {
    pub fn z_bytes_loan(obj: *const z_owned_bytes_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    pub fn z_bytes_loan_mut(obj: *mut z_owned_bytes_t) -> *mut z_loaned_bytes_t;
}
unsafe extern "C" {
    pub fn z_bytes_move(obj: *mut z_owned_bytes_t) -> *mut z_moved_bytes_t;
}
unsafe extern "C" {
    pub fn z_bytes_take(obj: *mut z_owned_bytes_t, src: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    pub fn z_bytes_drop(obj: *mut z_moved_bytes_t);
}
unsafe extern "C" {
    pub fn z_bytes_take_from_loaned(
        dst: *mut z_owned_bytes_t,
        src: *mut z_loaned_bytes_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_bytes_clone(obj: *mut z_owned_bytes_t, src: *const z_loaned_bytes_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_bytes_writer_null(obj: *mut z_owned_bytes_writer_t);
}
unsafe extern "C" {
    pub fn z_internal_bytes_writer_check(obj: *const z_owned_bytes_writer_t) -> bool;
}
unsafe extern "C" {
    pub fn z_bytes_writer_loan(
        obj: *const z_owned_bytes_writer_t,
    ) -> *const z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    pub fn z_bytes_writer_loan_mut(
        obj: *mut z_owned_bytes_writer_t,
    ) -> *mut z_loaned_bytes_writer_t;
}
unsafe extern "C" {
    pub fn z_bytes_writer_move(obj: *mut z_owned_bytes_writer_t) -> *mut z_moved_bytes_writer_t;
}
unsafe extern "C" {
    pub fn z_bytes_writer_take(obj: *mut z_owned_bytes_writer_t, src: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    pub fn z_bytes_writer_drop(obj: *mut z_moved_bytes_writer_t);
}
unsafe extern "C" {
    pub fn z_bytes_writer_take_from_loaned(
        dst: *mut z_owned_bytes_writer_t,
        src: *mut z_loaned_bytes_writer_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_reply_err_null(obj: *mut z_owned_reply_err_t);
}
unsafe extern "C" {
    pub fn z_internal_reply_err_check(obj: *const z_owned_reply_err_t) -> bool;
}
unsafe extern "C" {
    pub fn z_reply_err_loan(obj: *const z_owned_reply_err_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    pub fn z_reply_err_loan_mut(obj: *mut z_owned_reply_err_t) -> *mut z_loaned_reply_err_t;
}
unsafe extern "C" {
    pub fn z_reply_err_move(obj: *mut z_owned_reply_err_t) -> *mut z_moved_reply_err_t;
}
unsafe extern "C" {
    pub fn z_reply_err_take(obj: *mut z_owned_reply_err_t, src: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    pub fn z_reply_err_drop(obj: *mut z_moved_reply_err_t);
}
unsafe extern "C" {
    pub fn z_reply_err_take_from_loaned(
        dst: *mut z_owned_reply_err_t,
        src: *mut z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_reply_err_clone(
        obj: *mut z_owned_reply_err_t,
        src: *const z_loaned_reply_err_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_encoding_null(obj: *mut z_owned_encoding_t);
}
unsafe extern "C" {
    pub fn z_internal_encoding_check(obj: *const z_owned_encoding_t) -> bool;
}
unsafe extern "C" {
    pub fn z_encoding_loan(obj: *const z_owned_encoding_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    pub fn z_encoding_loan_mut(obj: *mut z_owned_encoding_t) -> *mut z_loaned_encoding_t;
}
unsafe extern "C" {
    pub fn z_encoding_move(obj: *mut z_owned_encoding_t) -> *mut z_moved_encoding_t;
}
unsafe extern "C" {
    pub fn z_encoding_take(obj: *mut z_owned_encoding_t, src: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    pub fn z_encoding_drop(obj: *mut z_moved_encoding_t);
}
unsafe extern "C" {
    pub fn z_encoding_take_from_loaned(
        dst: *mut z_owned_encoding_t,
        src: *mut z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_encoding_clone(
        obj: *mut z_owned_encoding_t,
        src: *const z_loaned_encoding_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_sample_null(closure_sample: *mut z_owned_closure_sample_t);
}
unsafe extern "C" {
    pub fn z_internal_closure_sample_check(val: *const z_owned_closure_sample_t) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_sample_move(
        val: *mut z_owned_closure_sample_t,
    ) -> *mut z_moved_closure_sample_t;
}
unsafe extern "C" {
    pub fn z_closure_sample_take(
        obj: *mut z_owned_closure_sample_t,
        src: *mut z_moved_closure_sample_t,
    );
}
unsafe extern "C" {
    pub fn z_closure_sample_drop(obj: *mut z_moved_closure_sample_t);
}
unsafe extern "C" {
    pub fn z_closure_sample_loan(
        val: *const z_owned_closure_sample_t,
    ) -> *const z_loaned_closure_sample_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_query_null(closure_query: *mut z_owned_closure_query_t);
}
unsafe extern "C" {
    pub fn z_internal_closure_query_check(val: *const z_owned_closure_query_t) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_query_move(val: *mut z_owned_closure_query_t) -> *mut z_moved_closure_query_t;
}
unsafe extern "C" {
    pub fn z_closure_query_take(
        obj: *mut z_owned_closure_query_t,
        src: *mut z_moved_closure_query_t,
    );
}
unsafe extern "C" {
    pub fn z_closure_query_drop(obj: *mut z_moved_closure_query_t);
}
unsafe extern "C" {
    pub fn z_closure_query_loan(
        val: *const z_owned_closure_query_t,
    ) -> *const z_loaned_closure_query_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_reply_null(closure_reply: *mut z_owned_closure_reply_t);
}
unsafe extern "C" {
    pub fn z_internal_closure_reply_check(val: *const z_owned_closure_reply_t) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_reply_move(val: *mut z_owned_closure_reply_t) -> *mut z_moved_closure_reply_t;
}
unsafe extern "C" {
    pub fn z_closure_reply_take(
        obj: *mut z_owned_closure_reply_t,
        src: *mut z_moved_closure_reply_t,
    );
}
unsafe extern "C" {
    pub fn z_closure_reply_drop(obj: *mut z_moved_closure_reply_t);
}
unsafe extern "C" {
    pub fn z_closure_reply_loan(
        val: *const z_owned_closure_reply_t,
    ) -> *const z_loaned_closure_reply_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_hello_null(closure_hello: *mut z_owned_closure_hello_t);
}
unsafe extern "C" {
    pub fn z_internal_closure_hello_check(val: *const z_owned_closure_hello_t) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_hello_move(val: *mut z_owned_closure_hello_t) -> *mut z_moved_closure_hello_t;
}
unsafe extern "C" {
    pub fn z_closure_hello_take(
        obj: *mut z_owned_closure_hello_t,
        src: *mut z_moved_closure_hello_t,
    );
}
unsafe extern "C" {
    pub fn z_closure_hello_drop(obj: *mut z_moved_closure_hello_t);
}
unsafe extern "C" {
    pub fn z_closure_hello_loan(
        val: *const z_owned_closure_hello_t,
    ) -> *const z_loaned_closure_hello_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_zid_null(closure_zid: *mut z_owned_closure_zid_t);
}
unsafe extern "C" {
    pub fn z_internal_closure_zid_check(val: *const z_owned_closure_zid_t) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_zid_move(val: *mut z_owned_closure_zid_t) -> *mut z_moved_closure_zid_t;
}
unsafe extern "C" {
    pub fn z_closure_zid_take(obj: *mut z_owned_closure_zid_t, src: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    pub fn z_closure_zid_drop(obj: *mut z_moved_closure_zid_t);
}
unsafe extern "C" {
    pub fn z_closure_zid_loan(val: *const z_owned_closure_zid_t) -> *const z_loaned_closure_zid_t;
}
unsafe extern "C" {
    pub fn z_internal_closure_matching_status_null(
        closure_matching_status: *mut z_owned_closure_matching_status_t,
    );
}
unsafe extern "C" {
    pub fn z_internal_closure_matching_status_check(
        val: *const z_owned_closure_matching_status_t,
    ) -> bool;
}
unsafe extern "C" {
    pub fn z_closure_matching_status_move(
        val: *mut z_owned_closure_matching_status_t,
    ) -> *mut z_moved_closure_matching_status_t;
}
unsafe extern "C" {
    pub fn z_closure_matching_status_take(
        obj: *mut z_owned_closure_matching_status_t,
        src: *mut z_moved_closure_matching_status_t,
    );
}
unsafe extern "C" {
    pub fn z_closure_matching_status_drop(obj: *mut z_moved_closure_matching_status_t);
}
unsafe extern "C" {
    pub fn z_closure_matching_status_loan(
        val: *const z_owned_closure_matching_status_t,
    ) -> *const z_loaned_closure_matching_status_t;
}
unsafe extern "C" {
    pub fn ze_internal_closure_miss_null(closure_miss: *mut ze_owned_closure_miss_t);
}
unsafe extern "C" {
    pub fn ze_internal_closure_miss_check(val: *const ze_owned_closure_miss_t) -> bool;
}
unsafe extern "C" {
    pub fn ze_closure_miss_move(val: *mut ze_owned_closure_miss_t) -> *mut ze_moved_closure_miss_t;
}
unsafe extern "C" {
    pub fn ze_closure_miss_take(
        obj: *mut ze_owned_closure_miss_t,
        src: *mut ze_moved_closure_miss_t,
    );
}
unsafe extern "C" {
    pub fn ze_closure_miss_drop(obj: *mut ze_moved_closure_miss_t);
}
unsafe extern "C" {
    pub fn ze_closure_miss_loan(
        val: *const ze_owned_closure_miss_t,
    ) -> *const ze_loaned_closure_miss_t;
}
unsafe extern "C" {
    pub fn z_view_keyexpr_is_empty(obj: *const z_view_keyexpr_t) -> bool;
}
unsafe extern "C" {
    pub fn z_view_keyexpr_loan(keyexpr: *const z_view_keyexpr_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    pub fn z_view_keyexpr_loan_mut(keyexpr: *mut z_view_keyexpr_t) -> *mut z_loaned_keyexpr_t;
}
unsafe extern "C" {
    pub fn z_view_keyexpr_empty(keyexpr: *mut z_view_keyexpr_t);
}
unsafe extern "C" {
    pub fn z_view_string_is_empty(obj: *const z_view_string_t) -> bool;
}
unsafe extern "C" {
    pub fn z_view_string_loan(string: *const z_view_string_t) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    pub fn z_view_string_loan_mut(string: *mut z_view_string_t) -> *mut z_loaned_string_t;
}
unsafe extern "C" {
    pub fn z_view_string_empty(string: *mut z_view_string_t);
}
unsafe extern "C" {
    pub fn z_view_slice_is_empty(obj: *const z_view_slice_t) -> bool;
}
unsafe extern "C" {
    pub fn z_view_slice_loan(slice: *const z_view_slice_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    pub fn z_view_slice_loan_mut(slice: *mut z_view_slice_t) -> *mut z_loaned_slice_t;
}
unsafe extern "C" {
    pub fn z_view_slice_empty(slice: *mut z_view_slice_t);
}
unsafe extern "C" {
    #[doc = " Gets data from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get data from.\n\n Return:\n   Pointer to the string data."]
    pub fn z_string_data(str_: *const z_loaned_string_t) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    #[doc = " Gets string length from a :c:type:`z_loaned_string_t`.\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get length from.\n\n Return:\n   Length of the string."]
    pub fn z_string_len(str_: *const z_loaned_string_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by copying a ``const char *`` string.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be copied.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_str(
        str_: *mut z_owned_string_t,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_string_t` by transferring ownership over a null-terminated string to it.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a null terminated string to be owned by `str`.\n   deleter: A thread-safe delete function to free the `value`. Will be called once when `str` is dropped.\n     Can be NULL in the case where `value` is allocated in static memory.\n   context: An optional context to be passed to the `deleter`.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_from_str(
        str_: *mut z_owned_string_t,
        value: *mut ::core::ffi::c_char,
        deleter: ::core::option::Option<
            unsafe extern "C" fn(
                value: *mut ::core::ffi::c_void,
                context: *mut ::core::ffi::c_void,
            ),
        >,
        context: *mut ::core::ffi::c_void,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds an empty :c:type:`z_owned_string_t`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`."]
    pub fn z_string_empty(str_: *mut z_owned_string_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_string_t` by wrapping a substring specified by ``const char *`` and length `len`.\n\n Parameters:\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t`.\n   value: Pointer to a string.\n   len: String size.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_string_copy_from_substr(
        str_: *mut z_owned_string_t,
        value: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if string is empty\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to check.\n\n Return:\n  ``true`` if the string is empty, ``false`` otherwise."]
    pub fn z_string_is_empty(str_: *const z_loaned_string_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Returns :c:type:`z_loaned_slice_t` for the string\n\n Parameters:\n   str: Pointer to a :c:type:`z_loaned_string_t` to get a slice.\n\n Return:\n   slice containing string data"]
    pub fn z_string_as_slice(str_: *const z_loaned_string_t) -> *const z_loaned_slice_t;
}
unsafe extern "C" {
    #[doc = " Returns default :c:type:`z_priority_t` value"]
    pub fn z_priority_default() -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Returns id of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Id of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_zid(hello: *const z_loaned_hello_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Returns type of Zenoh entity that transmitted hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   Type of the Zenoh entity that transmitted hello message."]
    pub fn z_hello_whatami(hello: *const z_loaned_hello_t) -> z_whatami_t;
}
unsafe extern "C" {
    #[doc = " Returns an array of locators of Zenoh entity that sent hello message.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n\n Return:\n   :c:type:`z_loaned_string_array_t` containing locators."]
    pub fn zp_hello_locators(hello: *const z_loaned_hello_t) -> *const z_loaned_string_array_t;
}
unsafe extern "C" {
    #[doc = " Constructs an array of locators of Zenoh entity that sent hello message.\n\n Note that it is a method for zenoh-c compatiblity, in zenoh-pico :c:func:`zp_hello_locators`\n can be used.\n\n Parameters:\n   hello: Pointer to a :c:type:`z_loaned_hello_t` message.\n   locators_out: An uninitialized memory location where :c:type:`z_owned_string_array_t` will be constructed."]
    pub fn z_hello_locators(
        hello: *const z_loaned_hello_t,
        locators_out: *mut z_owned_string_array_t,
    );
}
unsafe extern "C" {
    #[doc = " Constructs a non-owned non-null-terminated string from the kind of zenoh entity.\n\n The string has static storage (i.e. valid until the end of the program).\n\n Parameters:\n   whatami: A whatami bitmask of zenoh entity kind.\n   str_out: An uninitialized memory location where strring will be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn z_whatami_to_view_string(
        whatami: z_whatami_t,
        str_out: *mut z_view_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Scouts for other Zenoh entities like routers and/or peers.\n\n Parameters:\n   config: Moved :c:type:`z_owned_config_t` to configure the scouting with.\n   callback: Moved :c:type:`z_owned_closure_hello_t` callback.\n   options: Pointer to a :c:type:`z_scout_options_t` to configure the operation.\n\n Return:\n   ``0`` if scouting was successfully triggered, ``negative value`` otherwise."]
    pub fn z_scout(
        config: *mut z_moved_config_t,
        callback: *mut z_moved_closure_hello_t,
        options: *const z_scout_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_scout_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_scout_options_t`."]
    pub fn z_scout_options_default(options: *mut z_scout_options_t);
}
unsafe extern "C" {
    #[doc = " Opens a Zenoh session.\n\n Parameters:\n   zs: Pointer to an uninitialized :c:type:`z_owned_session_t` to store the session info.\n   config: Moved :c:type:`z_owned_config_t` to configure the session with.\n   options: Pointer to a :c:type:`z_open_options_t` to configure the operation.\n\n Return:\n   ``0`` if open is successful, ``negative value`` otherwise."]
    pub fn z_open(
        zs: *mut z_owned_session_t,
        config: *mut z_moved_config_t,
        options: *const z_open_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Closes a Zenoh session.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t` to close.\n   options: Pointer to a :c:type:`z_close_options_t` to configure the operation.\n\n Return:\n   ``0`` if close is successful, ``negative value`` otherwise."]
    pub fn z_close(zs: *mut z_loaned_session_t, options: *const z_close_options_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if Zenoh session is closed.\n\n Parameters:\n   zs: Loaned :c:type:`z_owned_session_t`.\n\n Return:\n   ``true`` if session is closed, ``false`` otherwise."]
    pub fn z_session_is_closed(zs: *const z_loaned_session_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected peers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to :c:type:`z_loaned_session_t` to fetch peer id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_peers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Fetches Zenoh IDs of all connected routers.\n\n The callback will be called once for each ID. It is guaranteed to never be called concurrently,\n and to be dropped before this function exits.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to fetch router id from.\n   callback: Moved :c:type:`z_owned_closure_zid_t` callback.\n\n Return:\n   ``0`` if operation was successfully triggered, ``negative value`` otherwise."]
    pub fn z_info_routers_zid(
        zs: *const z_loaned_session_t,
        callback: *mut z_moved_closure_zid_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the local Zenoh ID associated to a given Zenoh session.\n\n If this function returns an array of 16 zeros, this means the session is invalid.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to get the id from.\n\n Return:\n   The local Zenoh ID of the session as :c:type:`z_id_t`."]
    pub fn z_info_zid(zs: *const z_loaned_session_t) -> z_id_t;
}
unsafe extern "C" {
    #[doc = " Converts a Zenoh ID into a string for print purposes.\n\n Parameters:\n   id: Pointer to the id to convert.\n   str: Pointer to uninitialized :c:type:`z_owned_string_t` to store the string.\n\n Return:\n   ``0`` if operation is successful, ``negative value`` otherwise."]
    pub fn z_id_to_string(id: *const z_id_t, str_: *mut z_owned_string_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_sample_keyexpr(sample: *const z_loaned_sample_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the payload of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the payload from.\n\n Return:\n   The payload wrapped as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_payload(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Gets the timestamp of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the timestamp from.\n\n Return:\n   The pointer to timestamp wrapped as a :c:type:`z_timestamp_t`. Returns NULL if no timestamp was set."]
    pub fn z_sample_timestamp(sample: *const z_loaned_sample_t) -> *const z_timestamp_t;
}
unsafe extern "C" {
    #[doc = " Gets the encoding of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the encoding from.\n\n Return:\n   The encoding wrapped as a :c:type:`z_loaned_encoding_t`."]
    pub fn z_sample_encoding(sample: *const z_loaned_sample_t) -> *const z_loaned_encoding_t;
}
unsafe extern "C" {
    #[doc = " Gets the kind of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the kind from.\n\n Return:\n   The sample kind wrapped as a :c:type:`z_sample_kind_t`."]
    pub fn z_sample_kind(sample: *const z_loaned_sample_t) -> z_sample_kind_t;
}
unsafe extern "C" {
    #[doc = " Gets the reliability a sample was received with (unstable).\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the reliability from.\n\n Return:\n   The reliability wrapped as a :c:type:`z_reliability_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_sample_reliability(sample: *const z_loaned_sample_t) -> z_reliability_t;
}
unsafe extern "C" {
    #[doc = " Gets the source info for the sample (unstable).\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the source info from.\n\n Return:\n   The source info wrapped as a :c:type:`z_loaned_source_info_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_sample_source_info(sample: *const z_loaned_sample_t) -> *const z_loaned_source_info_t;
}
unsafe extern "C" {
    #[doc = " Got a sample qos congestion control value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the congestion control from.\n\n Return:\n   The congestion control wrapped as a :c:type:`z_congestion_control_t`."]
    pub fn z_sample_congestion_control(sample: *const z_loaned_sample_t) -> z_congestion_control_t;
}
unsafe extern "C" {
    #[doc = " Got whether sample qos express flag was set or not.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the express flag from.\n\n Return:\n   The express flag value."]
    pub fn z_sample_express(sample: *const z_loaned_sample_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets sample qos priority value.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the qos priority from.\n\n Return:\n   The priority wrapped as a :c:type:`z_priority_t`."]
    pub fn z_sample_priority(sample: *const z_loaned_sample_t) -> z_priority_t;
}
unsafe extern "C" {
    #[doc = " Gets the attachment of a sample by aliasing it.\n\n Parameters:\n   sample: Pointer to a :c:type:`z_loaned_sample_t` to get the attachment from.\n\n Return:\n   Pointer to the attachment as a :c:type:`z_loaned_bytes_t`."]
    pub fn z_sample_attachment(sample: *const z_loaned_sample_t) -> *const z_loaned_bytes_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_put_options_t`."]
    pub fn z_put_options_default(options: *mut z_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_delete_options_default(options: *mut z_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to put the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to put the data for.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_put(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to delete the data through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to delete the data for.\n   options: Pointer to a :c:type:`z_delete_options_t` to configure the operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_delete(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_delete_options_t`."]
    pub fn z_publisher_options_default(options: *mut z_publisher_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a publisher for a given keyexpr.\n\n Data can be put and deleted with this publisher with the help of the\n :c:func:`z_publisher_put` and :c:func:`z_publisher_delete` functions.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the publisher through.\n   pub: Pointer to an uninitialized :c:type:`z_owned_publisher_t`.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the publisher with.\n   options: Pointer to a :c:type:`z_publisher_options_t` to configure the operation.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_publisher(
        zs: *const z_loaned_session_t,
        pub_: *mut z_owned_publisher_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_publisher_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the publisher.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_publisher_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_publisher(pub_: *mut z_moved_publisher_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_put_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_put_options_t`."]
    pub fn z_publisher_put_options_default(options: *mut z_publisher_put_options_t);
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_publisher_delete_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_publisher_delete_options_t`."]
    pub fn z_publisher_delete_options_default(options: *mut z_publisher_delete_options_t);
}
unsafe extern "C" {
    #[doc = " Puts data for the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to put the data.\n   payload: Moved :c:type:`z_owned_bytes_t` containing the data to put.\n   options: Pointer to a :c:type:`z_publisher_put_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_put(
        pub_: *const z_loaned_publisher_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_publisher_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_publisher_put_impl(
        pub_: *const z_loaned_publisher_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_publisher_put_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deletes data from the keyexpr bound to the given publisher.\n\n Parameters:\n   pub: Pointer to a :c:type:`z_loaned_publisher_t` from where to delete the data.\n   options: Pointer to a :c:type:`z_publisher_delete_options_t` to configure the delete operation.\n\n Return:\n   ``0`` if delete operation is successful, ``negative value`` otherwise."]
    pub fn z_publisher_delete(
        pub_: *const z_loaned_publisher_t,
        options: *const z_publisher_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_publisher_delete_impl(
        pub_: *const z_loaned_publisher_t,
        options: *const z_publisher_delete_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a publisher.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_publisher_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_publisher_keyexpr(publisher: *const z_loaned_publisher_t)
    -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the entity global Id from a publisher.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_publisher_t` to get the entity global Id from.\n\n Return:\n   The entity gloabl Id wrapped as a :c:type:`z_entity_global_id_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_publisher_id(publisher: *const z_loaned_publisher_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying subscribers matching with a given publisher.\n The callback will be run in the background until the corresponding publisher is dropped.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the publisher changes (If last subscriber\n disconnects or when the first subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_background_matching_listener(
        publisher: *const z_loaned_publisher_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying subscribers matching with a given publisher.\n\n Parameters:\n   publisher: A publisher to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n listener's callback will be automatically dropped when the publisher is dropped. callback: A closure that will be\n called every time the matching status of the publisher changes (If last subscriber disconnects or when the first\n subscriber connects).\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_declare_matching_listener(
        publisher: *const z_loaned_publisher_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets publisher matching status - i.e. if there are any subscribers matching its key expression.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn z_publisher_get_matching_status(
        publisher: *const z_loaned_publisher_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the matching listener.\n\n Parameters:\n   listener: Moved :c:type:`z_owned_matching_listener_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_matching_listener(listener: *mut z_moved_matching_listener_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_get_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_get_options_t`."]
    pub fn z_get_options_default(options: *mut z_get_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters as a null-terminated string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::core::ffi::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Sends a distributed query for a given keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to send the query through.\n   keyexpr: Pointer to a  :c:type:`z_loaned_keyexpr_t` to send the query for.\n   parameters: Pointer to the parameters string.\n   parameters_len: Length of the parameters string.\n   callback: Moved :c:type:`z_owned_closure_reply_t` callback.\n   options: Pointer to a :c:type:`z_get_options_t` to configure the operation.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_get_with_parameters_substr(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        parameters: *const ::core::ffi::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_get_options_t`."]
    pub fn z_querier_get_options_default(options: *mut z_querier_get_options_t);
}
unsafe extern "C" {
    #[doc = "  Constructs the default value for :c:type:`z_querier_options_t`."]
    pub fn z_querier_options_default(options: *mut z_querier_options_t);
}
unsafe extern "C" {
    #[doc = " Constructs and declares a querier on the given key expression.\n\n The queries can be send with the help of the `z_querier_get()` function.\n\n Parameters:\n   zs: The Zenoh session.\n   querier: An uninitialized location in memory where querier will be constructed.\n   keyexpr: The key expression to send queries on.\n   options: Additional options for the querier.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_querier(
        zs: *const z_loaned_session_t,
        querier: *mut z_owned_querier_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *mut z_querier_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Frees memory and resets querier to its gravestone state."]
    pub fn z_undeclare_querier(querier: *mut z_moved_querier_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters null-terminated string, similar to a url's query segment.\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get(
        querier: *const z_loaned_querier_t,
        parameters: *const ::core::ffi::c_char,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Query data from the matching queryables in the system.\n\n Replies are provided through a callback function.\n\n Parameters:\n   querier: The querier to make query from.\n   parameters: The query's parameters string, similar to a url's query segment.\n   parameters_len: Length of the parameters string\n   callback: The callback function that will be called on reception of replies for this query. It will be\n \t\t\t\tautomatically dropped once all replies are processed.\n   options: Additional options for the get. All owned fields will be consumed.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_with_parameters_substr(
        querier: *const z_loaned_querier_t,
        parameters: *const ::core::ffi::c_char,
        parameters_len: usize,
        callback: *mut z_moved_closure_reply_t,
        options: *mut z_querier_get_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = "  Returns the key expression of the querier."]
    pub fn z_querier_keyexpr(querier: *const z_loaned_querier_t) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the entity global Id from a querier.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_querier_t` to get the entity global Id from.\n\n Return:\n   The entity gloabl Id wrapped as a :c:type:`z_entity_global_global_id_t`."]
    pub fn z_querier_id(querier: *const z_loaned_querier_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Declares a matching listener, registering a callback for notifying queryables matching the given querier key\n expression and target. The callback will be run in the background until the corresponding querier is dropped.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_background_matching_listener(
        querier: *const z_loaned_querier_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs matching listener, registering a callback for notifying queryables matching with a given querier's\n key expression and target.\n\n Parameters:\n   querier: A querier to associate with matching listener.\n   matching_listener: An uninitialized memory location where matching listener will be constructed. The matching\n                      listener's callback will be automatically dropped when the querier is dropped.\n   callback: A closure that will be called every time the matching status of the querier changes (If last\n             queryable disconnects or when the first queryable connects).\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_declare_matching_listener(
        querier: *const z_loaned_querier_t,
        matching_listener: *mut z_owned_matching_listener_t,
        callback: *mut z_moved_closure_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets querier matching status - i.e. if there are any queryables matching its key expression and target.\n\n Return:\n   ``0`` if put operation is successful, ``negative value`` otherwise."]
    pub fn z_querier_get_matching_status(
        querier: *const z_loaned_querier_t,
        matching_status: *mut z_matching_status_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Checks if queryable answered with an OK, which allows this value to be treated as a sample.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to check.\n\n Return:\n   ``true`` if queryable answered with an OK, ``false`` otherwise."]
    pub fn z_reply_is_ok(reply: *const z_loaned_reply_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Gets the content of an OK reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``true`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The OK reply content wrapped as a :c:type:`z_loaned_sample_t`."]
    pub fn z_reply_ok(reply: *const z_loaned_reply_t) -> *const z_loaned_sample_t;
}
unsafe extern "C" {
    #[doc = " Gets the contents of an error reply.\n\n You should always make sure that :c:func:`z_reply_is_ok` returns ``false`` before calling this function.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n   The error reply content wrapped as a :c:type:`z_loaned_reply_err_t`."]
    pub fn z_reply_err(reply: *const z_loaned_reply_t) -> *const z_loaned_reply_err_t;
}
unsafe extern "C" {
    #[doc = " Gets the id of the zenoh instance that answered this Reply.\n\n Parameters:\n   reply: Pointer to a :c:type:`z_loaned_reply_t` to get content from.\n\n Return:\n \t `true` if id is present"]
    pub fn z_reply_replier_id(
        reply: *const z_loaned_reply_t,
        out_id: *mut z_entity_global_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_queryable_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_queryable_options_t`."]
    pub fn z_queryable_options_default(options: *mut z_queryable_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a queryable for a given keyexpr.\n Note that dropping queryable drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   queryable: Pointer to an uninitialized :c:type:`z_owned_queryable_t` to contain the queryable.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_queryable(
        zs: *const z_loaned_session_t,
        queryable: *mut z_owned_queryable_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the queryable.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_queryable_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_queryable(pub_: *mut z_moved_queryable_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background queryable for a given keyexpr. The queryable callback will be called\n to proccess incoming queries until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a :c:type:`z_owned_closure_query_t` callback.\n   options: Pointer to a :c:type:`z_queryable_options_t` to configure the declare.\n\n Return:\n   ``0`` if declare operation is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_queryable(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_query_t,
        options: *const z_queryable_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_options_t`."]
    pub fn z_query_reply_options_default(options: *mut z_query_reply_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   payload: Pointer to the reply data.\n   options: Pointer to a :c:type:`z_query_reply_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_query_reply_sample(
        query: *const z_loaned_query_t,
        sample: *const z_loaned_sample_t,
        options: *const z_query_reply_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_del_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_del_options_t`."]
    pub fn z_query_reply_del_options_default(options: *mut z_query_reply_del_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply delete to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the reply with.\n   options: Pointer to a :c:type:`z_query_reply_del_options_t` to configure the reply.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_del(
        query: *const z_loaned_query_t,
        keyexpr: *const z_loaned_keyexpr_t,
        options: *const z_query_reply_del_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_query_reply_err_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_query_reply_err_options_t`."]
    pub fn z_query_reply_err_options_default(options: *mut z_query_reply_err_options_t);
}
unsafe extern "C" {
    #[doc = " Sends a reply error to a query.\n\n This function must be called inside of a :c:type:`z_owned_closure_query_t` callback associated to the\n :c:type:`z_owned_queryable_t`, passing the received query as parameters of the callback function. This function can\n be called multiple times to send multiple replies to a query. The reply will be considered complete when the callback\n returns.\n\n Parameters:\n   query: Pointer to a :c:type:`z_loaned_query_t` to reply.\n   payload: Moved reply error data payload.\n   options: Pointer to a :c:type:`z_query_reply_err_options_t` to configure the reply error.\n\n Return:\n   ``0`` if reply operation is successful, ``negative value`` otherwise."]
    pub fn z_query_reply_err(
        query: *const z_loaned_query_t,
        payload: *mut z_moved_bytes_t,
        options: *const z_query_reply_err_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the entity global Id from a queryable.\n\n Parameters:\n   publisher: Pointer to a :c:type:`z_loaned_queryable_t` to get the entity global Id from.\n\n Return:\n   The entity gloabl Id wrapped as a :c:type:`z_loaned_queryable_t`."]
    pub fn z_queryable_id(queryable: *const z_loaned_queryable_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a queryable.\n\n Parameters:\n   queryable: Pointer to a :c:type:`z_loaned_queryable_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`. Will return NULL if\n   corresponding session is closed or dropped."]
    pub fn z_queryable_keyexpr(queryable: *const z_loaned_queryable_t)
    -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the null-terminated string of the keyexpr.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a new keyexpr from a substring.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyxpr.\n   len: Length of the substring to consider.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a null-terminated string with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t`.\n   name: Pointer to string representation of the keyexpr as a null terminated string.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_str_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_owned_keyexpr_t` from a substring with auto canonization.\n\n Parameters:\n   keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to store the keyexpr.\n   name: Pointer to the start of the substring for keyexpr.\n   len: Length of the substring to consider. After the function return it will be equal to the canonized key\n     expression string length.\n\n Return:\n   ``0`` if creation is successful, ``negative value`` otherwise."]
    pub fn z_keyexpr_from_substr_autocanonize(
        keyexpr: *mut z_owned_keyexpr_t,
        name: *const ::core::ffi::c_char,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a keyexpr, so that it is mapped on a numerical id.\n\n This numerical id is used on the network to save bandwidth and ease the retrieval of the concerned resource\n in the routing tables.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the keyexpr through.\n   declared_keyexpr: Pointer to an uninitialized :c:type:`z_owned_keyexpr_t` to contain the declared keyexpr.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the keyexpr with.\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_keyexpr(
        zs: *const z_loaned_session_t,
        declared_keyexpr: *mut z_owned_keyexpr_t,
        keyexpr: *const z_loaned_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares a keyexpr.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to undeclare the data through.\n   keyexpr: Moved :c:type:`z_owned_keyexpr_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_keyexpr(
        zs: *const z_loaned_session_t,
        keyexpr: *mut z_moved_keyexpr_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Constructs a new empty string array.\n\n Parameters:\n   a: Pointer to an uninitialized :c:type:`z_owned_string_array_t` to store the array of strings."]
    pub fn z_string_array_new(a: *mut z_owned_string_array_t);
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by alias.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_alias(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Appends specified value to the end of the string array by copying.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   value: Pointer to the string to be added.\n\n Return:\n   The new length of the array."]
    pub fn z_string_array_push_by_copy(
        a: *mut z_loaned_string_array_t,
        value: *const z_loaned_string_t,
    ) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns the value at the position of index in the string array.\n\n Parameters:\n   a: Pointer to :c:type:`z_loaned_string_array_t`.\n   k: index value.\n\n Return:\n   `NULL` if the index is out of bounds."]
    pub fn z_string_array_get(
        a: *const z_loaned_string_array_t,
        k: usize,
    ) -> *const z_loaned_string_t;
}
unsafe extern "C" {
    #[doc = " Returns the number of elements in the array."]
    pub fn z_string_array_len(a: *const z_loaned_string_array_t) -> usize;
}
unsafe extern "C" {
    #[doc = " Returns ``true`` if the array is empty, ``false`` otherwise."]
    pub fn z_string_array_is_empty(a: *const z_loaned_string_array_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`z_subscriber_options_t` with default values.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`z_subscriber_options_t`."]
    pub fn z_subscriber_options_default(options: *mut z_subscriber_options_t);
}
unsafe extern "C" {
    #[doc = " Declares a subscriber for a given keyexpr.\n Note that dropping subscriber drops its callback.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   sub: Pointer to a :c:type:`z_owned_subscriber_t` to contain the subscriber.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_subscriber(
        zs: *const z_loaned_session_t,
        sub: *mut z_owned_subscriber_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Undeclares the subscriber.\n\n Parameters:\n   pub: Moved :c:type:`z_owned_subscriber_t` to undeclare.\n\n Return:\n   ``0`` if undeclare is successful, ``negative value`` otherwise."]
    pub fn z_undeclare_subscriber(pub_: *mut z_moved_subscriber_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Declares a background subscriber for a given keyexpr. Subscriber callback will be called to process the messages,\n until the corresponding session is closed or dropped.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to declare the subscriber through.\n   keyexpr: Pointer to a :c:type:`z_loaned_keyexpr_t` to bind the subscriber with.\n   callback: Pointer to a`z_owned_closure_sample_t` callback.\n   options: Pointer to a :c:type:`z_subscriber_options_t` to configure the operation\n\n Return:\n   ``0`` if declare is successful, ``negative value`` otherwise."]
    pub fn z_declare_background_subscriber(
        zs: *const z_loaned_session_t,
        keyexpr: *const z_loaned_keyexpr_t,
        callback: *mut z_moved_closure_sample_t,
        options: *const z_subscriber_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the keyexpr from a subscriber.\n\n Parameters:\n   subscriber: Pointer to a :c:type:`z_loaned_subscriber_t` to get the keyexpr from.\n\n Return:\n   The keyexpr wrapped as a :c:type:`z_loaned_keyexpr_t`."]
    pub fn z_subscriber_keyexpr(
        subscriber: *const z_loaned_subscriber_t,
    ) -> *const z_loaned_keyexpr_t;
}
unsafe extern "C" {
    #[doc = " Gets the entity global Id from a subscriber.\n\n Parameters:\n   subscriber: Pointer to a :c:type:`z_loaned_subscriber_t` to get the entity global Id from.\n\n Return:\n   The entity gloabl Id wrapped as a :c:type:`z_entity_global_global_id_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_subscriber_id(subscriber: *const z_loaned_subscriber_t) -> z_entity_global_id_t;
}
unsafe extern "C" {
    #[doc = " Activate the batching mechanism, any message that would have been sent on the network by a subsequent api call (e.g\n z_put, z_get) will be instead stored until either: the batch is full, flushed with :c:func:`zp_batch_flush`, batching\n is stopped with :c:func:`zp_batch_stop`, a message needs to be sent immediately.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will start batching messages.\n\n Return:\n   ``0`` if batching started, ``negative value`` otherwise."]
    pub fn zp_batch_start(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Send the currently batched messages on the network.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will send its batched messages.\n\n Return:\n   ``0`` if batch successfully sent, ``negative value`` otherwise."]
    pub fn zp_batch_flush(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deactivate the batching mechanism and send the currently batched on the network.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` that will stop batching messages.\n\n Return:\n   ``0`` if batching stopped and batch successfully sent, ``negative value`` otherwise."]
    pub fn zp_batch_stop(zs: *const z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Multi Thread Tasks helpers **************/\n/**\n Builds a :c:type:`zp_task_read_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_task_read_options_t`."]
    pub fn zp_task_read_options_default(options: *mut zp_task_read_options_t);
}
unsafe extern "C" {
    #[doc = " Starts a task to read from the network and process the received messages.\n\n Note that the task can be implemented in form of thread, process, etc. and its implementation is\n platform-dependent.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to start the task from.\n   options: Pointer to a :c:type:`zp_task_read_options_t` to configure the task.\n\n Return:\n   ``0`` if task started successfully, ``negative value`` otherwise."]
    pub fn zp_start_read_task(
        zs: *mut z_loaned_session_t,
        options: *const zp_task_read_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stops the read task.\n\n This may result in stopping a thread or a process depending on the target platform.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to stop the task from.\n\n Return:\n   ``0`` if task stopped successfully, ``negative value`` otherwise."]
    pub fn zp_stop_read_task(zs: *mut z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_task_lease_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_task_lease_options_t`."]
    pub fn zp_task_lease_options_default(options: *mut zp_task_lease_options_t);
}
unsafe extern "C" {
    #[doc = " Starts a task to handle the session lease.\n\n This task will send ``KeepAlive`` messages when needed and will close the session when the lease is expired.\n When operating over a multicast transport, it also periodically sends the ``Join`` messages.\n Note that the task can be implemented in form of thread, process, etc. and its implementation is\n platform-dependent.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to start the task from.\n   options: Pointer to a :c:type:`zp_task_lease_options_t` to configure the task.\n\n Return:\n   ``0`` if task started successfully, ``negative value`` otherwise."]
    pub fn zp_start_lease_task(
        zs: *mut z_loaned_session_t,
        options: *const zp_task_lease_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Stops the lease task.\n\n This may result in stopping a thread or a process depending on the target platform.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to stop the task from.\n\n Return:\n   ``0`` if task stopped successfully, ``negative value`` otherwise."]
    pub fn zp_stop_lease_task(zs: *mut z_loaned_session_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Single Thread helpers **************/\n/**\n Builds a :c:type:`zp_read_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_read_options_t`."]
    pub fn zp_read_options_default(options: *mut zp_read_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single read from the network and process received messages.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the read for.\n   options: Pointer to a :c:type:`zp_read_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_read(zs: *const z_loaned_session_t, options: *const zp_read_options_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_send_keep_alive_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_send_keep_alive_options_t`."]
    pub fn zp_send_keep_alive_options_default(options: *mut zp_send_keep_alive_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single send keep alive procedure.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the send for.\n   options: Pointer to a :c:type:`zp_send_keep_alive_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_send_keep_alive(
        zs: *const z_loaned_session_t,
        options: *const zp_send_keep_alive_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Builds a :c:type:`zp_send_join_options_t` with default value.\n\n Parameters:\n   options: Pointer to an uninitialized :c:type:`zp_send_join_options_t`."]
    pub fn zp_send_join_options_default(options: *mut zp_send_join_options_t);
}
unsafe extern "C" {
    #[doc = " Executes a single send join procedure.\n\n Parameters:\n   zs: Pointer to a :c:type:`z_loaned_session_t` to execute the send for.\n   options: Pointer to a :c:type:`zp_send_keep_alive_options_t` to configure the operation.\n\n Return:\n   ``0`` if execution was successful, ``negative value`` otherwise."]
    pub fn zp_send_join(
        zs: *const z_loaned_session_t,
        options: *const zp_send_join_options_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Gets the default reliability value (unstable).\n\n Return:\n   The reliability wrapped as a :c:type:`z_reliability_t`.\n\n .. warning:: This API has been marked as unstable: it works as advertised, but it may be changed in a future release."]
    pub fn z_reliability_default() -> z_reliability_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_t {
    pub _ring: _z_ring_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_t"][::core::mem::size_of::<_z_fifo_t>() - 40usize];
    ["Alignment of _z_fifo_t"][::core::mem::align_of::<_z_fifo_t>() - 8usize];
    ["Offset of field: _z_fifo_t::_ring"][::core::mem::offset_of!(_z_fifo_t, _ring) - 0usize];
};
unsafe extern "C" {
    pub fn _z_fifo_init(fifo: *mut _z_fifo_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_make(capacity: usize) -> _z_fifo_t;
}
unsafe extern "C" {
    pub fn _z_fifo_capacity(r: *const _z_fifo_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_fifo_len(r: *const _z_fifo_t) -> usize;
}
unsafe extern "C" {
    pub fn _z_fifo_is_empty(r: *const _z_fifo_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_fifo_is_full(r: *const _z_fifo_t) -> bool;
}
unsafe extern "C" {
    pub fn _z_fifo_push(r: *mut _z_fifo_t, e: *mut ::core::ffi::c_void)
    -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_fifo_push_drop(r: *mut _z_fifo_t, e: *mut ::core::ffi::c_void, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_pull(r: *mut _z_fifo_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn _z_fifo_clone(xs: *const _z_fifo_t, d_f: z_element_clone_f) -> *mut _z_fifo_t;
}
unsafe extern "C" {
    pub fn _z_fifo_clear(v: *mut _z_fifo_t, f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_free(xs: *mut *mut _z_fifo_t, f_f: z_element_free_f);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_mt_t {
    pub _fifo: _z_fifo_t,
    pub is_closed: bool,
    pub _mutex: _z_mutex_t,
    pub _cv_not_full: _z_condvar_t,
    pub _cv_not_empty: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_mt_t"][::core::mem::size_of::<_z_fifo_mt_t>() - 208usize];
    ["Alignment of _z_fifo_mt_t"][::core::mem::align_of::<_z_fifo_mt_t>() - 8usize];
    ["Offset of field: _z_fifo_mt_t::_fifo"][::core::mem::offset_of!(_z_fifo_mt_t, _fifo) - 0usize];
    ["Offset of field: _z_fifo_mt_t::is_closed"]
        [::core::mem::offset_of!(_z_fifo_mt_t, is_closed) - 40usize];
    ["Offset of field: _z_fifo_mt_t::_mutex"]
        [::core::mem::offset_of!(_z_fifo_mt_t, _mutex) - 48usize];
    ["Offset of field: _z_fifo_mt_t::_cv_not_full"]
        [::core::mem::offset_of!(_z_fifo_mt_t, _cv_not_full) - 112usize];
    ["Offset of field: _z_fifo_mt_t::_cv_not_empty"]
        [::core::mem::offset_of!(_z_fifo_mt_t, _cv_not_empty) - 160usize];
};
unsafe extern "C" {
    pub fn _z_fifo_mt_init(fifo: *mut _z_fifo_mt_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_new(capacity: usize) -> *mut _z_fifo_mt_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_close(fifo: *mut _z_fifo_mt_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_clear(fifo: *mut _z_fifo_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_mt_free(fifo: *mut _z_fifo_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_fifo_mt_push(
        src: *const ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_free: z_element_free_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_pull(
        dst: *mut ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_fifo_mt_try_pull(
        dst: *mut ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_mt_t {
    pub _ring: _z_ring_t,
    pub is_closed: bool,
    pub _mutex: _z_mutex_t,
    pub _cv_not_empty: _z_condvar_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_mt_t"][::core::mem::size_of::<_z_ring_mt_t>() - 160usize];
    ["Alignment of _z_ring_mt_t"][::core::mem::align_of::<_z_ring_mt_t>() - 8usize];
    ["Offset of field: _z_ring_mt_t::_ring"][::core::mem::offset_of!(_z_ring_mt_t, _ring) - 0usize];
    ["Offset of field: _z_ring_mt_t::is_closed"]
        [::core::mem::offset_of!(_z_ring_mt_t, is_closed) - 40usize];
    ["Offset of field: _z_ring_mt_t::_mutex"]
        [::core::mem::offset_of!(_z_ring_mt_t, _mutex) - 48usize];
    ["Offset of field: _z_ring_mt_t::_cv_not_empty"]
        [::core::mem::offset_of!(_z_ring_mt_t, _cv_not_empty) - 112usize];
};
unsafe extern "C" {
    pub fn _z_ring_mt_init(ring: *mut _z_ring_mt_t, capacity: usize) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_new(capacity: usize) -> *mut _z_ring_mt_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_close(ring: *mut _z_ring_mt_t) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_clear(ring: *mut _z_ring_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_mt_free(ring: *mut _z_ring_mt_t, free_f: z_element_free_f);
}
unsafe extern "C" {
    pub fn _z_ring_mt_push(
        src: *const ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_free: z_element_free_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_pull(
        dst: *mut ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
unsafe extern "C" {
    pub fn _z_ring_mt_try_pull(
        dst: *mut ::core::ffi::c_void,
        context: *mut ::core::ffi::c_void,
        element_move: z_element_move_f,
    ) -> z_result_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_t"]
        [::core::mem::size_of::<_z_ring_handler_sample_t>() - 160usize];
    ["Alignment of _z_ring_handler_sample_t"]
        [::core::mem::align_of::<_z_ring_handler_sample_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_t::collection"]
        [::core::mem::offset_of!(_z_ring_handler_sample_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_rc_t {
    pub _val: *mut _z_ring_handler_sample_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_rc_t"]
        [::core::mem::size_of::<_z_ring_handler_sample_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_sample_rc_t"]
        [::core::mem::align_of::<_z_ring_handler_sample_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_rc_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_sample_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_sample_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_sample_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_sample_weak_t {
    pub _val: *mut _z_ring_handler_sample_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_sample_weak_t"]
        [::core::mem::size_of::<_z_ring_handler_sample_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_sample_weak_t"]
        [::core::mem::align_of::<_z_ring_handler_sample_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_sample_weak_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_sample_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_sample_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_sample_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_sample_t {
    pub _rc: _z_ring_handler_sample_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_sample_t"]
        [::core::mem::size_of::<z_owned_ring_handler_sample_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_sample_t"]
        [::core::mem::align_of::<z_owned_ring_handler_sample_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_sample_t::_rc"]
        [::core::mem::offset_of!(z_owned_ring_handler_sample_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_sample_t = _z_ring_handler_sample_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_sample_t {
    pub _this: z_owned_ring_handler_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_sample_t"]
        [::core::mem::size_of::<z_moved_ring_handler_sample_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_sample_t"]
        [::core::mem::align_of::<z_moved_ring_handler_sample_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_sample_t::_this"]
        [::core::mem::offset_of!(z_moved_ring_handler_sample_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_t"]
        [::core::mem::size_of::<_z_fifo_handler_sample_t>() - 208usize];
    ["Alignment of _z_fifo_handler_sample_t"]
        [::core::mem::align_of::<_z_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_t::collection"]
        [::core::mem::offset_of!(_z_fifo_handler_sample_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_rc_t {
    pub _val: *mut _z_fifo_handler_sample_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_rc_t"]
        [::core::mem::size_of::<_z_fifo_handler_sample_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_sample_rc_t"]
        [::core::mem::align_of::<_z_fifo_handler_sample_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_rc_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_sample_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_sample_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_sample_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_sample_weak_t {
    pub _val: *mut _z_fifo_handler_sample_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_sample_weak_t"]
        [::core::mem::size_of::<_z_fifo_handler_sample_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_sample_weak_t"]
        [::core::mem::align_of::<_z_fifo_handler_sample_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_sample_weak_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_sample_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_sample_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_sample_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_sample_t {
    pub _rc: _z_fifo_handler_sample_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_sample_t"]
        [::core::mem::size_of::<z_owned_fifo_handler_sample_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_sample_t"]
        [::core::mem::align_of::<z_owned_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_sample_t::_rc"]
        [::core::mem::offset_of!(z_owned_fifo_handler_sample_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_sample_t = _z_fifo_handler_sample_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_sample_t {
    pub _this: z_owned_fifo_handler_sample_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_sample_t"]
        [::core::mem::size_of::<z_moved_fifo_handler_sample_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_sample_t"]
        [::core::mem::align_of::<z_moved_fifo_handler_sample_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_sample_t::_this"]
        [::core::mem::offset_of!(z_moved_fifo_handler_sample_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_t"]
        [::core::mem::size_of::<_z_ring_handler_query_t>() - 160usize];
    ["Alignment of _z_ring_handler_query_t"]
        [::core::mem::align_of::<_z_ring_handler_query_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_t::collection"]
        [::core::mem::offset_of!(_z_ring_handler_query_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_rc_t {
    pub _val: *mut _z_ring_handler_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_rc_t"]
        [::core::mem::size_of::<_z_ring_handler_query_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_query_rc_t"]
        [::core::mem::align_of::<_z_ring_handler_query_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_rc_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_query_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_query_weak_t {
    pub _val: *mut _z_ring_handler_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_query_weak_t"]
        [::core::mem::size_of::<_z_ring_handler_query_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_query_weak_t"]
        [::core::mem::align_of::<_z_ring_handler_query_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_query_weak_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_query_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_query_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_query_t {
    pub _rc: _z_ring_handler_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_query_t"]
        [::core::mem::size_of::<z_owned_ring_handler_query_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_query_t"]
        [::core::mem::align_of::<z_owned_ring_handler_query_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_query_t::_rc"]
        [::core::mem::offset_of!(z_owned_ring_handler_query_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_query_t = _z_ring_handler_query_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_query_t {
    pub _this: z_owned_ring_handler_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_query_t"]
        [::core::mem::size_of::<z_moved_ring_handler_query_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_query_t"]
        [::core::mem::align_of::<z_moved_ring_handler_query_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_query_t::_this"]
        [::core::mem::offset_of!(z_moved_ring_handler_query_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_t"]
        [::core::mem::size_of::<_z_fifo_handler_query_t>() - 208usize];
    ["Alignment of _z_fifo_handler_query_t"]
        [::core::mem::align_of::<_z_fifo_handler_query_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_t::collection"]
        [::core::mem::offset_of!(_z_fifo_handler_query_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_rc_t {
    pub _val: *mut _z_fifo_handler_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_rc_t"]
        [::core::mem::size_of::<_z_fifo_handler_query_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_query_rc_t"]
        [::core::mem::align_of::<_z_fifo_handler_query_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_rc_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_query_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_query_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_query_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_query_weak_t {
    pub _val: *mut _z_fifo_handler_query_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_query_weak_t"]
        [::core::mem::size_of::<_z_fifo_handler_query_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_query_weak_t"]
        [::core::mem::align_of::<_z_fifo_handler_query_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_query_weak_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_query_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_query_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_query_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_query_t {
    pub _rc: _z_fifo_handler_query_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_query_t"]
        [::core::mem::size_of::<z_owned_fifo_handler_query_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_query_t"]
        [::core::mem::align_of::<z_owned_fifo_handler_query_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_query_t::_rc"]
        [::core::mem::offset_of!(z_owned_fifo_handler_query_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_query_t = _z_fifo_handler_query_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_query_t {
    pub _this: z_owned_fifo_handler_query_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_query_t"]
        [::core::mem::size_of::<z_moved_fifo_handler_query_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_query_t"]
        [::core::mem::align_of::<z_moved_fifo_handler_query_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_query_t::_this"]
        [::core::mem::offset_of!(z_moved_fifo_handler_query_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_t {
    pub collection: _z_ring_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_t"]
        [::core::mem::size_of::<_z_ring_handler_reply_t>() - 160usize];
    ["Alignment of _z_ring_handler_reply_t"]
        [::core::mem::align_of::<_z_ring_handler_reply_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_t::collection"]
        [::core::mem::offset_of!(_z_ring_handler_reply_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_rc_t {
    pub _val: *mut _z_ring_handler_reply_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_rc_t"]
        [::core::mem::size_of::<_z_ring_handler_reply_rc_t>() - 16usize];
    ["Alignment of _z_ring_handler_reply_rc_t"]
        [::core::mem::align_of::<_z_ring_handler_reply_rc_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_rc_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_reply_rc_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_reply_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_reply_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_ring_handler_reply_weak_t {
    pub _val: *mut _z_ring_handler_reply_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_ring_handler_reply_weak_t"]
        [::core::mem::size_of::<_z_ring_handler_reply_weak_t>() - 16usize];
    ["Alignment of _z_ring_handler_reply_weak_t"]
        [::core::mem::align_of::<_z_ring_handler_reply_weak_t>() - 8usize];
    ["Offset of field: _z_ring_handler_reply_weak_t::_val"]
        [::core::mem::offset_of!(_z_ring_handler_reply_weak_t, _val) - 0usize];
    ["Offset of field: _z_ring_handler_reply_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_ring_handler_reply_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_ring_handler_reply_t {
    pub _rc: _z_ring_handler_reply_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_ring_handler_reply_t"]
        [::core::mem::size_of::<z_owned_ring_handler_reply_t>() - 16usize];
    ["Alignment of z_owned_ring_handler_reply_t"]
        [::core::mem::align_of::<z_owned_ring_handler_reply_t>() - 8usize];
    ["Offset of field: z_owned_ring_handler_reply_t::_rc"]
        [::core::mem::offset_of!(z_owned_ring_handler_reply_t, _rc) - 0usize];
};
pub type z_loaned_ring_handler_reply_t = _z_ring_handler_reply_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_ring_handler_reply_t {
    pub _this: z_owned_ring_handler_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_ring_handler_reply_t"]
        [::core::mem::size_of::<z_moved_ring_handler_reply_t>() - 16usize];
    ["Alignment of z_moved_ring_handler_reply_t"]
        [::core::mem::align_of::<z_moved_ring_handler_reply_t>() - 8usize];
    ["Offset of field: z_moved_ring_handler_reply_t::_this"]
        [::core::mem::offset_of!(z_moved_ring_handler_reply_t, _this) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_t {
    pub collection: _z_fifo_mt_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_t"]
        [::core::mem::size_of::<_z_fifo_handler_reply_t>() - 208usize];
    ["Alignment of _z_fifo_handler_reply_t"]
        [::core::mem::align_of::<_z_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_t::collection"]
        [::core::mem::offset_of!(_z_fifo_handler_reply_t, collection) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_rc_t {
    pub _val: *mut _z_fifo_handler_reply_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_rc_t"]
        [::core::mem::size_of::<_z_fifo_handler_reply_rc_t>() - 16usize];
    ["Alignment of _z_fifo_handler_reply_rc_t"]
        [::core::mem::align_of::<_z_fifo_handler_reply_rc_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_rc_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_reply_rc_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_reply_rc_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_reply_rc_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _z_fifo_handler_reply_weak_t {
    pub _val: *mut _z_fifo_handler_reply_t,
    pub _cnt: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _z_fifo_handler_reply_weak_t"]
        [::core::mem::size_of::<_z_fifo_handler_reply_weak_t>() - 16usize];
    ["Alignment of _z_fifo_handler_reply_weak_t"]
        [::core::mem::align_of::<_z_fifo_handler_reply_weak_t>() - 8usize];
    ["Offset of field: _z_fifo_handler_reply_weak_t::_val"]
        [::core::mem::offset_of!(_z_fifo_handler_reply_weak_t, _val) - 0usize];
    ["Offset of field: _z_fifo_handler_reply_weak_t::_cnt"]
        [::core::mem::offset_of!(_z_fifo_handler_reply_weak_t, _cnt) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_owned_fifo_handler_reply_t {
    pub _rc: _z_fifo_handler_reply_rc_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_owned_fifo_handler_reply_t"]
        [::core::mem::size_of::<z_owned_fifo_handler_reply_t>() - 16usize];
    ["Alignment of z_owned_fifo_handler_reply_t"]
        [::core::mem::align_of::<z_owned_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: z_owned_fifo_handler_reply_t::_rc"]
        [::core::mem::offset_of!(z_owned_fifo_handler_reply_t, _rc) - 0usize];
};
pub type z_loaned_fifo_handler_reply_t = _z_fifo_handler_reply_rc_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct z_moved_fifo_handler_reply_t {
    pub _this: z_owned_fifo_handler_reply_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of z_moved_fifo_handler_reply_t"]
        [::core::mem::size_of::<z_moved_fifo_handler_reply_t>() - 16usize];
    ["Alignment of z_moved_fifo_handler_reply_t"]
        [::core::mem::align_of::<z_moved_fifo_handler_reply_t>() - 8usize];
    ["Offset of field: z_moved_fifo_handler_reply_t::_this"]
        [::core::mem::offset_of!(z_moved_fifo_handler_reply_t, _this) - 0usize];
};
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::core::ffi::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state"]
        [::core::mem::size_of::<__darwin_arm_exception_state>() - 12usize];
    ["Alignment of __darwin_arm_exception_state"]
        [::core::mem::align_of::<__darwin_arm_exception_state>() - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__exception"]
        [::core::mem::offset_of!(__darwin_arm_exception_state, __exception) - 0usize];
    ["Offset of field: __darwin_arm_exception_state::__fsr"]
        [::core::mem::offset_of!(__darwin_arm_exception_state, __fsr) - 4usize];
    ["Offset of field: __darwin_arm_exception_state::__far"]
        [::core::mem::offset_of!(__darwin_arm_exception_state, __far) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64"]
        [::core::mem::size_of::<__darwin_arm_exception_state64>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64"]
        [::core::mem::align_of::<__darwin_arm_exception_state64>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__far"]
        [::core::mem::offset_of!(__darwin_arm_exception_state64, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64::__esr"]
        [::core::mem::offset_of!(__darwin_arm_exception_state64, __esr) - 8usize];
    ["Offset of field: __darwin_arm_exception_state64::__exception"]
        [::core::mem::offset_of!(__darwin_arm_exception_state64, __exception) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64_v2 {
    pub __far: __uint64_t,
    pub __esr: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_exception_state64_v2"]
        [::core::mem::size_of::<__darwin_arm_exception_state64_v2>() - 16usize];
    ["Alignment of __darwin_arm_exception_state64_v2"]
        [::core::mem::align_of::<__darwin_arm_exception_state64_v2>() - 8usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__far"]
        [::core::mem::offset_of!(__darwin_arm_exception_state64_v2, __far) - 0usize];
    ["Offset of field: __darwin_arm_exception_state64_v2::__esr"]
        [::core::mem::offset_of!(__darwin_arm_exception_state64_v2, __esr) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state"]
        [::core::mem::size_of::<__darwin_arm_thread_state>() - 68usize];
    ["Alignment of __darwin_arm_thread_state"]
        [::core::mem::align_of::<__darwin_arm_thread_state>() - 4usize];
    ["Offset of field: __darwin_arm_thread_state::__r"]
        [::core::mem::offset_of!(__darwin_arm_thread_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_thread_state::__sp"]
        [::core::mem::offset_of!(__darwin_arm_thread_state, __sp) - 52usize];
    ["Offset of field: __darwin_arm_thread_state::__lr"]
        [::core::mem::offset_of!(__darwin_arm_thread_state, __lr) - 56usize];
    ["Offset of field: __darwin_arm_thread_state::__pc"]
        [::core::mem::offset_of!(__darwin_arm_thread_state, __pc) - 60usize];
    ["Offset of field: __darwin_arm_thread_state::__cpsr"]
        [::core::mem::offset_of!(__darwin_arm_thread_state, __cpsr) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_thread_state64"]
        [::core::mem::size_of::<__darwin_arm_thread_state64>() - 272usize];
    ["Alignment of __darwin_arm_thread_state64"]
        [::core::mem::align_of::<__darwin_arm_thread_state64>() - 8usize];
    ["Offset of field: __darwin_arm_thread_state64::__x"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __x) - 0usize];
    ["Offset of field: __darwin_arm_thread_state64::__fp"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __fp) - 232usize];
    ["Offset of field: __darwin_arm_thread_state64::__lr"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __lr) - 240usize];
    ["Offset of field: __darwin_arm_thread_state64::__sp"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __sp) - 248usize];
    ["Offset of field: __darwin_arm_thread_state64::__pc"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __pc) - 256usize];
    ["Offset of field: __darwin_arm_thread_state64::__cpsr"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __cpsr) - 264usize];
    ["Offset of field: __darwin_arm_thread_state64::__pad"]
        [::core::mem::offset_of!(__darwin_arm_thread_state64, __pad) - 268usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_vfp_state"][::core::mem::size_of::<__darwin_arm_vfp_state>() - 260usize];
    ["Alignment of __darwin_arm_vfp_state"]
        [::core::mem::align_of::<__darwin_arm_vfp_state>() - 4usize];
    ["Offset of field: __darwin_arm_vfp_state::__r"]
        [::core::mem::offset_of!(__darwin_arm_vfp_state, __r) - 0usize];
    ["Offset of field: __darwin_arm_vfp_state::__fpscr"]
        [::core::mem::offset_of!(__darwin_arm_vfp_state, __fpscr) - 256usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state64"]
        [::core::mem::size_of::<__darwin_arm_neon_state64>() - 528usize];
    ["Alignment of __darwin_arm_neon_state64"]
        [::core::mem::align_of::<__darwin_arm_neon_state64>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state64::__v"]
        [::core::mem::offset_of!(__darwin_arm_neon_state64, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpsr"]
        [::core::mem::offset_of!(__darwin_arm_neon_state64, __fpsr) - 512usize];
    ["Offset of field: __darwin_arm_neon_state64::__fpcr"]
        [::core::mem::offset_of!(__darwin_arm_neon_state64, __fpcr) - 516usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_neon_state"]
        [::core::mem::size_of::<__darwin_arm_neon_state>() - 272usize];
    ["Alignment of __darwin_arm_neon_state"]
        [::core::mem::align_of::<__darwin_arm_neon_state>() - 16usize];
    ["Offset of field: __darwin_arm_neon_state::__v"]
        [::core::mem::offset_of!(__darwin_arm_neon_state, __v) - 0usize];
    ["Offset of field: __darwin_arm_neon_state::__fpsr"]
        [::core::mem::offset_of!(__darwin_arm_neon_state, __fpsr) - 256usize];
    ["Offset of field: __darwin_arm_neon_state::__fpcr"]
        [::core::mem::offset_of!(__darwin_arm_neon_state, __fpcr) - 260usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_pagein_state"][::core::mem::size_of::<__arm_pagein_state>() - 4usize];
    ["Alignment of __arm_pagein_state"][::core::mem::align_of::<__arm_pagein_state>() - 4usize];
    ["Offset of field: __arm_pagein_state::__pagein_error"]
        [::core::mem::offset_of!(__arm_pagein_state, __pagein_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __arm_legacy_debug_state"]
        [::core::mem::size_of::<__arm_legacy_debug_state>() - 256usize];
    ["Alignment of __arm_legacy_debug_state"]
        [::core::mem::align_of::<__arm_legacy_debug_state>() - 4usize];
    ["Offset of field: __arm_legacy_debug_state::__bvr"]
        [::core::mem::offset_of!(__arm_legacy_debug_state, __bvr) - 0usize];
    ["Offset of field: __arm_legacy_debug_state::__bcr"]
        [::core::mem::offset_of!(__arm_legacy_debug_state, __bcr) - 64usize];
    ["Offset of field: __arm_legacy_debug_state::__wvr"]
        [::core::mem::offset_of!(__arm_legacy_debug_state, __wvr) - 128usize];
    ["Offset of field: __arm_legacy_debug_state::__wcr"]
        [::core::mem::offset_of!(__arm_legacy_debug_state, __wcr) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state32"]
        [::core::mem::size_of::<__darwin_arm_debug_state32>() - 264usize];
    ["Alignment of __darwin_arm_debug_state32"]
        [::core::mem::align_of::<__darwin_arm_debug_state32>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state32::__bvr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state32, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state32::__bcr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state32, __bcr) - 64usize];
    ["Offset of field: __darwin_arm_debug_state32::__wvr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state32, __wvr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state32::__wcr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state32, __wcr) - 192usize];
    ["Offset of field: __darwin_arm_debug_state32::__mdscr_el1"]
        [::core::mem::offset_of!(__darwin_arm_debug_state32, __mdscr_el1) - 256usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_debug_state64"]
        [::core::mem::size_of::<__darwin_arm_debug_state64>() - 520usize];
    ["Alignment of __darwin_arm_debug_state64"]
        [::core::mem::align_of::<__darwin_arm_debug_state64>() - 8usize];
    ["Offset of field: __darwin_arm_debug_state64::__bvr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state64, __bvr) - 0usize];
    ["Offset of field: __darwin_arm_debug_state64::__bcr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state64, __bcr) - 128usize];
    ["Offset of field: __darwin_arm_debug_state64::__wvr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state64, __wvr) - 256usize];
    ["Offset of field: __darwin_arm_debug_state64::__wcr"]
        [::core::mem::offset_of!(__darwin_arm_debug_state64, __wcr) - 384usize];
    ["Offset of field: __darwin_arm_debug_state64::__mdscr_el1"]
        [::core::mem::offset_of!(__darwin_arm_debug_state64, __mdscr_el1) - 512usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_arm_cpmu_state64"]
        [::core::mem::size_of::<__darwin_arm_cpmu_state64>() - 128usize];
    ["Alignment of __darwin_arm_cpmu_state64"]
        [::core::mem::align_of::<__darwin_arm_cpmu_state64>() - 8usize];
    ["Offset of field: __darwin_arm_cpmu_state64::__ctrs"]
        [::core::mem::offset_of!(__darwin_arm_cpmu_state64, __ctrs) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext32"][::core::mem::size_of::<__darwin_mcontext32>() - 340usize];
    ["Alignment of __darwin_mcontext32"][::core::mem::align_of::<__darwin_mcontext32>() - 4usize];
    ["Offset of field: __darwin_mcontext32::__es"]
        [::core::mem::offset_of!(__darwin_mcontext32, __es) - 0usize];
    ["Offset of field: __darwin_mcontext32::__ss"]
        [::core::mem::offset_of!(__darwin_mcontext32, __ss) - 12usize];
    ["Offset of field: __darwin_mcontext32::__fs"]
        [::core::mem::offset_of!(__darwin_mcontext32, __fs) - 80usize];
};
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_mcontext64"][::core::mem::size_of::<__darwin_mcontext64>() - 816usize];
    ["Alignment of __darwin_mcontext64"][::core::mem::align_of::<__darwin_mcontext64>() - 16usize];
    ["Offset of field: __darwin_mcontext64::__es"]
        [::core::mem::offset_of!(__darwin_mcontext64, __es) - 0usize];
    ["Offset of field: __darwin_mcontext64::__ss"]
        [::core::mem::offset_of!(__darwin_mcontext64, __ss) - 16usize];
    ["Offset of field: __darwin_mcontext64::__ns"]
        [::core::mem::offset_of!(__darwin_mcontext64, __ns) - 288usize];
};
pub type mcontext_t = *mut __darwin_mcontext64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::core::ffi::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_sigaltstack"][::core::mem::size_of::<__darwin_sigaltstack>() - 24usize];
    ["Alignment of __darwin_sigaltstack"][::core::mem::align_of::<__darwin_sigaltstack>() - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_sp"]
        [::core::mem::offset_of!(__darwin_sigaltstack, ss_sp) - 0usize];
    ["Offset of field: __darwin_sigaltstack::ss_size"]
        [::core::mem::offset_of!(__darwin_sigaltstack, ss_size) - 8usize];
    ["Offset of field: __darwin_sigaltstack::ss_flags"]
        [::core::mem::offset_of!(__darwin_sigaltstack, ss_flags) - 16usize];
};
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::core::ffi::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_ucontext"][::core::mem::size_of::<__darwin_ucontext>() - 56usize];
    ["Alignment of __darwin_ucontext"][::core::mem::align_of::<__darwin_ucontext>() - 8usize];
    ["Offset of field: __darwin_ucontext::uc_onstack"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_onstack) - 0usize];
    ["Offset of field: __darwin_ucontext::uc_sigmask"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_sigmask) - 4usize];
    ["Offset of field: __darwin_ucontext::uc_stack"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_stack) - 8usize];
    ["Offset of field: __darwin_ucontext::uc_link"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_link) - 32usize];
    ["Offset of field: __darwin_ucontext::uc_mcsize"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_mcsize) - 40usize];
    ["Offset of field: __darwin_ucontext::uc_mcontext"]
        [::core::mem::offset_of!(__darwin_ucontext, uc_mcontext) - 48usize];
};
pub type ucontext_t = __darwin_ucontext;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::core::ffi::c_int,
    pub sival_ptr: *mut ::core::ffi::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::core::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::core::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::core::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::core::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::core::ffi::c_int,
    pub sigev_signo: ::core::ffi::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::core::mem::size_of::<sigevent>() - 32usize];
    ["Alignment of sigevent"][::core::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::core::mem::offset_of!(sigevent, sigev_notify) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::core::mem::offset_of!(sigevent, sigev_signo) - 4usize];
    ["Offset of field: sigevent::sigev_value"]
        [::core::mem::offset_of!(sigevent, sigev_value) - 8usize];
    ["Offset of field: sigevent::sigev_notify_function"]
        [::core::mem::offset_of!(sigevent, sigev_notify_function) - 16usize];
    ["Offset of field: sigevent::sigev_notify_attributes"]
        [::core::mem::offset_of!(sigevent, sigev_notify_attributes) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::core::ffi::c_int,
    pub si_errno: ::core::ffi::c_int,
    pub si_code: ::core::ffi::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::core::ffi::c_int,
    pub si_addr: *mut ::core::ffi::c_void,
    pub si_value: sigval,
    pub si_band: ::core::ffi::c_long,
    pub __pad: [::core::ffi::c_ulong; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __siginfo"][::core::mem::size_of::<__siginfo>() - 104usize];
    ["Alignment of __siginfo"][::core::mem::align_of::<__siginfo>() - 8usize];
    ["Offset of field: __siginfo::si_signo"][::core::mem::offset_of!(__siginfo, si_signo) - 0usize];
    ["Offset of field: __siginfo::si_errno"][::core::mem::offset_of!(__siginfo, si_errno) - 4usize];
    ["Offset of field: __siginfo::si_code"][::core::mem::offset_of!(__siginfo, si_code) - 8usize];
    ["Offset of field: __siginfo::si_pid"][::core::mem::offset_of!(__siginfo, si_pid) - 12usize];
    ["Offset of field: __siginfo::si_uid"][::core::mem::offset_of!(__siginfo, si_uid) - 16usize];
    ["Offset of field: __siginfo::si_status"]
        [::core::mem::offset_of!(__siginfo, si_status) - 20usize];
    ["Offset of field: __siginfo::si_addr"][::core::mem::offset_of!(__siginfo, si_addr) - 24usize];
    ["Offset of field: __siginfo::si_value"]
        [::core::mem::offset_of!(__siginfo, si_value) - 32usize];
    ["Offset of field: __siginfo::si_band"][::core::mem::offset_of!(__siginfo, si_band) - 40usize];
    ["Offset of field: __siginfo::__pad"][::core::mem::offset_of!(__siginfo, __pad) - 48usize];
};
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub __sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::core::ffi::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::core::ffi::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction_u"][::core::mem::size_of::<__sigaction_u>() - 8usize];
    ["Alignment of __sigaction_u"][::core::mem::align_of::<__sigaction_u>() - 8usize];
    ["Offset of field: __sigaction_u::__sa_handler"]
        [::core::mem::offset_of!(__sigaction_u, __sa_handler) - 0usize];
    ["Offset of field: __sigaction_u::__sa_sigaction"]
        [::core::mem::offset_of!(__sigaction_u, __sa_sigaction) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::core::ffi::c_void,
            arg2: ::core::ffi::c_int,
            arg3: ::core::ffi::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::core::ffi::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigaction"][::core::mem::size_of::<__sigaction>() - 24usize];
    ["Alignment of __sigaction"][::core::mem::align_of::<__sigaction>() - 8usize];
    ["Offset of field: __sigaction::__sigaction_u"]
        [::core::mem::offset_of!(__sigaction, __sigaction_u) - 0usize];
    ["Offset of field: __sigaction::sa_tramp"]
        [::core::mem::offset_of!(__sigaction, sa_tramp) - 8usize];
    ["Offset of field: __sigaction::sa_mask"]
        [::core::mem::offset_of!(__sigaction, sa_mask) - 16usize];
    ["Offset of field: __sigaction::sa_flags"]
        [::core::mem::offset_of!(__sigaction, sa_flags) - 20usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::core::mem::size_of::<sigaction>() - 16usize];
    ["Alignment of sigaction"][::core::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_u"]
        [::core::mem::offset_of!(sigaction, __sigaction_u) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::core::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::core::mem::offset_of!(sigaction, sa_flags) - 12usize];
};
pub type sig_t = ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    pub sv_mask: ::core::ffi::c_int,
    pub sv_flags: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigvec"][::core::mem::size_of::<sigvec>() - 16usize];
    ["Alignment of sigvec"][::core::mem::align_of::<sigvec>() - 8usize];
    ["Offset of field: sigvec::sv_handler"][::core::mem::offset_of!(sigvec, sv_handler) - 0usize];
    ["Offset of field: sigvec::sv_mask"][::core::mem::offset_of!(sigvec, sv_mask) - 8usize];
    ["Offset of field: sigvec::sv_flags"][::core::mem::offset_of!(sigvec, sv_flags) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::core::ffi::c_char,
    pub ss_onstack: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::core::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::core::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::core::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::core::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn signal(
        arg1: ::core::ffi::c_int,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            arg1: ::core::ffi::c_int,
            arg2: ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
        ),
    >;
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::core::ffi::c_long,
    pub ru_ixrss: ::core::ffi::c_long,
    pub ru_idrss: ::core::ffi::c_long,
    pub ru_isrss: ::core::ffi::c_long,
    pub ru_minflt: ::core::ffi::c_long,
    pub ru_majflt: ::core::ffi::c_long,
    pub ru_nswap: ::core::ffi::c_long,
    pub ru_inblock: ::core::ffi::c_long,
    pub ru_oublock: ::core::ffi::c_long,
    pub ru_msgsnd: ::core::ffi::c_long,
    pub ru_msgrcv: ::core::ffi::c_long,
    pub ru_nsignals: ::core::ffi::c_long,
    pub ru_nvcsw: ::core::ffi::c_long,
    pub ru_nivcsw: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage"][::core::mem::size_of::<rusage>() - 144usize];
    ["Alignment of rusage"][::core::mem::align_of::<rusage>() - 8usize];
    ["Offset of field: rusage::ru_utime"][::core::mem::offset_of!(rusage, ru_utime) - 0usize];
    ["Offset of field: rusage::ru_stime"][::core::mem::offset_of!(rusage, ru_stime) - 16usize];
    ["Offset of field: rusage::ru_maxrss"][::core::mem::offset_of!(rusage, ru_maxrss) - 32usize];
    ["Offset of field: rusage::ru_ixrss"][::core::mem::offset_of!(rusage, ru_ixrss) - 40usize];
    ["Offset of field: rusage::ru_idrss"][::core::mem::offset_of!(rusage, ru_idrss) - 48usize];
    ["Offset of field: rusage::ru_isrss"][::core::mem::offset_of!(rusage, ru_isrss) - 56usize];
    ["Offset of field: rusage::ru_minflt"][::core::mem::offset_of!(rusage, ru_minflt) - 64usize];
    ["Offset of field: rusage::ru_majflt"][::core::mem::offset_of!(rusage, ru_majflt) - 72usize];
    ["Offset of field: rusage::ru_nswap"][::core::mem::offset_of!(rusage, ru_nswap) - 80usize];
    ["Offset of field: rusage::ru_inblock"][::core::mem::offset_of!(rusage, ru_inblock) - 88usize];
    ["Offset of field: rusage::ru_oublock"][::core::mem::offset_of!(rusage, ru_oublock) - 96usize];
    ["Offset of field: rusage::ru_msgsnd"][::core::mem::offset_of!(rusage, ru_msgsnd) - 104usize];
    ["Offset of field: rusage::ru_msgrcv"][::core::mem::offset_of!(rusage, ru_msgrcv) - 112usize];
    ["Offset of field: rusage::ru_nsignals"]
        [::core::mem::offset_of!(rusage, ru_nsignals) - 120usize];
    ["Offset of field: rusage::ru_nvcsw"][::core::mem::offset_of!(rusage, ru_nvcsw) - 128usize];
    ["Offset of field: rusage::ru_nivcsw"][::core::mem::offset_of!(rusage, ru_nivcsw) - 136usize];
};
pub type rusage_info_t = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v0"][::core::mem::size_of::<rusage_info_v0>() - 96usize];
    ["Alignment of rusage_info_v0"][::core::mem::align_of::<rusage_info_v0>() - 8usize];
    ["Offset of field: rusage_info_v0::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v0, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v0::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v0, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v0::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v0, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v0::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v0, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v0::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v0, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v0::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v0, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v0::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v0, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v0::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v0, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v0::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v0, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v0::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v0, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v0::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v0, ri_proc_exit_abstime) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v1"][::core::mem::size_of::<rusage_info_v1>() - 144usize];
    ["Alignment of rusage_info_v1"][::core::mem::align_of::<rusage_info_v1>() - 8usize];
    ["Offset of field: rusage_info_v1::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v1, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v1::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v1, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v1::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v1, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v1::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v1, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v1::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v1, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v1::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v1, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v1::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v1, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v1::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v1, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v1::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v1, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v1::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v1, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v1::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v1, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v1::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v1::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v1::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v1::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v1::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v1::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v1, ri_child_elapsed_abstime) - 136usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v2"][::core::mem::size_of::<rusage_info_v2>() - 160usize];
    ["Alignment of rusage_info_v2"][::core::mem::align_of::<rusage_info_v2>() - 8usize];
    ["Offset of field: rusage_info_v2::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v2, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v2::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v2, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v2::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v2, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v2::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v2, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v2::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v2, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v2::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v2, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v2::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v2, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v2::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v2, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v2::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v2, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v2::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v2, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v2::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v2, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v2::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v2::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v2::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v2::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v2::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v2::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v2, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v2::ri_diskio_bytesread"]
        [::core::mem::offset_of!(rusage_info_v2, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v2::ri_diskio_byteswritten"]
        [::core::mem::offset_of!(rusage_info_v2, ri_diskio_byteswritten) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v3"][::core::mem::size_of::<rusage_info_v3>() - 232usize];
    ["Alignment of rusage_info_v3"][::core::mem::align_of::<rusage_info_v3>() - 8usize];
    ["Offset of field: rusage_info_v3::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v3, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v3::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v3::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v3::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v3, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v3::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v3, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v3::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v3, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v3::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v3, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v3::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v3, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v3::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v3, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v3::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v3, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v3::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v3, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v3::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v3::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v3::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v3::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v3::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v3::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v3, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v3::ri_diskio_bytesread"]
        [::core::mem::offset_of!(rusage_info_v3, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v3::ri_diskio_byteswritten"]
        [::core::mem::offset_of!(rusage_info_v3, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_default"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_maintenance"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_background"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_utility"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_legacy"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_initiated"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v3::ri_cpu_time_qos_user_interactive"]
        [::core::mem::offset_of!(rusage_info_v3, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v3::ri_billed_system_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v3::ri_serviced_system_time"]
        [::core::mem::offset_of!(rusage_info_v3, ri_serviced_system_time) - 224usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v4"][::core::mem::size_of::<rusage_info_v4>() - 296usize];
    ["Alignment of rusage_info_v4"][::core::mem::align_of::<rusage_info_v4>() - 8usize];
    ["Offset of field: rusage_info_v4::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v4, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v4::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v4::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v4::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v4, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v4::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v4, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v4::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v4, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v4::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v4, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v4::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v4, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v4::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v4, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v4::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v4, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v4::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v4, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v4::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v4::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v4::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v4::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v4::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v4::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v4, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v4::ri_diskio_bytesread"]
        [::core::mem::offset_of!(rusage_info_v4, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v4::ri_diskio_byteswritten"]
        [::core::mem::offset_of!(rusage_info_v4, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_default"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_maintenance"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_background"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_utility"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_legacy"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_initiated"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v4::ri_cpu_time_qos_user_interactive"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v4::ri_billed_system_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v4::ri_serviced_system_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v4::ri_logical_writes"]
        [::core::mem::offset_of!(rusage_info_v4, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v4::ri_lifetime_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v4, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v4::ri_instructions"]
        [::core::mem::offset_of!(rusage_info_v4, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v4::ri_cycles"]
        [::core::mem::offset_of!(rusage_info_v4, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v4::ri_billed_energy"]
        [::core::mem::offset_of!(rusage_info_v4, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v4::ri_serviced_energy"]
        [::core::mem::offset_of!(rusage_info_v4, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v4::ri_interval_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v4, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v4::ri_runnable_time"]
        [::core::mem::offset_of!(rusage_info_v4, ri_runnable_time) - 288usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v5"][::core::mem::size_of::<rusage_info_v5>() - 304usize];
    ["Alignment of rusage_info_v5"][::core::mem::align_of::<rusage_info_v5>() - 8usize];
    ["Offset of field: rusage_info_v5::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v5, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v5::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v5::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v5::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v5, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v5::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v5, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v5::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v5, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v5::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v5, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v5::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v5, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v5::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v5, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v5::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v5, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v5::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v5, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v5::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v5::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v5::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v5::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v5::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v5::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v5, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v5::ri_diskio_bytesread"]
        [::core::mem::offset_of!(rusage_info_v5, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v5::ri_diskio_byteswritten"]
        [::core::mem::offset_of!(rusage_info_v5, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_default"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_maintenance"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_background"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_utility"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_legacy"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_initiated"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v5::ri_cpu_time_qos_user_interactive"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v5::ri_billed_system_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v5::ri_serviced_system_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v5::ri_logical_writes"]
        [::core::mem::offset_of!(rusage_info_v5, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v5::ri_lifetime_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v5, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v5::ri_instructions"]
        [::core::mem::offset_of!(rusage_info_v5, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v5::ri_cycles"]
        [::core::mem::offset_of!(rusage_info_v5, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v5::ri_billed_energy"]
        [::core::mem::offset_of!(rusage_info_v5, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v5::ri_serviced_energy"]
        [::core::mem::offset_of!(rusage_info_v5, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v5::ri_interval_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v5, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v5::ri_runnable_time"]
        [::core::mem::offset_of!(rusage_info_v5, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v5::ri_flags"]
        [::core::mem::offset_of!(rusage_info_v5, ri_flags) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_secure_time_in_system: u64,
    pub ri_secure_ptime_in_system: u64,
    pub ri_neural_footprint: u64,
    pub ri_lifetime_max_neural_footprint: u64,
    pub ri_interval_max_neural_footprint: u64,
    pub ri_reserved: [u64; 9usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rusage_info_v6"][::core::mem::size_of::<rusage_info_v6>() - 464usize];
    ["Alignment of rusage_info_v6"][::core::mem::align_of::<rusage_info_v6>() - 8usize];
    ["Offset of field: rusage_info_v6::ri_uuid"]
        [::core::mem::offset_of!(rusage_info_v6, ri_uuid) - 0usize];
    ["Offset of field: rusage_info_v6::ri_user_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_user_time) - 16usize];
    ["Offset of field: rusage_info_v6::ri_system_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_system_time) - 24usize];
    ["Offset of field: rusage_info_v6::ri_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v6, ri_pkg_idle_wkups) - 32usize];
    ["Offset of field: rusage_info_v6::ri_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v6, ri_interrupt_wkups) - 40usize];
    ["Offset of field: rusage_info_v6::ri_pageins"]
        [::core::mem::offset_of!(rusage_info_v6, ri_pageins) - 48usize];
    ["Offset of field: rusage_info_v6::ri_wired_size"]
        [::core::mem::offset_of!(rusage_info_v6, ri_wired_size) - 56usize];
    ["Offset of field: rusage_info_v6::ri_resident_size"]
        [::core::mem::offset_of!(rusage_info_v6, ri_resident_size) - 64usize];
    ["Offset of field: rusage_info_v6::ri_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_phys_footprint) - 72usize];
    ["Offset of field: rusage_info_v6::ri_proc_start_abstime"]
        [::core::mem::offset_of!(rusage_info_v6, ri_proc_start_abstime) - 80usize];
    ["Offset of field: rusage_info_v6::ri_proc_exit_abstime"]
        [::core::mem::offset_of!(rusage_info_v6, ri_proc_exit_abstime) - 88usize];
    ["Offset of field: rusage_info_v6::ri_child_user_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_user_time) - 96usize];
    ["Offset of field: rusage_info_v6::ri_child_system_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_system_time) - 104usize];
    ["Offset of field: rusage_info_v6::ri_child_pkg_idle_wkups"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_pkg_idle_wkups) - 112usize];
    ["Offset of field: rusage_info_v6::ri_child_interrupt_wkups"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_interrupt_wkups) - 120usize];
    ["Offset of field: rusage_info_v6::ri_child_pageins"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_pageins) - 128usize];
    ["Offset of field: rusage_info_v6::ri_child_elapsed_abstime"]
        [::core::mem::offset_of!(rusage_info_v6, ri_child_elapsed_abstime) - 136usize];
    ["Offset of field: rusage_info_v6::ri_diskio_bytesread"]
        [::core::mem::offset_of!(rusage_info_v6, ri_diskio_bytesread) - 144usize];
    ["Offset of field: rusage_info_v6::ri_diskio_byteswritten"]
        [::core::mem::offset_of!(rusage_info_v6, ri_diskio_byteswritten) - 152usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_default"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_default) - 160usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_maintenance"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_maintenance) - 168usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_background"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_background) - 176usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_utility"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_utility) - 184usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_legacy"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_legacy) - 192usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_initiated"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_initiated) - 200usize];
    ["Offset of field: rusage_info_v6::ri_cpu_time_qos_user_interactive"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cpu_time_qos_user_interactive) - 208usize];
    ["Offset of field: rusage_info_v6::ri_billed_system_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_billed_system_time) - 216usize];
    ["Offset of field: rusage_info_v6::ri_serviced_system_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_serviced_system_time) - 224usize];
    ["Offset of field: rusage_info_v6::ri_logical_writes"]
        [::core::mem::offset_of!(rusage_info_v6, ri_logical_writes) - 232usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_lifetime_max_phys_footprint) - 240usize];
    ["Offset of field: rusage_info_v6::ri_instructions"]
        [::core::mem::offset_of!(rusage_info_v6, ri_instructions) - 248usize];
    ["Offset of field: rusage_info_v6::ri_cycles"]
        [::core::mem::offset_of!(rusage_info_v6, ri_cycles) - 256usize];
    ["Offset of field: rusage_info_v6::ri_billed_energy"]
        [::core::mem::offset_of!(rusage_info_v6, ri_billed_energy) - 264usize];
    ["Offset of field: rusage_info_v6::ri_serviced_energy"]
        [::core::mem::offset_of!(rusage_info_v6, ri_serviced_energy) - 272usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_phys_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_interval_max_phys_footprint) - 280usize];
    ["Offset of field: rusage_info_v6::ri_runnable_time"]
        [::core::mem::offset_of!(rusage_info_v6, ri_runnable_time) - 288usize];
    ["Offset of field: rusage_info_v6::ri_flags"]
        [::core::mem::offset_of!(rusage_info_v6, ri_flags) - 296usize];
    ["Offset of field: rusage_info_v6::ri_user_ptime"]
        [::core::mem::offset_of!(rusage_info_v6, ri_user_ptime) - 304usize];
    ["Offset of field: rusage_info_v6::ri_system_ptime"]
        [::core::mem::offset_of!(rusage_info_v6, ri_system_ptime) - 312usize];
    ["Offset of field: rusage_info_v6::ri_pinstructions"]
        [::core::mem::offset_of!(rusage_info_v6, ri_pinstructions) - 320usize];
    ["Offset of field: rusage_info_v6::ri_pcycles"]
        [::core::mem::offset_of!(rusage_info_v6, ri_pcycles) - 328usize];
    ["Offset of field: rusage_info_v6::ri_energy_nj"]
        [::core::mem::offset_of!(rusage_info_v6, ri_energy_nj) - 336usize];
    ["Offset of field: rusage_info_v6::ri_penergy_nj"]
        [::core::mem::offset_of!(rusage_info_v6, ri_penergy_nj) - 344usize];
    ["Offset of field: rusage_info_v6::ri_secure_time_in_system"]
        [::core::mem::offset_of!(rusage_info_v6, ri_secure_time_in_system) - 352usize];
    ["Offset of field: rusage_info_v6::ri_secure_ptime_in_system"]
        [::core::mem::offset_of!(rusage_info_v6, ri_secure_ptime_in_system) - 360usize];
    ["Offset of field: rusage_info_v6::ri_neural_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_neural_footprint) - 368usize];
    ["Offset of field: rusage_info_v6::ri_lifetime_max_neural_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_lifetime_max_neural_footprint) - 376usize];
    ["Offset of field: rusage_info_v6::ri_interval_max_neural_footprint"]
        [::core::mem::offset_of!(rusage_info_v6, ri_interval_max_neural_footprint) - 384usize];
    ["Offset of field: rusage_info_v6::ri_reserved"]
        [::core::mem::offset_of!(rusage_info_v6, ri_reserved) - 392usize];
};
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of rlimit"][::core::mem::size_of::<rlimit>() - 16usize];
    ["Alignment of rlimit"][::core::mem::align_of::<rlimit>() - 8usize];
    ["Offset of field: rlimit::rlim_cur"][::core::mem::offset_of!(rlimit, rlim_cur) - 0usize];
    ["Offset of field: rlimit::rlim_max"][::core::mem::offset_of!(rlimit, rlim_max) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of proc_rlimit_control_wakeupmon"]
        [::core::mem::size_of::<proc_rlimit_control_wakeupmon>() - 8usize];
    ["Alignment of proc_rlimit_control_wakeupmon"]
        [::core::mem::align_of::<proc_rlimit_control_wakeupmon>() - 4usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_flags"]
        [::core::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_flags) - 0usize];
    ["Offset of field: proc_rlimit_control_wakeupmon::wm_rate"]
        [::core::mem::offset_of!(proc_rlimit_control_wakeupmon, wm_rate) - 4usize];
};
unsafe extern "C" {
    pub fn getpriority(arg1: ::core::ffi::c_int, arg2: id_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getiopolicy_np(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int)
    -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getrlimit(arg1: ::core::ffi::c_int, arg2: *mut rlimit) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getrusage(arg1: ::core::ffi::c_int, arg2: *mut rusage) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setpriority(
        arg1: ::core::ffi::c_int,
        arg2: id_t,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setiopolicy_np(
        arg1: ::core::ffi::c_int,
        arg2: ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setrlimit(arg1: ::core::ffi::c_int, arg2: *const rlimit) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::core::ffi::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_1"][::core::mem::size_of::<wait__bindgen_ty_1>() - 4usize];
    ["Alignment of wait__bindgen_ty_1"][::core::mem::align_of::<wait__bindgen_ty_1>() - 4usize];
};
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Termsig_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                7u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                7u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Coredump_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Retcode_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::core::ffi::c_uint,
        w_Coredump: ::core::ffi::c_uint,
        w_Retcode: ::core::ffi::c_uint,
        w_Filler: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::core::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::core::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::core::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::core::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait__bindgen_ty_2"][::core::mem::size_of::<wait__bindgen_ty_2>() - 4usize];
    ["Alignment of wait__bindgen_ty_2"][::core::mem::align_of::<wait__bindgen_ty_2>() - 4usize];
};
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopval_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn w_Filler_raw(this: *const Self) -> ::core::ffi::c_uint {
        unsafe {
            ::core::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::core::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::core::ffi::c_uint,
        w_Stopsig: ::core::ffi::c_uint,
        w_Filler: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::core::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::core::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::core::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of wait"][::core::mem::size_of::<wait>() - 4usize];
    ["Alignment of wait"][::core::mem::align_of::<wait>() - 4usize];
    ["Offset of field: wait::w_status"][::core::mem::offset_of!(wait, w_status) - 0usize];
    ["Offset of field: wait::w_T"][::core::mem::offset_of!(wait, w_T) - 0usize];
    ["Offset of field: wait::w_S"][::core::mem::offset_of!(wait, w_S) - 0usize];
};
unsafe extern "C" {
    pub fn wait(arg1: *mut ::core::ffi::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::core::ffi::c_int, arg3: ::core::ffi::c_int) -> pid_t;
}
unsafe extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wait3(
        arg1: *mut ::core::ffi::c_int,
        arg2: ::core::ffi::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::core::ffi::c_int,
        arg3: ::core::ffi::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn alloca(arg1: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::core::ffi::c_int,
    pub rem: ::core::ffi::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::core::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::core::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::core::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::core::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::core::ffi::c_long,
    pub rem: ::core::ffi::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::core::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::core::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::core::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::core::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::core::ffi::c_longlong,
    pub rem: ::core::ffi::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::core::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::core::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::core::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::core::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub static mut __mb_cur_max: ::core::ffi::c_int;
}
pub type malloc_type_id_t = ::core::ffi::c_ulonglong;
unsafe extern "C" {
    pub fn malloc_type_malloc(size: usize, type_id: malloc_type_id_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_free(ptr: *mut ::core::ffi::c_void, type_id: malloc_type_id_t);
}
unsafe extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::core::ffi::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_valloc(size: usize, type_id: malloc_type_id_t) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::core::ffi::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
unsafe extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::core::ffi::c_void,
        type_id: malloc_type_id_t,
    );
}
unsafe extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::core::ffi::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn malloc(__size: ::core::ffi::c_ulong) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __count: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn free(arg1: *mut ::core::ffi::c_void);
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn reallocf(__ptr: *mut ::core::ffi::c_void, __size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::core::ffi::c_ulong,
        __size: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::core::ffi::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn abs(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn atexit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        arg1: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn atof(arg1: *const ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn atol(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn atoll(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn div(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn exit(arg1: ::core::ffi::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn labs(arg1: ::core::ffi::c_long) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn ldiv(arg1: ::core::ffi::c_long, arg2: ::core::ffi::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn llabs(arg1: ::core::ffi::c_longlong) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn lldiv(arg1: ::core::ffi::c_longlong, arg2: ::core::ffi::c_longlong) -> lldiv_t;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::core::ffi::c_char, __n: usize) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::core::ffi::c_char, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::core::ffi::c_char,
        arg3: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn quick_exit(arg1: ::core::ffi::c_int) -> !;
}
unsafe extern "C" {
    pub fn rand() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn srand(arg1: ::core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn strtod(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn strtof(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f32;
}
unsafe extern "C" {
    pub fn strtol(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn strtold(arg1: *const ::core::ffi::c_char, arg2: *mut *mut ::core::ffi::c_char) -> f64;
}
unsafe extern "C" {
    pub fn strtoll(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn strtoul(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulong;
}
unsafe extern "C" {
    pub fn strtoull(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub fn system(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn wcstombs(arg1: *mut ::core::ffi::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
unsafe extern "C" {
    pub fn wctomb(arg1: *mut ::core::ffi::c_char, arg2: wchar_t) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn _Exit(arg1: ::core::ffi::c_int) -> !;
}
unsafe extern "C" {
    pub fn a64l(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn erand48(arg1: *mut ::core::ffi::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_int,
        arg4: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::core::ffi::c_int,
        arg3: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const *mut ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn grantpt(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn initstate(
        arg1: ::core::ffi::c_uint,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn jrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn l64a(arg1: ::core::ffi::c_long) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn lcong48(arg1: *mut ::core::ffi::c_ushort);
}
unsafe extern "C" {
    pub fn lrand48() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn mktemp(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mrand48() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn nrand48(arg1: *mut ::core::ffi::c_ushort) -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn posix_openpt(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn ptsname(arg1: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ptsname_r(
        fildes: ::core::ffi::c_int,
        buffer: *mut ::core::ffi::c_char,
        buflen: usize,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn putenv(arg1: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn random() -> ::core::ffi::c_long;
}
unsafe extern "C" {
    pub fn rand_r(arg1: *mut ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::core::ffi::c_char,
        arg2: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn seed48(arg1: *mut ::core::ffi::c_ushort) -> *mut ::core::ffi::c_ushort;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::core::ffi::c_char,
        __value: *const ::core::ffi::c_char,
        __overwrite: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn setkey(arg1: *const ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn setstate(arg1: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn srand48(arg1: ::core::ffi::c_long);
}
unsafe extern "C" {
    pub fn srandom(arg1: ::core::ffi::c_uint);
}
unsafe extern "C" {
    pub fn unlockpt(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
unsafe extern "C" {
    pub fn arc4random() -> u32;
}
unsafe extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::core::ffi::c_uchar, arg2: ::core::ffi::c_int);
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::core::ffi::c_void, __nbytes: usize);
}
unsafe extern "C" {
    pub fn arc4random_stir();
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
unsafe extern "C" {
    pub fn atexit_b(arg1: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bsearch_b(
        __key: *const ::core::ffi::c_void,
        __base: *const ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::core::ffi::c_void,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn cgetcap(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn cgetclose() -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetmatch(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetnum(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut ::core::ffi::c_long,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetset(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetstr(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn cgetustr(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut *mut ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn daemon(arg1: ::core::ffi::c_int, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn getbsize(
        arg1: *mut ::core::ffi::c_int,
        arg2: *mut ::core::ffi::c_long,
    ) -> *mut ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn getprogname() -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn setprogname(arg1: *const ::core::ffi::c_char);
}
unsafe extern "C" {
    pub fn heapsort(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn heapsort_b(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mergesort(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn mergesort_b(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn psort(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn psort_b(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn psort_r(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::core::ffi::c_void,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn qsort_b(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::core::ffi::c_void,
    );
}
unsafe extern "C" {
    pub fn qsort_r(
        __base: *mut ::core::ffi::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::core::ffi::c_void,
        __compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::core::ffi::c_void,
                arg2: *const ::core::ffi::c_void,
                arg3: *const ::core::ffi::c_void,
            ) -> ::core::ffi::c_int,
        >,
    );
}
unsafe extern "C" {
    pub fn radixsort(
        __base: *mut *const ::core::ffi::c_uchar,
        __nel: ::core::ffi::c_int,
        __table: *const ::core::ffi::c_uchar,
        __endbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn rpmatch(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::core::ffi::c_uchar,
        __nel: ::core::ffi::c_int,
        __table: *const ::core::ffi::c_uchar,
        __endbyte: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
unsafe extern "C" {
    pub fn sranddev();
}
unsafe extern "C" {
    pub fn srandomdev();
}
unsafe extern "C" {
    pub fn strtonum(
        __numstr: *const ::core::ffi::c_char,
        __minval: ::core::ffi::c_longlong,
        __maxval: ::core::ffi::c_longlong,
        __errstrp: *mut *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn strtoq(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __str: *const ::core::ffi::c_char,
        __endptr: *mut *mut ::core::ffi::c_char,
        __base: ::core::ffi::c_int,
    ) -> ::core::ffi::c_ulonglong;
}
unsafe extern "C" {
    pub static mut suboptarg: *mut ::core::ffi::c_char;
}
#[doc = " Represents a reader for serialized data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_deserializer_t {
    pub _reader: z_bytes_reader_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_deserializer_t"][::core::mem::size_of::<ze_deserializer_t>() - 32usize];
    ["Alignment of ze_deserializer_t"][::core::mem::align_of::<ze_deserializer_t>() - 8usize];
    ["Offset of field: ze_deserializer_t::_reader"]
        [::core::mem::offset_of!(ze_deserializer_t, _reader) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_serializer_t {
    pub _writer: _z_bytes_writer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ze_serializer_t"][::core::mem::size_of::<_ze_serializer_t>() - 40usize];
    ["Alignment of _ze_serializer_t"][::core::mem::align_of::<_ze_serializer_t>() - 8usize];
    ["Offset of field: _ze_serializer_t::_writer"]
        [::core::mem::offset_of!(_ze_serializer_t, _writer) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_owned_serializer_t {
    pub _val: _ze_serializer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_owned_serializer_t"][::core::mem::size_of::<ze_owned_serializer_t>() - 40usize];
    ["Alignment of ze_owned_serializer_t"]
        [::core::mem::align_of::<ze_owned_serializer_t>() - 8usize];
    ["Offset of field: ze_owned_serializer_t::_val"]
        [::core::mem::offset_of!(ze_owned_serializer_t, _val) - 0usize];
};
pub type ze_loaned_serializer_t = _ze_serializer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ze_moved_serializer_t {
    pub _this: ze_owned_serializer_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ze_moved_serializer_t"][::core::mem::size_of::<ze_moved_serializer_t>() - 40usize];
    ["Alignment of ze_moved_serializer_t"]
        [::core::mem::align_of::<ze_moved_serializer_t>() - 8usize];
    ["Offset of field: ze_moved_serializer_t::_this"]
        [::core::mem::offset_of!(ze_moved_serializer_t, _this) - 0usize];
};
unsafe extern "C" {
    #[doc = " Constructs an empty serializer.\n\n Parameters:\n   serializer: An uninitialized memory location where serializer is to be constructed.\n\n Return:\n   ``0`` in case of success, ``negative value`` otherwise."]
    pub fn ze_serializer_empty(serializer: *mut ze_owned_serializer_t) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Finishes serialization and returns underlying bytes.\n\n Parameters:\n   serializer: A data serializer.\n   bytes: An uninitialized memory location where bytes is to be constructed."]
    pub fn ze_serializer_finish(
        serializer: *mut ze_moved_serializer_t,
        bytes: *mut z_owned_bytes_t,
    );
}
unsafe extern "C" {
    #[doc = " Returns a deserializer for :c:type:`z_loaned_bytes_t`.\n\n The `bytes` should outlive the reader and should not be modified, while reader is in use.\n\n Parameters:\n   bytes: Data to deserialize.\n\n Return:\n   The constructed :c:type:`ze_deserializer_t`."]
    pub fn ze_deserializer_from_bytes(bytes: *const z_loaned_bytes_t) -> ze_deserializer_t;
}
unsafe extern "C" {
    #[doc = " Checks if deserializer parsed all of its data.\n\n Parameters:\n   deserializer: A deserializer instance.\n\n Return:\n   ``True`` if there is no more data to parse, ``false`` otherwise."]
    pub fn ze_deserializer_is_done(deserializer: *const ze_deserializer_t) -> bool;
}
unsafe extern "C" {
    #[doc = " Serializes array of bytes and writes it into an underlying :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the data to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_buf(
        serializer: *mut ze_loaned_serializer_t,
        val: *const u8,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes slice and writes it into an underlying :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   serializer: A serializer instance.\n   val: A slice to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_slice(
        serializer: *mut ze_loaned_serializer_t,
        val: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes next portion of data and advances the reader position.\n\n Parameters:\n   deserializer: A deserializer instance.\n   val: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the deserialized slice.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_slice(
        deserializer: *mut ze_deserializer_t,
        val: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a null-terminated string and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_str(
        serializer: *mut ze_loaned_serializer_t,
        val: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a substring and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The substring should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   start: Pointer to the start of the substring to serialize.\n   len: Length of the substring to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_substr(
        serializer: *mut ze_loaned_serializer_t,
        start: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a string and writes it into an underlying :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   serializer: A serializer instance.\n   val: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_string(
        serializer: *mut ze_loaned_serializer_t,
        val: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes next portion of data and advances the reader position.\n\n Parameters:\n   deserializer: A deserializer instance.\n   val: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the deserialized string.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_string(
        deserializer: *mut ze_deserializer_t,
        val: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initiate serialization of a sequence of multiple elements.\n\n Parameters:\n   serializer: A serializer instance.\n   len: Length of the sequence. Could be read during deserialization using\n     :c:func:`ze_deserializer_deserialize_sequence_length`.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_serializer_serialize_sequence_length(
        serializer: *mut ze_loaned_serializer_t,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Initiate deserialization of a sequence of multiple elements.\n\n Parameters:\n   deserializer: A deserializer instance.\n   len: A pointer where the length of the sequence (previously passed via\n     :c:func:`ze_serializer_serialize_sequence_length`) will be written.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserializer_deserialize_sequence_length(
        deserializer: *mut ze_deserializer_t,
        len: *mut usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes data into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized data.\n   data: Pointer to the data to serialize.\n   len: Number of bytes to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_buf(bytes: *mut z_owned_bytes_t, data: *const u8, len: usize)
    -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a string into a :c:type:`z_owned_bytes_t`.\n\n The string should be a valid UTF-8.\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   s: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_string(
        bytes: *mut z_owned_bytes_t,
        s: *const z_loaned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a null-terminated string into a :c:type:`z_owned_bytes_t`.\n The string should be a valid UTF-8.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   value: Pointer to the string to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_str(
        bytes: *mut z_owned_bytes_t,
        value: *const ::core::ffi::c_char,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a substring into a :c:type:`z_owned_bytes_t`.\n The substring should be a valid UTF-8.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized string.\n   start: Pointer to the the start of string to serialize.\n   len: Length of the substring to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_substr(
        bytes: *mut z_owned_bytes_t,
        start: *const ::core::ffi::c_char,
        len: usize,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a slice into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized slice.\n   slice: Pointer to the slice to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_slice(
        bytes: *mut z_owned_bytes_t,
        slice: *const z_loaned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int8_t` into a :c:type:`z_owned_bytes_t` .\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int8_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int8(bytes: *mut z_owned_bytes_t, val: i8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int16_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int16_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int16(bytes: *mut z_owned_bytes_t, val: i16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int32_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int32_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int32(bytes: *mut z_owned_bytes_t, val: i32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `int64_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `int64_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_int64(bytes: *mut z_owned_bytes_t, val: i64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint8_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint8_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint8(bytes: *mut z_owned_bytes_t, val: u8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint16_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint16_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint16(bytes: *mut z_owned_bytes_t, val: u16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint32_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint32_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint32(bytes: *mut z_owned_bytes_t, val: u32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `uint64_t` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `uint64_t` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_uint64(bytes: *mut z_owned_bytes_t, val: u64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `float` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `float` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_float(bytes: *mut z_owned_bytes_t, val: f32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `double` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `double` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_double(bytes: *mut z_owned_bytes_t, val: f64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Serializes a `bool` into a :c:type:`z_owned_bytes_t`.\n\n Parameters:\n   bytes: An uninitialized :c:type:`z_owned_bytes_t` to contain the serialized int.\n   val: `bool` value to serialize.\n\n Return:\n   ``0`` if serialization is successful, ``negative value`` otherwise."]
    pub fn ze_serialize_bool(bytes: *mut z_owned_bytes_t, val: bool) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a :c:type:`z_owned_slice_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   str: Pointer to an uninitialized :c:type:`z_owned_slice_t` to contain the deserialized slice.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_slice(
        bytes: *const z_loaned_bytes_t,
        dst: *mut z_owned_slice_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a :c:type:`z_owned_string_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   str: Pointer to an uninitialized :c:type:`z_owned_string_t` to contain the deserialized string.\n\n Return:\n   ``0`` if deserialization is successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_string(
        bytes: *const z_loaned_bytes_t,
        str_: *mut z_owned_string_t,
    ) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int8_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int8_t` to contain the deserialized.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int8(bytes: *const z_loaned_bytes_t, dst: *mut i8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int16_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int16_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int16(bytes: *const z_loaned_bytes_t, dst: *mut i16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int32_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int32_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int32(bytes: *const z_loaned_bytes_t, dst: *mut i32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `int64_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `int64_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_int64(bytes: *const z_loaned_bytes_t, dst: *mut i64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint8_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint8_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint8(bytes: *const z_loaned_bytes_t, dst: *mut u8) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint16_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint16_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint16(bytes: *const z_loaned_bytes_t, dst: *mut u16) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint32_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint32_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint32(bytes: *const z_loaned_bytes_t, dst: *mut u32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `uint64_t`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `uint64_t` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_uint64(bytes: *const z_loaned_bytes_t, dst: *mut u64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `float`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `float` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_float(bytes: *const z_loaned_bytes_t, dst: *mut f32) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a `double`.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `double` to contain the deserialized number.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_double(bytes: *const z_loaned_bytes_t, dst: *mut f64) -> z_result_t;
}
unsafe extern "C" {
    #[doc = " Deserializes data into a boolean.\n\n Parameters:\n   bytes: Pointer to a :c:type:`z_loaned_bytes_t` to deserialize.\n   dst: Pointer to an uninitialized `bool` to contain the deserialized value.\n\n Return:\n   ``0`` if deserialization successful, or a ``negative value`` otherwise."]
    pub fn ze_deserialize_bool(bytes: *const z_loaned_bytes_t, dst: *mut bool) -> z_result_t;
}
unsafe extern "C" {
    pub fn ze_internal_serializer_null(obj: *mut ze_owned_serializer_t);
}
unsafe extern "C" {
    pub fn ze_internal_serializer_check(obj: *const ze_owned_serializer_t) -> bool;
}
unsafe extern "C" {
    pub fn ze_serializer_loan(obj: *const ze_owned_serializer_t) -> *const ze_loaned_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_loan_mut(obj: *mut ze_owned_serializer_t) -> *mut ze_loaned_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_move(obj: *mut ze_owned_serializer_t) -> *mut ze_moved_serializer_t;
}
unsafe extern "C" {
    pub fn ze_serializer_take(obj: *mut ze_owned_serializer_t, src: *mut ze_moved_serializer_t);
}
unsafe extern "C" {
    pub fn ze_serializer_drop(obj: *mut ze_moved_serializer_t);
}
unsafe extern "C" {
    pub fn ze_serializer_take_from_loaned(
        dst: *mut ze_owned_serializer_t,
        src: *mut ze_loaned_serializer_t,
    ) -> z_result_t;
}
pub type __builtin_va_list = *mut ::core::ffi::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub _address: u8,
}
pub type __uint128_t = u128;
